{
    "_attachments": {
        "index.html": {
            "content_type": "text/html",
            "data": "PCFET0NUWVBFIGh0bWw+CjxodG1sPgogIDxoZWFkPgogICAgPHNjcmlwdCBzcmM9Ii9fYnJvd3NlcmlkL2luY2x1ZGUuanMiIHR5cGU9InRleHQvamF2YXNjcmlwdCI+PC9zY3JpcHQ+CgogICAgPCEtLSBPcHRpb25hbCBzdHlsZXMgLS0+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIHR5cGU9InRleHQvY3NzIiBocmVmPSIvX2Jyb3dzZXJpZC9zdHlsZS5jc3MiPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiB0eXBlPSJ0ZXh0L2NzcyIgaHJlZj0iY3NzL3N0eWxlLmNzcyI+CiAgPC9oZWFkPgoKICA8Ym9keT4KICAgIDxkaXYgY2xhc3M9ImhlYWQiPgogICAgICA8aDI+T0F1dGggTWFuYWdlbWVudCBmb3IgU2lnbiBvbiBQdWJsaXNoPC9oMj4KICAgICAgPGltZyBjbGFzcz0ibG9nbyIgc3JjPSJpbWFnZXMvbGVhcm5pbmctcmVnaXN0cnktbG9nby5wbmciPgogICAgPC9kaXY+CgogICAgPGRpdiBjbGFzcz0iY3JlZGVudGlhbHMiPgogICAgICA8ZGl2IGlkPSJicm93c2VyaWQiPgogICAgICAgIDxkaXYgY2xhc3M9InBpY3R1cmUiPjwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImxvZ2luIj4KICAgICAgICAgIDxpbWcgc3JjPSIvX2Jyb3dzZXJpZC9zaWduX2luX2dyZWVuLnBuZyI+CiAgICAgICAgPC9kaXY+CiAgICAgIDwvZGl2PgogICAgPC9kaXY+CiAgICA8ZGl2IGNsYXNzPSJtc2ciPjwvZGl2PgogICAgPGRpdiBjbGFzcz0ib2F1dGgiPgogICAgICA8ZmllbGRzZXQ+CiAgICAgICAgPGxlZ2VuZD5QdWJsaXNoIFBhc3N3b3JkPC9sZWdlbmQ+CiAgICAgICAgPHA+VXNpbmcgeW91ciBlbWFpbCBhZGRyZXNzIGFzIHVzZXJuYW1lIGFuZCB0aGlzIHBhc3N3b3JkLCB5b3UgbWF5IHB1Ymxpc2ggdG8gdGhlIEJhc2ljIFB1Ymxpc2ggb3IgU1dPUkQgaW50ZXJmYWNlcyB5b3VyIG93biBkaWdpdGFsbHkgc2lnbmVkIHJlc291cmNlIGRhdGEgZW52ZWxvcGVzLjwvcD4KCiAgICAgICAgPGxhYmVsIGZvcj0icGFzc3dvcmRfc2V0Ij5JcyBQYXNzd29yZCBTZXQ/PC9sYWJlbD4KICAgICAgICA8aW5wdXQgdHlwZT0iY2hlY2tib3giIGlkPSJwYXNzd29yZF9zZXQiIGRpc2FibGVkPSJkaXNhYmxlZCI+CgogICAgICAgIDxsYWJlbCBmb3I9InBhc3N3b3JkIj5QYXNzd29yZDwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9InBhc3N3b3JkIiBpZD0icGFzc3dvcmQiPgoKICAgICAgICA8bGFiZWwgZm9yPSJ2ZXJpZnlfcGFzc3dvcmQiPlZlcmlmeSBQYXNzd29yZDwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9InBhc3N3b3JkIiBpZD0idmVyaWZ5X3Bhc3N3b3JkIj4KICAgICAgICA8YnV0dG9uIGlkPSJzYXZlX3Bhc3N3b3JkIj5TYXZlPC9idXR0b24+CiAgICAgIDwvZmllbGRzZXQ+CiAgICAgIDxmaWVsZHNldD4KICAgICAgICA8bGVnZW5kPlNpZ25pbmcgSW5mb3JtYXRpb248L2xlZ2VuZD4KICAgICAgICA8cD5UaGUgZm9sbG93aW5nIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHJlc291cmNlIGRhdGEgZG9jdW1lbnQncyBpZGVudGl0eSBzaWduZXIgZmllbGQgYWxvbmcgd2l0aCB5b3VyIGVtYWlsIGFkZHJlc3Mgc28gdGhhdCB5b3VyIHN1Ym1pc3Npb25zIG1heSBiZSBpZGVudGlmaWVkLjwvcD4KICAgICAgICA8bGFiZWwgZm9yPSJmdWxsX25hbWUiPkZ1bGwgTmFtZTwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGlkPSJmdWxsX25hbWUiPgoKICAgICAgICA8YnV0dG9uIGlkPSJpbmZvX3VwZGF0ZSI+U2F2ZTwvYnV0dG9uPgogICAgICA8L2ZpZWxkc2V0PgogICAgICA8ZmllbGRzZXQ+CiAgICAgICAgPGxlZ2VuZD4yLUxlZ2dlZCBPQXV0aCBDb25maWc8L2xlZ2VuZD4KICAgICAgICA8cD5Vc2UgdGhlIGZvbGxvd2luZyB3aGVuIGNvbm5lY3RpbmcgeW91ciBhcHBsaWNhdGlvbiB0byBMUiB0byBzaWduIG9uIHlvdXIgYmVoYWxmLiAgSWYgdGhlIE9BdXRoIHNpZ25hdHVyZSBpcyBwcmVzZW50IHdoZW4geW91IHB1Ymxpc2gsIHRoZSBkb2N1bWVudHMgeW91IHB1Ymxpc2ggd2lsbCBiZSBzaWduZWQgYnkgdGhlIG5vZGUuPC9wPgogICAgICAgIDxsYWJlbCBmb3I9ImNvbnN1bWVyX2tleSI+b2F1dGhfY29uc3VtZXJfa2V5PC9sYWJlbD4KICAgICAgICA8aW5wdXQgdHlwZT0idGV4dCIgZGlzYWJsZWQ9ImRpc2FibGVkIiBpZD0iY29uc3VtZXJfa2V5IiB2YWx1ZT0ibm9kZV9zaWduX2tleSI+CgogICAgICAgIDxsYWJlbCBmb3I9ImNvbnN1bWVyX3NlY3JldCI+b2F1dGhfY29uc3VtZXJfc2VjcmV0PC9sYWJlbD4KICAgICAgICA8aW5wdXQgdHlwZT0idGV4dCIgZGlzYWJsZWQ9ImRpc2FibGVkIiBpZD0iY29uc3VtZXJfc2VjcmV0Ij4KCgogICAgICAgIDxsYWJlbCBmb3I9InRva2VuIj5vYXV0aF90b2tlbjwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGRpc2FibGVkPSJkaXNhYmxlZCIgaWQ9InRva2VuIiB2YWx1ZT0ibm9kZV9zaWduX3Rva2VuIj4KCiAgICAgICAgPGxhYmVsIGZvcj0idG9rZW5fc2VjcmV0Ij5vYXV0aF90b2tlbl9zZWNyZXQ8L2xhYmVsPgogICAgICAgIDxpbnB1dCB0eXBlPSJ0ZXh0IiBkaXNhYmxlZD0iZGlzYWJsZWQiIGlkPSJ0b2tlbl9zZWNyZXQiPgoKICAgICAgICA8YnV0dG9uIGlkPSJyZWdlbmVyYXRlIj5SZXZva2UgYW5kIFJlZ2VuZXJhdGU8L2J1dHRvbj4KICAgICAgPC9maWVsZHNldD4KICAgICAgCiAgICA8L2Rpdj4KICA8L2JvZHk+CgogIDwhLS0gUmVjb21tZW5kZWQgY29udmVuaWVuY2UgQVBJIC0tPgogIDxzY3JpcHQgc3JjPSIvX3V0aWxzL3NjcmlwdC9qcXVlcnkuanMiIHR5cGU9InRleHQvamF2YXNjcmlwdCI+PC9zY3JpcHQ+CiAgPHNjcmlwdCBzcmM9Ii9fdXRpbHMvc2NyaXB0L29hdXRoLmpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPjwvc2NyaXB0PgogIDxzY3JpcHQgc3JjPSIvX3V0aWxzL3NjcmlwdC9zaGExLmpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPjwvc2NyaXB0PgogIDxzY3JpcHQgc3JjPSIvX2Jyb3dzZXJpZC9tYWluLmpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPjwvc2NyaXB0PgogIDxzY3JpcHQgc3JjPSJtb2R1bGVzLmpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPjwvc2NyaXB0PgogIDxzY3JpcHQgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij4KICAgIHZhciBtYW5hZ2VfdG9rZW5zID0gcmVxdWlyZSgibGliL21hbmFnZS10b2tlbnMiKTsKCiAgICBtYW5hZ2VfdG9rZW5zLnJlZ2lzdGVyQ2FsbGJhY2tzKCk7CiAgPC9zY3JpcHQ+CjwvaHRtbD4="
        },
        "css/style.css": {
            "content_type": "text/css",
            "data": "CmRpdi5vYXV0aCB7CiAgICBkaXNwbGF5OiBub25lOwogICAgd2lkdGg6IDEwMCU7CiAgICBjbGVhcjogYm90aDsKfQoKZGl2Lm9hdXRoIGlucHV0W3R5cGU9Y2hlY2tib3hdLCBkaXYub2F1dGggbGFiZWxbZm9yPXBhc3N3b3JkX3NldF0gewogICAgZGlzcGxheTogaW5saW5lOwogICAgd2lkdGg6IDI1cHg7Cn0KCmRpdi5vYXV0aCBsYWJlbCwgZGl2Lm9hdXRoIGlucHV0IHsKICAgIGRpc3BsYXk6IGJsb2NrOwogICAgd2lkdGg6IDEwMCU7Cn0KCmRpdi5oZWFkICwgZGl2LmNyZWRlbnRpYWxzIHsKICAgIHdpZHRoOiAxMDAlOwogICAgY2xlYXI6IGJvdGg7Cn0KCiNicm93c2VyaWQgewogICAgd2lkdGg6IGF1dG87Cn0KCmRpdi5sb2dpbiB7IAoKfQoKLmhlYWQgaDIgewogICAgZmxvYXQ6IGxlZnQ7CiAgICB3aWR0aDogNjAlOwp9CgoKLnBpY3R1cmUgewogICAgZmxvYXQ6IGxlZnQ7Cn0KCmltZyB7CiAgICBib3JkZXI6IG5vbmU7Cn0KCi5sb2dvIHsKICAgIGZsb2F0OiByaWdodDsKfQoKLmNsZWFyOiBib3RoOw=="
        },
        "images/learning-registry-logo.png": {
            "content_type": "image/png",
            "data": "iVBORw0KGgoAAAANSUhEUgAAARMAAABxCAYAAAD24kddAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAGmhJREFUeNrsXUFy4zpzxkzNNvX0TvDoE4x8gX/kbTaWFllbOkDKViqVra1tKhVZlQNYXmdheZOt5FzAnBOY/wl+/ZUDvLA1H8YwDJAACJCUp78q1YwlkWo2Gh+6Gw1ACAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDEYJPrIKPj3/45/8elv9clq+sfN3/33/905q10pruR+U/9MpLvW+YTBjHbtAvIBKJGRNKK3q/Kf+5Vt66LfU+/6jP+6VnDK5jXyo/75PC/vN//kKj/EB//1/+8X93PfZKMu3t8/LFZJIel9rfV+WLySSicQ/g9n0rX0P8v+r7B1IhNxGvp/K1K0lmn5g0dDmNJKJ8X/53Bzm/l69NSTL7jtt44Pgeox3dCyaT5gQyLl8XdeRR0Sgy9rzCPSn+fKQOG5NYSlKgUXwJeUMwUp7xrrwfEcuqJ8TCaBe30l6Vvz8sPiUmkQwx4zghS1MHJWJZlKRSeJDbEu5/rsaxIJOXlHKWpFK01cAIH7fa2+TZnXFfb0X/Y3i1nIBt4Ilca6zc1kiwqPNUSvme0cASdM2NQih/JpaT8hXzNjwVJhPG0YY5pfFOMep3ES8SeU1LGWa2UQAZ9qH2NoVfN5oXkVJ+0tG4JC3yUo7C9dUS5IWrF+jguWba27lv2ArZ3iXr1fuXn+3q5LB9B4OjtBmvSQHl2srnSinD0XkmeNi7BrmG2CAymakNiAZ7NhFF+b1PimeyFWG5nRCQ8UxSeSmhngnacwqiHcYILxV5LqHfQU1IeF9FAgYvc11+f1Zhi2tdXgx+d8rvnsrP8dml4fmlfPMaghjj3gNcYxzkUsqg/c5QuddQuQ/p+FEtF0A7PUD2g15bIRMI+WAYZboGNciEWBwGtrV0DIEGzDsgE9mgZyWh5H0gE60TOIWXdfUTIPK7AL1aDRlyPujtCM94VKHrE9kBDTU4h1AZ9x25tJvNSzCE0+TRnRi+l0wGz7RDDsLLDTKd1RH754jG2jciEZBpC7JbVhCJ0DrOU8tyHoiuJLFpD8KZqTIiOYeX5XV3Ncb8HEjQU4SmJpjac1nzOwPtOt1upT2PHNvtAc/nIl9WYadJZFAGUZf85VDpLyaZRDIygeFtRb/n06UhTx2Ip2s577okFBjRnSUUI++AvJmJMBe8UadfWm5tyqHtMQJPcF96zTE66rj0eAyXDljUdCg1BFjDS7jF3ya7id1mMWW4rhhEC/FaF/VmYAsR+ksDwxtZDO9YkWnuXlcgQtmXIU8X04hLxzBjU7b/k6H9yUNZGXIoU0fXfFdevwb5q+0xIHurc7M1zCH7HiRJIdHX8rVyzPHkkFHNuS0MshHORZoakkYyILS8spDITNUnvivrq4Kcg8+BRDI0xKoxsNNebeIPzdh95NwnIJRhB16JPqoXtnwFknXrQC9iYovx0XHuHUOaqhzOreyE9Fs09V++Jo6EVOidWJFt1VA2V8SQ4dqSYznV9UAES/oRDZZZfAkwukFATG1T1kbUlMcr5ffnIm3xW2Zxg2XWnKptd7ZZF638ftwwbDrouLznaYtVsxeG9xY11ywMXsdYvF9/sla+d+vQoXeGjuDT7quGuqiqVdpZ2is2YshgCvnqZn/mof0sJMy5a9hRdnA1ndx4PPgGrxnyNKFl+XUd+ACqUC07MhEK1YE4MTU6vZRzXl4/Fq9ToKHkdoecQhsYOhrtm9EMa6cqc0+YrqUOPqip9xgqA0fwIBWhBqaoeObc8Mwp0EgGDMKmfrqp629YqjJNSiaYihs3UM68aUmxdK8TFMcNNXI4aXIz5Dw2IJVlIAFTYdvUldASkMnUoeMULs9mKSiTiUa5mHKQshN62FjbIXYKGUzt6VoQ+JSUTJRCoBC8KyCLoOw1GLRPhXJGUikJYQdCmQbcYlle38YiwYFjzF2HqiKuKbyOUcJwtRAM77aJoUMfz+Qq0ADIG4me6Vaq+UYx75miTBlEMCtJ4SmAkGXB0bHsg7Ew6JW8kAdRn6gsEFr9NZDIBK5ldIAvjp1sIPzm+iWi7uilrEIeiTR1IUnrZShcwb4nvoRyVV63anO1sY0Y6ohAz1coRVOZJSfzhH9zpSp11IBMGHYvZJCyH7h6JiFeySIBkTwn7vBZ6hYGocgtEHxwmdg72Rm8vNsIoemVQa/k/U1iLBZkWNMApiTtkMjdoU2/hfzmZw9D9sqRqEv6I2Eq0lfaZm00NFYK+yaipyChVDB1bOcQsjTSK7x0GU1TznVEMmI6iDZA6Bg7RCHTJGSCGRwfIz7kB1py244ZM+GX6BqItInmx5BBhIwPC9qWyquSoB08kgvmgWRtuqxYSyREgxlSF8/Et2HnifZnXYv0Ze7f2mplJGUXnpedp5IHU/Z6Jx+Rt1FBJEPxfiV2rXeHWR3bZ7Y6pm/MDUF9Zm8YlJ71DdwpjVC+HkSDdUYuORMfl7NIdYQCCOq0Yn+HowPyJz7PknoKnHIyD4aRjDryQs50KWtdLg2jmF4KvzHIvUQ8v0GRVAY7u64gIw59AvoM1vKYvEVaHVxgANFXUgdtDva5ZgQZed500YKCaPEW7VlxZmHeJuiCoLxKv0vyGSXULXX8WwuJ0Wj2J73Ej0T4tcE2NobBZGUJ2cgD+Rvu9yLeVlYXphDQchwKo7pNb4V9vY0k8Td7roSmKerCHJ/Gk+XkbSlph0VoJ3j4GCFQ61spoLrVhxB9O1Th+J7U6zxwUFhjodi7dhJ+K2rJhk6FeeZq1OTZHPVTRLwm9veCrkE/cWmDHLrPUpDJV497JT/LxubKKd7KqbDv+eCEmuRUKviQ8DdP/RSG+9/XXHMDXa4dZT+r2tYPBDWp6SQ73GeCNtW9pL1Bno3W1kXAgLYK8BQXjvp0vXdKGdQ2OIFOc4MTQDVhp+jDQX3gU03HevZw/Xt15CRmoS4C8gxnba/NwIZIroVsRci6IeSaMngQhcd1Mp7W186QjkI3fx5po2Fuk6lObm0qcx0yoCky7Vzb3vWa2N/zvcZ1Q2vtmhvxvmiwtn/XkYnPkQ+nfdwxG8k9mSzMekomQ+QhXEMjPiOa4WL7crZNbmh95tJHMaM29e0Xn2MJ3kcikW4+Nso5UVz3KoZuPQmbYiNpBkO83Zekbr9a1ZMZG/pR7QD7+VfSLHbcInftd/EjaWuKr7vaz9bZPW97FzbGhwF55lt46zYv3rSns1P64ktNPOaKogvNlJ1KFlRtfBfBKfui6OfD/NZRQ+fCfaaGDx73txXSbdHBYskusRbva4HIxl+wfcd35f1vFfa3akQmwm9GpCvjlsvzD3t+lP8++m4khKQUZbhvEWPyqP+xSESOthn+Xpc2MutIDlmUt2pjw3DshEezOHeWEMhlcmLmmsL4HCkH0oeR8nBwVNlofytfQRsyIwxadyR/7z3BI4VeVTvtKEyUperUzg/Yga+N0J7smXKFO89LycYmPv3hy5Ebyk6YNx6ewmgKuGibj+Te/mKueow8QaeDH8jLdL51K0WecAzOlGUQpm0y9wi16fUUsr1qNDIJONekLUNaNgmDWoznGWnwpHl9stO0HY537s2DVJI9e91sjg85dOE6+ozQjcOghPCRhaeR/by4G/GjNJ9smQaSsxaPD/ml8CViZ011qlmlu49tEH1HCRkGUcekMuR1xwbmUyLPIY6/ndy2bZu/Iuo8k+8e9xrZ5q97DHmgufRWWt/lHrun+fzudzZbxjF6JjvP+9GIf9PyM+xEnL0upLdSKN5KG17Alef3vRJj5fMs8Rvkec1lzgg1OuoSA9LjfV1OSSG/c5BxprUFeXtBm19j+pTa4auSUzgkBPWpVMh/juea1Zy0KI8ZKaCDjYMsU8sz5rgP7WJWewSJJfl68JCVXJmx/gWyP8C+6fMJVUvj/WvxupXpHronve+0e9yI1x3z5q45Q8Vufv5u3TW1azxKb+NFuC9Jpoc6aXP1cPnQW5Fu4xxS/CIVqcAonn30W8ryu8f9TWt+TmBcNhLLy984tdzvSpj3MbHpbu4SPkIPdecfFSCNHTrhViXY8v1JhcxL3UYryEeeo5052vsCYZTpXj4LZef6fQyyHxZ51tz3tvzOHNfrehJ49qKmPcbi7SZZTotLXcrpfbyTQcBI2xQpvQdi/meMmKm8Ep97+07XmTrnZU0bDU2zSxQGCr/9QUl327pNsNF5XxxCvQz3mxoGj6rB5Nxgo8Ma8s087H0J3bh6JK5ymt7L4DEMHT3dkaVd6nBheE4Rg0zuPQ34GvPZbSH1oUvBu3U7dCLfXf8fWwqr9gZX2aQDcn0XeG0sOSkroShuvM806Z2FIGLgwTTSix+7+tFrZhlcpzoBIyzwmXm7j9R+e6196ojCFGqOQxyK2joTqh3BXpE+I+hdec1ZF5slJcI+MpFIt96nExSRS7A3MOA9Or3MD6zU+FgpA9cx0+NvEKS+UGyIDnDj4ZnlCB82GvFOlXvGJvexQZYzPQdB4Rs8kanBO9pphHIKkhmK9/uw0jPOldDS18ZulcFFPXJ1rvz+BjnATPNuhhU5kHHoIOZatLYQfqfQDfH9SQsdfSfSnv6WC8dVkx5YBnSIVUydaTmGnbBPnZp0uzAl8pAcnBji9EudTECoJs/sXf4Dhh96vKqPzerPYxyRaW0PShKmdeE2cjy2/NcuUNYF6mdcPId7QxteVHhNF4aB1GkQc9qCAPX5vrmJMTZZOVZPZI3R9zRmDYplVHOVJxZ8TgYcG2Sx1mygg+jGPTBMu48MnlnlmUsgsHVbRmDKhaiEIl6L4eYtVlbvNSKpw9rR+5Be6NBA7k7271NO7+udHJgbS/xnCUOePPK9VikMQ5uiDBmJ9hGNMXeU2dThdw6y6CXscuTfVHkCjoa7SpHDgmzXllyIXIqhhzFdFMN5eTMo7NSPG7GFOuMGuRx3MiHvpCSGkPNqSEA643SSYjc2Mr6AKlgbBiLB7BBi/rvAWD+3TT22QL6mfMY+0lqibxYSqmtvCqWCNz2uue/OQIIZcjtXsLOdeK0xKUT7CClafDQQhSnU0UOcwicU891pLXQfCGoQOndlGWP3d8M9YjUqyblFNWwWwxvBVN6zCE8axj6sfN+QTKbIiVS9QnNYru2Yan3SxOHeI3iYL1Tj1MEiTW8P1XKcytghxPGayfUiE3gWTQ7aIoZ/AalkASQyRB7mJRGZqB3mJXRBIDUMSORFNKu7WTRI0sUc2WJgLXoO8nJRsDd3tKmRHHxaFDOPpP9Ms+3Lpm3mvQUBnamC4yJDGVkWtl2V98nhNpJ7u9e3MFBOFPwGJs3Uz1rY8mAqXkvsN1JOQ8myLLmWeokxdbnzTLS1hcKTvEln62Pag0XmQpA0ltOuVYMf2YjoYgc3D6wMA5sa6owN9lckJRPFHdxG6DSySvAKBBF6nyeR9izan3EzyKON0WfSAwM0jYL3kUjO1GYj4ZZgHLVEKhsMIjIMGIFcxhZCWfX1pAEkYvWcED3HXBkMg0OcYDLBgcgT5AK62rJxKPwXIh4DKheudeCF6HDeLgEzWIcDoAzPY+p01FFvau45TfGgkPUKz/duj1aM0uT2ryvW74xFv/ebudfIJEPOR68o3ofMaAYfdYHT1c5E5OpQz3Dpp0sW2DH6SCRnfRndIIeut5FLclpZ50Ie7IuhpN7UZsOqbSCU1bIpIBcxUueqTMBDLwtxfNgY+qvp1MugSutG5+YgIXvSERv/4fFdavjTno8aeZ+IpMbdvashkpFQdoQXhsV18FRMo59xXxl9l/kE+KYNVHVJ1X3DAat1jx463xi8qcyQX/FG4z1gEfKcifol5CnyGFUu80+WlTF+aZAkZ2jhWErQKD3p6XaClIzUz14ZYeuHmZqkU0KFa0PHyy0kP9bufVj8h13w5JqQry3Ylp7DoWd8MIWcFR7SzsMrPqzORrl9Bntu41wfvejvXZlF6IAWZUNpVLdOSlLR919oJcypKFx7U54No6B1Fd+F+74cqbHo6ayNqlvTepsRwpccerYu7ReWfU2QFLSd62Jbwr9Gxxu1QJpjkAqRxHfFIx4bbOfWRgR4TlOh3Va3WxrwEpQDvAnR0GbDCrIJQtTjQelMX4Q9uxbsfOgwKtiM+FaEnSUS2xs5TUwke8f36gxwB1LeW9phVEMk64p7r4V7MSR9d+4Z6jjpAHZiygHKneWuxdvdzfQQtS6Hsgmw6yjt50kYm16QCQiFDgqnRpmIdpOeuoLWNUZM7pzcp6JNOQu4zm3kRzYGQwwyFujy1OP6HXJAt473PhH2Q+Vz6EyGHD5koud8cpve8f6pcC/WkjutuSwGnYv6nF2h/fajq+wN7UJNCQT3hU+pe04Z+hCTX4g0tQFnauEaEndDxH1rnxvh2kuRroaB5Lxv+9weJENldeMqhgutbKDzhzaSFggHGhklZoIGSgfScxZ/6p26ajtLTCdfQD6nbTiVupKvBm/hO+TaBDwbyfJNvM/5fTfZRojsjnKYlnjMmtjnp7aMGuXzpJhz0bzY7ecRFbFXIysd5SKSnDsRuMHyRwc6ytIlHFKuIZL5m07U8DIZ7gPM1oeQXdDa8aCoS6H8wA0W6sk4W07JjSxuZK6OBmQ4KXdwQ6eX5dSqnHLH9KEwJ27liP8EOXMmkFqoiVeaEnZZpTq2kDbDHReWfFQjfGK9MjocIf80DB7WXJJlW0ghzNsrMty9EsJJ08GPyYTRpWHbjimhUfJRvCZjM3iwU5NXYjuag/X7l7HihZBn/5swz0ZFCRO/sMoZHYKmhE3ru6bCrbCwcptHxptNy8c17dAYn1nfjK4Atzq03qcQ/Vx+0Ce4FGXOYuX2OMxh9CmWlyUEWYUnQsTz2PYU+5HqlLw728FppMeom28xmTD62AlMpfl5T9cuHYM+38xAcrKawWAwGAwGg8FgMBgMBoPBYDAYDAaDkQD//h/LEb1YHn5W1uXHRhsVsCPR0jknRyoPPyvrksnkSLEWR3BU5RGO3FeshV8bv9xCv3/713nBzR4/BBA/Nr26ZW2wZ8JgMBjdeSbliJSJ16Xim3LUz2u+T2sExim+T6Nj+flOGSnptZPvaTIbPRR5j/JfuSM5fbfAb+89ZFXxToYafVq9J/oNmw4gc1bxeXTdKwnJw9oP5e/CxwPEbxU2Hdc8d1V7yj2BD+FtKq8U8u/V+6ty+epeaU9pg3tcVwS0ewbZ9nX9pjPPpBSCSETu2ESbrjyU7y0rvk97K6jb9D3gPaMCytez6/eBrSLXBWTaGmL5qbDvlbFFw9Nvy+0k6d8XvG9s9PK1VWSlTZbpSISvgardVnz2II3UgKWw7FmbUPfy+IcLGL38e+T5zENhOW8Jz/vgoy+0ybN4e1DWtso+G/SDG+hqb7IzH91rfetFsUGyqWfTdSCJKru4tgxyal/pzjOB4NQwJwrjzSumzmh39EX53Zlyj1soyMSMxLZz9X18nzr1qoKFx1DwDH/fC/+Dtui5zrRR5rt839JYhfZsKxjQrM6j0fM55bX0mpb/XxuebQBdzg3tMdbfT6378v9niodyLf8OAO3yvizvszCMvpfwesblZxtDZzB5QUQwj+X7N8p7N9QZqfNr7zchErn50JmlnX11L5+JrjvVbHABHd2p9wPuYYczi3dDZL222G60zaVCPRMy3lxXYIW7RK7+rYFRVyZmJIPV74Xv5zXkMFQ7oek+DpjrxgnZhxb2p8Zf6PJD1pAjLVeW0eJCvD/aUZVhbTHotnQfDNx/XfFsdTrRO+PeQhhz8XrsRxMSkd4oyT6pGDC8dI/OT4PWxGCDe8hvqneh3xjjel13G5Dx0BCi7mOFOMFkAgGGHtOB3y3v58LxQCU8fJ0x30Yw7NxT1oElFv+rCDhkG6NvpjY+SGyEDrJDh9FHwFXHum+Kld7R8Zw7PPdIJXPoJ9O9FRkakAeiv8SPc5D3tpDVwyuXns8sst3LPF9RQbqkp3PD+xsDGUu7WBlItMpm2s2ZwOU/L5X7gsaKamxgf7ovuYQvcMkyhxGubeSGzi1HzSJSx5oqbuq9OqopHa7oUvcRSLwwEOWFeD2RT/dcbJ0hq9H7vQg/YvM35NMedY8jEoYVBKQS0bDOZhTPI4fufnouyuC07gWZwB2Wx2v+UZWkDDFmsP8fcPlO8Ft93O9TxrJjJYH5oOQCQrDW3Naf7rziuWQpRpiOdf+zQ+D5VM/jZ2ig5AJsneGevJmKVyjx/h05hou+ldaDNApph5rNSM9lnMoraeqZ/BxR4O7R2cIPkeS6xmg763uRGYx9BkKhc2BepOcW6ikpOYQrGIeeZKTR9VKGHzHj3i51r03tXypeifRcZGehcMU2Xf+khwEJ2pts/c7ikTbych1kP68g9hXsQpLtxmAzA83T7Q+ZaIYQyxUmD+dRHA+GaDgild+RlGvaEeUorbr6QnP5L4WW/P0AupfPbTJ4GeJVPfdBN7awO0Y4Di/gFJ1zGZmoBjavRyGCVVW+TfxI4r4hW/TPgfJZ0QsyoXBGZ2UkY2ONkLmWFxgggTZS8gS9AEK787JxaBZoHStvI3MIpti26rOOdL/XB5LQTovnGZnyQFWfabqhzra1zGBsI7XPHiE+6echYs7Q6PXgWUj2eQ0RrCoIp+qzxgitgC3AyncwaqnIWIdHL2AML/itDAog5r1rkItIAZJvr8gqz0UuhEPlrMMobTOcR4dkXSu6p5G6/P5OuWYIW8gbPLft2o3BU9PloeTxHs8h22QI2eYRPYnDIWDwTui3zpoOJtDlBGHzNWQe4LVwGDzWGNxyi+7OXSpwQ9DoqAuwsSwlji4g2HigxNKZMvr0xTMZKXHu3/Hvb4hZ901yJz3wuLx0L68RhhqkjttHCM8S/57InoHM96kIoDdk8qtDVn6KH7Mee8Pnsh6BV9MyPjx41XAzEJk8VYzCyapGGQwmk48FCgEuTPU18FqmgjdiYvwi4DCneagzFa+rU2VMfsgjiR8L/XasJQaTCcOHVDLxOj1a8I5uDAaDwWAwGAwGg8FgMBgMBuP/BRgAZRDki4tS2fUAAAAASUVORK5CYII="
        },
        "modules.js": {
            "content_type": "application/json; charset=utf-8",
            "data": "LypnbG9iYWwgd2luZG93OiBmYWxzZSwgJDogZmFsc2UsIHBhZ2VUcmFja2VyOiBmYWxzZSwga2Fuc286IHRydWUgKi8KCi8qKgogKiBDb2RlIHJlcXVpcmVkIHRvIGJvb3RzdHJhcCB0aGUgYnJvd3NlciBDb21tb25KUyBlbnZpcm9ubWVudC4KICovCgooZnVuY3Rpb24gKGV4cG9ydHMpIHsKCiAgICBleHBvcnRzLm1vZHVsZUNhY2hlID0ge307CgogICAgZXhwb3J0cy5ub3JtYWxpemVQYXRoID0gZnVuY3Rpb24gKHApIHsKICAgICAgICB2YXIgcGF0aCA9IFtdOwogICAgICAgIHZhciBwYXJ0cyA9IHAuc3BsaXQoJy8nKTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gJy4uJykgewogICAgICAgICAgICAgICAgcGF0aC5wb3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1tpXSAhPT0gJy4nKSB7CiAgICAgICAgICAgICAgICBwYXRoLnB1c2gocGFydHNbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYXRoLmpvaW4oJy8nKTsKICAgIH07CgogICAgZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHApIHsKICAgICAgICBpZiAocCA9PT0gJy8nKSB7CiAgICAgICAgICAgIHJldHVybiBwOwogICAgICAgIH0KICAgICAgICB2YXIgcGFydHMgPSBwLnNwbGl0KCcvJyk7CiAgICAgICAgcGFydHMucG9wKCk7CiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSAmJiBwYXJ0c1swXSA9PT0gJycpIHsKICAgICAgICAgICAgcmV0dXJuICcvJzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTsKICAgIH07CgogICAgZXhwb3J0cy5jcmVhdGVSZXF1aXJlID0gZnVuY3Rpb24gKGN1cnJlbnQpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgewogICAgICAgICAgICB2YXIgcGF0aDsKICAgICAgICAgICAgaWYgKHRhcmdldC5jaGFyQXQoMCkgPT09ICcuJykgewogICAgICAgICAgICAgICAgdmFyIGRpciA9IGV4cG9ydHMuZGlybmFtZShjdXJyZW50KTsKICAgICAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLm5vcm1hbGl6ZVBhdGgoZGlyICsgJy8nICsgdGFyZ2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLm5vcm1hbGl6ZVBhdGgodGFyZ2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgbSA9IGthbnNvLm1vZHVsZUNhY2hlW3BhdGhdOwogICAgICAgICAgICBpZiAoIW0pIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBtb2R1bGU6ICcgKyBwYXRoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIW0ubG9hZGVkKSB7CiAgICAgICAgICAgICAgICBtLmV4cG9ydHMgPSB7fTsKICAgICAgICAgICAgICAgIG0uaWQgPSBwYXRoOwogICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvcGVydHkgbm90IHByb3ZpZGVkIGJ5IGNvdWNoZGIsIGJ1dCBpcyBieSBub2RlOgogICAgICAgICAgICAgICAgLy9tLnJlcXVpcmUgPSBleHBvcnRzLmNyZWF0ZVJlcXVpcmUocGF0aCk7CiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwcm9wZXJ0eSBub3QgcHJvdmlkZWQgYnkgY291Y2hkYiwgYnV0IGlzIGJ5IG5vZGU6CiAgICAgICAgICAgICAgICAvL20uZmlsZW5hbWUgPSAnJzsKICAgICAgICAgICAgICAgIC8vIFRPRE86IG1vZHVsZSBwcm9wZXJ0aWVzIHByb3ZpZGVkIGJ5IGNvdWNoZGIsIGJ1dCBub3QgYnkga2Fuc28KICAgICAgICAgICAgICAgIC8vICogY3VycmVudAogICAgICAgICAgICAgICAgLy8gKiBwYXJlbnQKICAgICAgICAgICAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgKmJlZm9yZSogY2FsbGluZyBtLmxvYWQgc28gY2lyY3VsYXIKICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVzIGRvbid0IGJsb3cgdGhlIGNhbGwgc3RhY2sKICAgICAgICAgICAgICAgIG0ubG9hZGVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIC8vbS5sb2FkKG0sIG0uZXhwb3J0cywgbS5yZXF1aXJlKTsKICAgICAgICAgICAgICAgIG0ubG9hZChtLCBtLmV4cG9ydHMsIGV4cG9ydHMuY3JlYXRlUmVxdWlyZShwYXRoKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG0uZXhwb3J0czsKICAgICAgICB9OwogICAgfTsKCiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgLy8gbWFrZSByZXF1aXJlIGF2YWlsYWJsZSBnbG9iYWxseSwgdW5sZXNzIGFscmVhZHkgaW4gYSBjb21tb25qcwogICAgICAgIC8vIGVudmlyb25tZW50CiAgICAgICAgdGhpcy5yZXF1aXJlID0gZXhwb3J0cy5jcmVhdGVSZXF1aXJlKCcnKTsKICAgIH0KCn0oKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmthbnNvID0ge306IG1vZHVsZS5leHBvcnRzKSk7CgoKLyoqCiAqIENvbW1vbkpTIG1vZHVsZXMgYXJlIHdyYXBwZWQgYW5kIGFwcGVuZGVkIHRvIHRoaXMgZmlsZS4KICovCi8qKioqKioqKioqIGxpYi9hcHAgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJsaWIvYXBwIl0gPSB7bG9hZDogKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUpIHsKCgoKfSl9OwoKLyoqKioqKioqKiogbGliL21hbmFnZS10b2tlbnMgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJsaWIvbWFuYWdlLXRva2VucyJdID0ge2xvYWQ6IChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCByZXF1aXJlKSB7CgoKdmFyIHNlc3Npb24gPSByZXF1aXJlKCJzZXNzaW9uIiksCiAgICB1c2VycyA9IHJlcXVpcmUoInVzZXJzIiksCiAgICBfID0gcmVxdWlyZSgidW5kZXJzY29yZSIpLl87CgpmdW5jdGlvbiBnZXRPQXV0aChlbWFpbCwgZG9jLCByZWdlbmVyYXRlKSB7CiAgICBpZiAocmVnZW5lcmF0ZSB8fCAhKGRvYy5vYXV0aCAKICAgICAgICAmJiBkb2Mub2F1dGguY29uc3VtZXJfa2V5cyAKICAgICAgICAmJiBkb2Mub2F1dGguY29uc3VtZXJfa2V5c1tlbWFpbF0KICAgICAgICAmJiBkb2Mub2F1dGgudG9rZW5zCiAgICAgICAgJiYgZG9jLm9hdXRoLnRva2Vucy5ub2RlX3NpZ25fdG9rZW4pKSB7CgogICAgICAgIGRvYy5vYXV0aCA9IGRvYy5vYXV0aCB8fCB7fTsKICAgICAgICBkb2Mub2F1dGguY29uc3VtZXJfa2V5cyA9IGRvYy5vYXV0aC5jb25zdW1lcl9rZXlzIHx8IHt9OwogICAgICAgIGRvYy5vYXV0aC50b2tlbnMgPSBkb2Mub2F1dGgudG9rZW5zIHx8IHt9OwoKICAgICAgICBkb2Mub2F1dGguY29uc3VtZXJfa2V5c1tlbWFpbF0gPSBleHBvcnRzLmdlbmVyYXRlU2VjcmV0KDMyKTsKICAgICAgICBkb2Mub2F1dGgudG9rZW5zLm5vZGVfc2lnbl90b2tlbiA9IGV4cG9ydHMuZ2VuZXJhdGVTZWNyZXQoMzIpOwoKICAgICAgICBpZiAoIWRvYy5yb2xlcyB8fCBfLmluZGV4T2YoZG9jLnJvbGVzLCAibm9kZV9zaWduIikgPT0gLTEpIHsKICAgICAgICAgICAgZG9jLnJvbGVzID0gZG9jLnJvbGVzIHx8IFtdOwogICAgICAgICAgICAvLyBkb2Mucm9sZXMucHVzaCgibm9kZV9zaWduIik7CiAgICAgICAgfQoKICAgICAgICB1c2Vycy51cGRhdGUoZW1haWwsIG51bGwsIGRvYywgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBnZXRVc2VySW5mbyhlbWFpbCk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICB9IGVsc2UgewogICAgICAgICQoIi5vYXV0aCIpLnNob3coNTAwKTsKICAgICAgICAkKCIjY29uc3VtZXJfa2V5IikudmFsKGVtYWlsKQogICAgICAgICQoIiNjb25zdW1lcl9zZWNyZXQiKS52YWwoZG9jLm9hdXRoLmNvbnN1bWVyX2tleXNbZW1haWxdKTsKICAgICAgICAkKCIjdG9rZW5fc2VjcmV0IikudmFsKGRvYy5vYXV0aC50b2tlbnMubm9kZV9zaWduX3Rva2VuKTsKICAgIH0KfQoKZnVuY3Rpb24gZ2V0U2lnbmluZ0luZm8oZW1haWwsIGRvYykgewogICAgaWYgKGRvYy5scnNpZ25hdHVyZSAmJiBkb2MubHJzaWduYXR1cmUuZnVsbF9uYW1lKSB7CiAgICAgICAgJCgiI2Z1bGxfbmFtZSIpLnZhbChkb2MubHJzaWduYXR1cmUuZnVsbF9uYW1lKTsKICAgIH0KfQoKZnVuY3Rpb24gc2V0TWVzc2FnZShtc2csIHdhaXQsIGNiKSB7CiAgICBpZiAoIXdhaXQpIHsKICAgICAgICB3YWl0ID0gMTAwMDA7CiAgICB9CgogICAgJCgiLm1zZyIpLmZhZGVPdXQoJ2Zhc3QnKS5lbXB0eSgpLnRleHQobXNnKS5mYWRlSW4oJ2Zhc3QnKS5kZWxheSh3YWl0KS5mYWRlT3V0KCdzbG93JykuaGlkZSgnZmFzdCcpOwoKICAgIGlmIChjYikgewogICAgICAgIGNiKCk7CiAgICB9Cn0KCmZ1bmN0aW9uIHNldFNpZ25pbmdJbmZvKCkgewogICAgZnVsbF9uYW1lID0gJCgiI2Z1bGxfbmFtZSIpLnZhbCgpOwogICAgaWYgKCQudHJpbShmdWxsX25hbWUpICE9PSAiIikgewogICAgICAgIHNlc3Npb24uaW5mbyhmdW5jdGlvbihlcnIsIHNlc3Npb25faW5mbyl7CiAgICAgICAgICAgIGlmIChzZXNzaW9uX2luZm8udXNlckN0eC5uYW1lKSB7CiAgICAgICAgICAgICAgICB1c2Vycy5nZXQoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSwgZnVuY3Rpb24oZXJyLCBkb2MpewogICAgICAgICAgICAgICAgICAgIGRvYy5scnNpZ25hdHVyZSA9IGRvYy5scnNpZ25hdHVyZSB8fCB7fQogICAgICAgICAgICAgICAgICAgIGRvYy5scnNpZ25hdHVyZS5mdWxsX25hbWUgPSBmdWxsX25hbWU7CgogICAgICAgICAgICAgICAgICAgIHVzZXJzLnVwZGF0ZShzZXNzaW9uX2luZm8udXNlckN0eC5uYW1lLCBudWxsLCBkb2MsIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZSgiVW5hYmxlIHRvIHNhdmUgc2lnbmluZyBpbmZvcm1hdGlvbi4iKTsKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1lc3NhZ2UoIkluZm9ybWF0aW9uIHNhdmVkLiIpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0pOyAKICAgICAgICAgICAgfTsKICAgICAgICB9KTsKICAgIH0KfQoKZnVuY3Rpb24gc2V0UGFzc3dvcmRJbmZvKGVtYWlsLCBkb2MpIHsKICAgIGlmIChkb2MucGFzc3dvcmRfc2hhKSB7CiAgICAgICAgJCgiI3Bhc3N3b3JkX3NldCIpLnByb3AoImNoZWNrZWQiLCB0cnVlKTsKICAgIH0gZWxzZSB7CiAgICAgICAgJCgiI3Bhc3N3b3JkX3NldCIpLnByb3AoImNoZWNrZWQiLCBmYWxzZSk7CiAgICB9Cn0KCmZ1bmN0aW9uIGdldFVzZXJJbmZvKGVtYWlsKSB7CiAgICB1c2Vycy5nZXQoZW1haWwsIGZ1bmN0aW9uKGVyciwgZG9jKSB7CiAgICAgICAgaWYgKCFlcnIpIHsKICAgICAgICAgICAgZ2V0T0F1dGgoZW1haWwsIGRvYyk7CiAgICAgICAgICAgIGdldFNpZ25pbmdJbmZvKGVtYWlsLCBkb2MpOwogICAgICAgICAgICBzZXRQYXNzd29yZEluZm8oZW1haWwsIGRvYyk7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICBzZXRNZXNzYWdlKGVycik7CiAgICAgICAgfQogICAgfSk7Cn0KCmZ1bmN0aW9uIHJldm9rZUFuZEdlbmVyYXRlKCkgewogICAgc2Vzc2lvbi5pbmZvKGZ1bmN0aW9uKGVyciwgc2Vzc2lvbl9pbmZvKXsKICAgICAgICBpZiAoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSkgewogICAgICAgICAgICB1c2Vycy5nZXQoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSwgZnVuY3Rpb24gKGVyciwgZG9jKXsKICAgICAgICAgICAgICAgIGlmICghZXJyKSB7CiAgICAgICAgICAgICAgICAgICBnZXRPQXV0aChzZXNzaW9uX2luZm8udXNlckN0eC5uYW1lLCBkb2MsIHRydWUpOyAKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc2Vzc2lvblRpbWVvdXQoKTsKICAgICAgICB9CiAgICB9KTsKfQoKZnVuY3Rpb24gc2Vzc2lvblRpbWVvdXQgKCkgewogICAgc2V0TWVzc2FnZSgiU2Vzc2lvbiBoYXMgdGltZWQgb3V0LiIsIDUwMDAwLCBmdW5jdGlvbigpewogICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTsKICAgIH0pOwp9CgpmdW5jdGlvbiBjaGVja1Bhc3N3b3JkTWF0Y2goKSB7CiAgICB2YXIgcGFzc3dkMSA9ICQoIiNwYXNzd29yZCIpLnZhbCgpOwogICAgdmFyIHBhc3N3ZDIgPSAkKCIjdmVyaWZ5X3Bhc3N3b3JkIikudmFsKCk7CiAgICBpZiAocGFzc3dkMSA9PT0gIiIgfHwgcGFzc3dkMiA9PT0gIiIgfHwgcGFzc3dkMSAhPT0gcGFzc3dkMikKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICByZXR1cm4gdHJ1ZTsKfQoKZnVuY3Rpb24gc2F2ZVBhc3N3b3JkKCkgewogICAgdmFyIHBhc3N3ZDEgPSAkKCIjcGFzc3dvcmQiKS52YWwoKTsKICAgIHZhciBwYXNzd2QyID0gJCgiI3ZlcmlmeV9wYXNzd29yZCIpLnZhbCgpOwogICAgaWYgKCBjaGVja1Bhc3N3b3JkTWF0Y2goKSApIHsKICAgICAgICBzZXNzaW9uLmluZm8oZnVuY3Rpb24oZXJyLCBzZXNzaW9uX2luZm8pIHsKICAgICAgICAgICAgaWYgKHNlc3Npb25faW5mby51c2VyQ3R4Lm5hbWUpIHsKICAgICAgICAgICAgICAgIHVzZXJzLmdldChzZXNzaW9uX2luZm8udXNlckN0eC5uYW1lLCBmdW5jdGlvbihlcnIsIGRvYyl7CiAgICAgICAgICAgICAgICAgICAgZG9jLnBhc3N3b3JkID0gcGFzc3dkMTsKCiAgICAgICAgICAgICAgICAgICAgdXNlcnMudXBkYXRlKHNlc3Npb25faW5mby51c2VyQ3R4Lm5hbWUsIG51bGwsIGRvYywgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlKCJVbmFibGUgdG8gc2F2ZSBwdWJsaXNoIHBhc3N3b3JkLiIpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZSgiUGFzc3dvcmQgc2F2ZWQuIik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCIjcGFzc3dvcmQiKS52YWwoIiIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgiI3ZlcmlmeV9wYXNzd29yZCIpLnZhbCgiIik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCIjcGFzc3dvcmRfc2V0IikucHJvcCgiY2hlY2tlZCIsIHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9KTsgCiAgICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICB9IGVsc2UgewogICAgICAgIHNldE1lc3NhZ2UoIlBhc3N3b3JkcyBkbyBubyBtYXRjaC4iKTsKICAgIH0KfQoKCmV4cG9ydHMucmVnaXN0ZXJDYWxsYmFja3MgPSBmdW5jdGlvbigpIHsKICAgICQuY291Y2guYnJvd3NlcmlkLmxvZ2luKGZ1bmN0aW9uKGV2dCwgZXJyLCBpbmZvKSB7IAogICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmIChpbmZvICYmIGluZm8uZW1haWwpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZm8uZW1haWwpOwogICAgICAgICAgICAgICAgZ2V0VXNlckluZm8oaW5mby5lbWFpbCk7CiAgICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnJvcikgewoKICAgICAgICB9IGZpbmFsbHkgewoKICAgICAgICB9IAogICAgfSk7CgogICAgJC5jb3VjaC5icm93c2VyaWQubG9nb3V0KGZ1bmN0aW9uKGV2dCwgZXJyLCBpbmZvKXsKICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7CiAgICB9KTsKCiAgICAkKCIjaW5mb191cGRhdGUiKS5iaW5kKCdjbGljaycsIHNldFNpZ25pbmdJbmZvKTsKICAgICQoIiNyZWdlbmVyYXRlIikuYmluZCgnY2xpY2snLCByZXZva2VBbmRHZW5lcmF0ZSk7CiAgICAkKCIjc2F2ZV9wYXNzd29yZCIpLmJpbmQoJ2NsaWNrJywgc2F2ZVBhc3N3b3JkKTsKfQoKCi8vIFNpbXBsZSBzZWNyZXQga2V5IGdlbmVyYXRvcgpleHBvcnRzLmdlbmVyYXRlU2VjcmV0ID0gZnVuY3Rpb24obGVuZ3RoKSB7CiAgICB2YXIgdGFiID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iOwogICAgdmFyIHNlY3JldCA9ICcnOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgIHNlY3JldCArPSB0YWIuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY0KSk7CiAgICB9CiAgICByZXR1cm4gc2VjcmV0Owp9CgoKCn0pfTsKCi8qKioqKioqKioqIHVzZXJzICoqKioqKioqKiovCgprYW5zby5tb2R1bGVDYWNoZVsidXNlcnMiXSA9IHtsb2FkOiAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSkgewoKLyoqCiAqICMjIFVzZXJzIG1vZHVsZQogKgogKiBGdW5jdGlvbnMgZm9yIHF1ZXJ5aW5nLCBjcmVhdGluZywgdXBkYXRpbmcgYW5kIGRlbGV0aW5nIHVzZXIgZG9jdW1lbnRzLgogKgogKiBGdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgZm9sbG93IHRoZSBub2RlLmpzIGNhbGxiYWNrIHN0eWxlLiBUaGUgZmlyc3QKICogYXJndW1lbnQgaXMgYW4gZXJyb3Igb2JqZWN0IChpZiBvbmUgb2NjdXJyZWQpLCB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyBhcmUKICogdGhlIHJlc3VsdHMgb2YgdGhlIG9wZXJhdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGFsd2F5cyB0aGUgbGFzdCBhcmd1bWVudCB0byBhCiAqIGZ1bmN0aW9uLgogKgogKiBAbW9kdWxlCiAqLwoKCnZhciBkYiA9IHJlcXVpcmUoJ2RiJyksCiAgICBzZXNzaW9uID0gcmVxdWlyZSgnc2Vzc2lvbicpLAogICAgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKSwKICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJykuXzsKCgovKioKICogUmV0dXJucyB0aGUgYXV0aGVudGljYXRpb24gZGF0YWJhc2UgZm9yIHRoZSBjdXJyZW50IHVzZXIncyBzZXNzaW9uLgogKgogKiBAbmFtZSBhdXRoZGIoY2FsbGJhY2spCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBhdXRoZGIgPSBmdW5jdGlvbihjYWxsYmFjaykgewogICAgZGIucmVxdWVzdCh7CiAgICAgICAgdHlwZTogIkdFVCIsCiAgICAgICAgdXJsOiAiL19zZXNzaW9uIgogICAgfSwKICAgIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpOwogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwLmluZm8uYXV0aGVudGljYXRpb25fZGIpOwogICAgfSk7Cn07CgoKLyoqCiAqIFJldHVybnMgc3VjY2Vzc2Z1bCBpZiB1c2VybmFtZSBpcyBpbiBhZG1pbiBkYXRhYmFzZS4KICoKICogQG5hbWUgZ2V0QWRtaW4odXNlcm5hbWUsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICogQGFwaSBwcml2YXRlCiAqLwoKdmFyIGdldEFkbWluID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhbGxiYWNrKSB7CiAgICBkYi5yZXF1ZXN0KHsKICAgICAgICB0eXBlOiAnR0VUJywKICAgICAgICB1cmw6ICcvX2NvbmZpZy9hZG1pbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh1c2VybmFtZSksCiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJwogICAgfSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBEZWxldGUgdXNlciBmcm9tIHVzZXIgZGF0YWJhc2UuCiAqCiAqIEBuYW1lIGRlbGV0ZVVzZXIoYXV0aGRiLCBpZCwgdXNlciwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyIGRhdGFiYXNlCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyIGlkCiAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyIGRvY3VtZW50CiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBkZWxldGVVc2VyID0gZnVuY3Rpb24oYXV0aGRiLCBpZCwgdXNlciwgY2FsbGJhY2spIHsKICAgIGRiLnJlcXVlc3QoewogICAgICAgIHR5cGU6ICdERUxFVEUnLAogICAgICAgIHVybDogJy8nICsgZGIuZW5jb2RlKGF1dGhkYikgKyAnLycgKyBkYi5lbmNvZGUoaWQpICsKICAgICAgICAgICAgICc/cmV2PScgKyBkYi5lbmNvZGUodXNlci5fcmV2KSwKICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nCiAgICB9LCBjYWxsYmFjayk7Cn07CgovKioKICogRGVsZXRlIHVzZXIgZnJvbSBhZG1pbiBkYXRhYmFzZS4KICoKICogQG5hbWUgZGVsZXRlQWRtaW4odXNlcm5hbWUsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICogQGFwaSBwcml2YXRlCiAqLwoKdmFyIGRlbGV0ZUFkbWluID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhbGxiYWNrKSB7CiAgICBkYi5yZXF1ZXN0KHsKICAgICAgICB0eXBlOiAnREVMRVRFJywKICAgICAgICB1cmw6ICcvX2NvbmZpZy9hZG1pbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh1c2VybmFtZSksCiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJwogICAgfSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBTYXZlIHVzZXIgdG8gdXNlciBkYXRhYmFzZS4KICoKICogQG5hbWUgc2F2ZVVzZXIoYXV0aGRiLCBkb2MsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlciBkYXRhYmFzZQogKiBAcGFyYW0ge09iamVjdH0gdXNlciBkb2N1bWVudAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjawogKiBAYXBpIHByaXZhdGUKICovCgp2YXIgc2F2ZVVzZXIgPSBmdW5jdGlvbihhdXRoZGIsIGRvYywgY2FsbGJhY2spIHsKICAgIHZhciB1cmwgPSAnLycgKyBhdXRoZGIgKyAnLycgKyBkb2MuX2lkOwogICAgdmFyIHJlcSA9IHsKICAgICAgICB0eXBlOiAnUFVUJywKICAgICAgICB1cmw6IHVybCwKICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkb2MpLAogICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSwKICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nCiAgICB9OwogICAgZGIucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogQ3JlYXRlIGEgbmV3IHVzZXIgaW4gdGhlIHVzZXIgZGF0YWJhc2UuCiAqCiAqIEBuYW1lIGNyZWF0ZVVzZXIodXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lCiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZAogKiBAcGFyYW0ge0hhc2h9IHByb3BlcnRpZXMKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICogQGFwaSBwcml2YXRlCiAqLwoKdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7CiAgICB2YXIgZG9jID0ge307CiAgICBkb2MuX2lkID0gJ29yZy5jb3VjaGRiLnVzZXI6JyArIHVzZXJuYW1lOwogICAgZG9jLm5hbWUgPSB1c2VybmFtZTsKICAgIGRvYy50eXBlID0gJ3VzZXInOwoKICAgIF8uZXh0ZW5kKGRvYywgcHJvcGVydGllcyk7CgogICAgZGIubmV3VVVJRCgxMDAsIGZ1bmN0aW9uIChlcnIsIHV1aWQpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIH0KICAgICAgICBkb2Muc2FsdCA9IHV1aWQ7CiAgICAgICAgZG9jLnBhc3N3b3JkX3NoYSA9IHNoYTEuaGV4KHBhc3N3b3JkICsgZG9jLnNhbHQpOwoKICAgICAgICBhdXRoZGIoZnVuY3Rpb24gKGVyciwgYXV0aGRiKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0KICAgICAgICAgICAgc2F2ZVVzZXIoYXV0aGRiLCBkb2MsIGNhbGxiYWNrKTsKICAgICAgICB9KTsKICAgIH0pOwp9OwoKCi8qKgogKiBDcmVhdGUgYSBuZXcgdXNlciBpbiB0aGUgYWRtaW4gZGF0YWJhc2UuCiAqCiAqIEBuYW1lIGNyZWF0ZUFkbWluKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZQogKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICogQGFwaSBwcml2YXRlCiAqLwoKdmFyIGNyZWF0ZUFkbWluID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykgewogICAgdmFyIHVybCA9ICcvX2NvbmZpZy9hZG1pbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh1c2VybmFtZSk7CiAgICB2YXIgcmVxID0gewogICAgICAgIHR5cGU6ICdQVVQnLAogICAgICAgIHVybDogdXJsLAogICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHBhc3N3b3JkKSwKICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsCiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJwogICAgfTsKICAgIGRiLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIFNhbml0aXplIHRoZSBhcmd1bWVudHMgYnkgYWxsb3dpbmcgdG8gb21pdCB0aGUgcHJvcGVydGllcyBhbmQKICogcHJlZGVmaW5pbmcgdGhlIHJvbGVzIGlmIHRoZXkncmUgbm90IHNldC4KICoKICogQG5hbWUgc2FuaXRpemVBcmd1bWVudHModXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYiwgY2IyKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUKICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkCiAqIEBwYXJhbSB7SGFzaH0gcHJvcGVydGllcwogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYjIKICogQGFwaSBwcml2YXRlCiAqLwoKdmFyIHNhbml0aXplQXJndW1lbnRzID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYiwgY2IyKSB7CiAgICBpZiAoIWNiKSB7CiAgICAgICAgY2IgPSBwcm9wZXJ0aWVzOwogICAgICAgIHByb3BlcnRpZXMgPSB7fTsKICAgIH0KICAgIGlmICghcHJvcGVydGllcy5yb2xlcykgewogICAgICAgIHByb3BlcnRpZXMucm9sZXMgPSBbXTsKICAgIH0KICAgIGNiMih1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNiKTsKfTsKCgovKioKICogRGVsZXRlcyBhbiBleGlzdGluZyB1c2VyIGRvY3VtZW50LCBnaXZlbiBpdHMgdXNlcm5hbWUuIFlvdQogKiBtdXN0IGJlIGxvZ2dlZCBpbiBhcyBhbiBhZG1pbmlzdHJhdGl2ZSB1c2VyIGZvciB0aGlzIGZ1bmN0aW9uCiAqIHRvIHN1Y2NlZWQuCiAqCiAqIEBuYW1lIGRlbGV0ZSh1c2VybmFtZSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSAtIFRoZSB1c2VybmFtZSBvZiB0aGUgdXNlciB0byBkZWxldGUKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKSAtIEZ1bmN0aW9uIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9mCiAqICAgICB0aGUgb3BlcmF0aW9uCiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogdXNlcnMuZGVsZXRlKCd1c2VybmFtZScsIGZ1bmN0aW9uIChlcnIpIHsKICogICAgIGlmIChlcnIpIC8vIHRoZXJlIHdhcyBhbiBlcnJvciBkZWxldGluZyB0aGUgdXNlcgogKiAgICAgZWxzZSAgICAgLy8gc3VjY2VzcwogKiB9KTsKICogYGBgCiAqLwoKZXhwb3J0cy5kZWxldGUgPSBmdW5jdGlvbiAodXNlcm5hbWUsIGNhbGxiYWNrKSB7CiAgICBleHBvcnRzLmdldCh1c2VybmFtZSwgZnVuY3Rpb24oZXJyLCB1c2VyLCBvcHRpb25zKSB7CiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfQoKICAgICAgICBnZXRBZG1pbih1c2VybmFtZSwgZnVuY3Rpb24oZXJyLCBhZG1pbikgewogICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICBpZiAoZXJyLnN0YXR1cyAhPT0gNDA0KSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBkZWxldGVVc2VyKG9wdGlvbnMuYXV0aGRiLCBvcHRpb25zLmlkLCB1c2VyLCBjYWxsYmFjayk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBkZWxldGVBZG1pbih1c2VybmFtZSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZGVsZXRlVXNlcihvcHRpb25zLmF1dGhkYiwgb3B0aW9ucy5pZCwgdXNlciwgY2FsbGJhY2spOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgIH0pOwp9OwoKCi8qKgogKiBHZXQgYSBzaW5nbGUgdXNlciBieSB1c2VybmFtZS4gVGhlIHRoaXJkIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayBpcyBhbiBpbmZvCiAqIG9iamVjdCB3aGljaCByZXR1cm5zIHRoZSBhdXRoZGIgdXNlZCwgYW5kIHRoZSByZWFsIGlkIG9mIHRoZSB1c2VyIHdpdGgKICogIm9yZy5jb3VjaGRiLnVzZXI6IiBwcmVmaXguCiAqCiAqIEBuYW1lIGdldCh1c2VybmFtZSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSAtIFRoZSB1c2VybmFtZSBvZiB0aGUgdXNlciB0byBnZXQKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHVzZXIsaW5mbykgLSBGdW5jdGlvbiBjYWxsZWQgb24gY29tcGxldGlvbgogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHVzZXJzLmdldCgndGVzdHVzZXInLCBmdW5jdGlvbiAoZXJyLCBkb2MpIHsKICogICAgIGlmIChlcnIpIC8vIHRoZXJlIHdhcyBhbiBlcnJvciBmZXRjaGluZyB0aGUgdXNlciBkb2N1bWVudAogKiAgICAgZWxzZSAgICAgLy8gc3VjY2VzcwogKiB9KTsKICogYGBgCiAqLwoKZXhwb3J0cy5nZXQgPSBmdW5jdGlvbih1c2VybmFtZSwgY2FsbGJhY2spIHsKICAgIHZhciBpZCA9ICdvcmcuY291Y2hkYi51c2VyOicgKyB1c2VybmFtZTsKCiAgICBhdXRoZGIoZnVuY3Rpb24gKGVyciwgYXV0aGRiKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB9CiAgICAgICAgZGIucmVxdWVzdCh7CiAgICAgICAgICAgIHR5cGU6ICdHRVQnLAogICAgICAgICAgICB1cmw6ICcvJyArIGRiLmVuY29kZShhdXRoZGIpICsgJy8nICsgZGIuZW5jb2RlKGlkKSwKICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJwogICAgICAgIH0sCiAgICAgICAgZnVuY3Rpb24gKGVyciwgdXNlcikgewogICAgICAgICAgICBjYWxsYmFjayhlcnIsIHVzZXIsIHthdXRoZGI6IGF1dGhkYiwgaWQ6IGlkfSk7CiAgICAgICAgfSk7CiAgICB9KTsKfTsKCgovKioKICogTGlzdCB1c2VycyBpbiB0aGUgYXV0aCBkYXRhYmFzZS4gQnkgZGVmYXVsdCwgaXQgd2lsbCBsaXN0IGFsbCB1c2Vycy4KICogQnkgdXNpbmcgdGhlIG9wdGlvbmFsIGBxYCBwYXJhbWV0ZXIsIHlvdSBjYW4gcGFzcyBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gdGhlCiAqIGBfYWxsX2RvY3NgIHZpZXcgZm9yIHRoZSBhdXRoIGRhdGFiYXNlLgogKgogKiBAbmFtZSBsaXN0KFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7T2JqZWN0fSBxIC0gUXVlcnkgcGFyYW1ldGVycyAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixsaXN0KSAtIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSByZXN1bHRpbmcKICogICAgIGxpc3QgKG9yIGVycm9yKQogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHVzZXJzLmxpc3QoZnVuY3Rpb24gKGVyciwgbGlzdCkgewogKiAgICAgaWYgKGVycikgLy8gdGhlcmUgd2FzIGFuIGVycm9yIHF1ZXJ5aW5nIHRoZSBhdXRoIGRhdGFiYXNlCiAqICAgICBlbHNlICAgICAvLyBzdWNjZXNzCiAqIH0pOwogKiBgYGAKICovCgpleHBvcnRzLmxpc3QgPSBmdW5jdGlvbihxLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CiAgICBpZiAoIXEuc3RhcnRrZXkpIHsKICAgICAgICBxLnN0YXJ0a2V5ID0gJyJvcmcuY291Y2hkYi51c2VyOiInOwogICAgfQogICAgaWYgKCFxLmVuZGtleSkgewogICAgICAgIHEuZW5ka2V5ID0gJyJvcmcuY291Y2hkYi51c2VyXyInOwogICAgfQogICAgYXV0aGRiKGZ1bmN0aW9uIChlcnIsIGF1dGhkYikgewogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTsKICAgICAgICB9CiAgICAgICAgdmFyIHJlcSA9IHsKICAgICAgICAgICAgdHlwZTogJ0dFVCcsCiAgICAgICAgICAgIHVybDogJy8nICsgZGIuZW5jb2RlKGF1dGhkYikgKyAnL19hbGxfZG9jcycsCiAgICAgICAgICAgIGRhdGE6IGRiLnN0cmluZ2lmeVF1ZXJ5KHEpLAogICAgICAgICAgICBleHBlY3RfanNvbjogdHJ1ZQogICAgICAgIH07CiAgICAgICAgZGIucmVxdWVzdChyZXEsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciB1c2VycyA9IF8ocmVzdWx0LnJvd3MpLnNlbGVjdChmdW5jdGlvbihyb3cpIHsKICAgICAgICAgICAgICAgIHJldHVybiByb3cuaWQubWF0Y2goL15vcmdcLmNvdWNoZGJcLnVzZXIvKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHVzZXJzKTsKICAgICAgICB9KTsKICAgIH0pOwp9OwoKCi8qKgogKiBDcmVhdGVzIGEgbmV3IHVzZXIgZG9jdW1lbnQgd2l0aCBnaXZlbiB1c2VybmFtZSBhbmQgcGFzc3dvcmQuCiAqIElmIHByb3BlcnRpZXMucm9sZXMgY29udGFpbnMgJ19hZG1pbicsIHVzZXIgd2lsbCBiZSBtYWRlIGFkbWluLgogKgogKiBAbmFtZSBjcmVhdGUodXNlcm5hbWUsIHBhc3N3b3JkLCBbcHJvcGVydGllc10sIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBUaGUgdXNlcm5hbWUgb2YgdGhlIG5ldyB1c2VyCiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIFRoZSB1bmhhc2hlZCBwYXNzd29yZCBmb3IgdGhlIG5ldyB1c2VyCiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHN1Y2ggYXMgcm9sZXMgdG8gZXh0ZW5kCiAqICAgICB0aGUgdXNlciBkb2N1bWVudCB3aXRoIChvcHRpb25hbCkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKSAtIEZ1bmN0aW9uIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9yCiAqICAgICBlcnJvcgogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHVzZXJzLmNyZWF0ZSgndGVzdHVzZXInLCAndGVzdGluZycsIHtyb2xlczogWydleGFtcGxlJ119LCBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICBpZiAoZXJyKSAvLyBhbiBlcnJvciBvY2N1cnJlZAogKiAgICAgZWxzZSAgICAgLy8gc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgbmV3IHVzZXIKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2spIHsKICAgIHNhbml0aXplQXJndW1lbnRzKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2ssCiAgICAgICAgZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykgewogICAgICAgICAgICBpZiAoXy5pbmRleE9mKHByb3BlcnRpZXMucm9sZXMsICJfYWRtaW4iKSAhPT0gLTEpIHsKICAgICAgICAgICAgICAgIGNyZWF0ZUFkbWluKHVzZXJuYW1lLCBwYXNzd29yZCwgZnVuY3Rpb24gKGVycikgewogICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucm9sZXMgPSBbXTsKICAgICAgICAgICAgICAgICAgICBjcmVhdGVVc2VyKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2spOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjcmVhdGVVc2VyKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2spOwogICAgICAgICAgICB9CiAgICB9KTsKfTsKCgovKioKICogVXBkYXRlcyBhbiBleGlzdGluZyB1c2VyIGRvY3VtZW50LiBTaW1pbGFyIHVzYWdlIHRvIHRoZSBjcmVhdGUgZnVuY3Rpb24uCiAqCiAqIEBuYW1lIHVwZGF0ZSh1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBUaGUgdXNlcm5hbWUgb2YgdGhlIG5ldyB1c2VyCiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIFRoZSB1bmhhc2hlZCBwYXNzd29yZCBmb3IgdGhlIG5ldyB1c2VyCiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHN1Y2ggYXMgcm9sZXMgdG8gZXh0ZW5kCiAqICAgICB0aGUgdXNlciBkb2N1bWVudCB3aXRoIChvcHRpb25hbCkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKSAtIEZ1bmN0aW9uIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9yCiAqICAgICBlcnJvcgogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHVzZXJzLnVwZGF0ZSgndGVzdHVzZXInLCAndGVzdGluZycsIHtyb2xlczogWydleGFtcGxlJ119LCBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICBpZiAoZXJyKSAvLyBhbiBlcnJvciBvY2N1cnJlZAogKiAgICAgZWxzZSAgICAgLy8gc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgdXNlcgogKiB9KTsKICogYGBgCiAqLwoKZXhwb3J0cy51cGRhdGUgPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykgewogICAgc2FuaXRpemVBcmd1bWVudHModXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaywKICAgICAgICBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGV4cG9ydHMuZ2V0KHVzZXJuYW1lLCBmdW5jdGlvbiAoZXJyLCB1c2VyLCBvcHRpb25zKSB7CiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKHByb3BlcnRpZXMucm9sZXMsICJfYWRtaW4iKSA9PT0gLTEpIHsKICAgICAgICAgICAgICAgICAgICBfLmV4dGVuZCh1c2VyLCBwcm9wZXJ0aWVzKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChwYXNzd29yZCkgewogICAgICAgICAgICAgICAgICAgIHVzZXIucGFzc3dvcmRfc2hhID0gc2hhMS5oZXgocGFzc3dvcmQgKyB1c2VyLnNhbHQpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHNhdmVVc2VyKG9wdGlvbnMuYXV0aGRiLCB1c2VyLCBmdW5jdGlvbiAoZXJyLCB1c2VyKSB7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5pbmZvKGZ1bmN0aW9uKGVyciwgc2Vzc2lvbl9pbmZvKXsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25faW5mby51c2VyQ3R4LnJvbGVzICYmIF8uaW5kZXhPZihzZXNzaW9uX2luZm8udXNlckN0eC5yb2xlcywgIl9hZG1pbiIpICE9PSAtMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihwcm9wZXJ0aWVzLnJvbGVzLCAiX2FkbWluIikgIT09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlQWRtaW4odXNlcm5hbWUsIHBhc3N3b3JkLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHVzZXIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWRtaW4odXNlcm5hbWUsIGZ1bmN0aW9uKGVyciwgYWRtaW4pIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5zdGF0dXMgIT09IDQwNCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHVzZXIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRtaW4odXNlcm5hbWUsIGNhbGxiYWNrKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB1c2VyKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgfSk7Cn07CgoKfSl9OwoKLyoqKioqKioqKiogdW5kZXJzY29yZSAqKioqKioqKioqLwoKa2Fuc28ubW9kdWxlQ2FjaGVbInVuZGVyc2NvcmUiXSA9IHtsb2FkOiAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSkgewoKLy8gICAgIFVuZGVyc2NvcmUuanMgMS4zLjMKLy8gICAgIChjKSAyMDA5LTIwMTIgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy4KLy8gICAgIFVuZGVyc2NvcmUgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLgovLyAgICAgUG9ydGlvbnMgb2YgVW5kZXJzY29yZSBhcmUgaW5zcGlyZWQgb3IgYm9ycm93ZWQgZnJvbSBQcm90b3R5cGUsCi8vICAgICBPbGl2ZXIgU3RlZWxlJ3MgRnVuY3Rpb25hbCwgYW5kIEpvaG4gUmVzaWcncyBNaWNyby1UZW1wbGF0aW5nLgovLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOgovLyAgICAgaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS91bmRlcnNjb3JlCgooZnVuY3Rpb24oKSB7CgogIC8vIEJhc2VsaW5lIHNldHVwCiAgLy8gLS0tLS0tLS0tLS0tLS0KCiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBnbG9iYWxgIG9uIHRoZSBzZXJ2ZXIuCiAgdmFyIHJvb3QgPSB0aGlzOwoKICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLgogIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87CgogIC8vIEVzdGFibGlzaCB0aGUgb2JqZWN0IHRoYXQgZ2V0cyByZXR1cm5lZCB0byBicmVhayBvdXQgb2YgYSBsb29wIGl0ZXJhdGlvbi4KICB2YXIgYnJlYWtlciA9IHt9OwoKICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOgogIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTsKCiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuCiAgdmFyIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLAogICAgICB1bnNoaWZ0ICAgICAgICAgID0gQXJyYXlQcm90by51bnNoaWZ0LAogICAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsCiAgICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTsKCiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlCiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuCiAgdmFyCiAgICBuYXRpdmVGb3JFYWNoICAgICAgPSBBcnJheVByb3RvLmZvckVhY2gsCiAgICBuYXRpdmVNYXAgICAgICAgICAgPSBBcnJheVByb3RvLm1hcCwKICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLAogICAgbmF0aXZlUmVkdWNlUmlnaHQgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodCwKICAgIG5hdGl2ZUZpbHRlciAgICAgICA9IEFycmF5UHJvdG8uZmlsdGVyLAogICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSwKICAgIG5hdGl2ZVNvbWUgICAgICAgICA9IEFycmF5UHJvdG8uc29tZSwKICAgIG5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZiwKICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsCiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LAogICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsCiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDsKCiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuCiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG5ldyB3cmFwcGVyKG9iaik7IH07CgogIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoCiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpbgogIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllciwKICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciAiYWR2YW5jZWQiIG1vZGUuCiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykgewogICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7CiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87CiAgICB9CiAgICBleHBvcnRzLl8gPSBfOwogIH0gZWxzZSB7CiAgICByb290WydfJ10gPSBfOwogIH0KCiAgLy8gQ3VycmVudCB2ZXJzaW9uLgogIF8uVkVSU0lPTiA9ICcxLjMuMyc7CgogIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zCiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuCiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZvckVhY2hgIGlmIGF2YWlsYWJsZS4KICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuOwogICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHsKICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpOwogICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgewogICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICBpZiAoaSBpbiBvYmogJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgewogICAgICAgIGlmIChfLmhhcyhvYmosIGtleSkpIHsKICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9OwoKICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuCiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7CiAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0czsKICAgIGlmIChuYXRpdmVNYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpOwogICAgfSk7CiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHJlc3VsdHMubGVuZ3RoID0gb2JqLmxlbmd0aDsKICAgIHJldHVybiByZXN1bHRzOwogIH07CgogIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCwKICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuCiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7CiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyOwogICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTsKICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7CiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7CiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTsKICAgIH0KICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgaWYgKCFpbml0aWFsKSB7CiAgICAgICAgbWVtbyA9IHZhbHVlOwogICAgICAgIGluaXRpYWwgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7CiAgICAgIH0KICAgIH0pOwogICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7CiAgICByZXR1cm4gbWVtbzsKICB9OwoKICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlUmlnaHRgIGlmIGF2YWlsYWJsZS4KICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHsKICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7CiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdOwogICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHsKICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTsKICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yKTsKICAgIH0KICAgIHZhciByZXZlcnNlZCA9IF8udG9BcnJheShvYmopLnJldmVyc2UoKTsKICAgIGlmIChjb250ZXh0ICYmICFpbml0aWFsKSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7CiAgICByZXR1cm4gaW5pdGlhbCA/IF8ucmVkdWNlKHJldmVyc2VkLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkgOiBfLnJlZHVjZShyZXZlcnNlZCwgaXRlcmF0b3IpOwogIH07CgogIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC4KICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIHZhciByZXN1bHQ7CiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgewogICAgICAgIHJlc3VsdCA9IHZhbHVlOwogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKCiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuCiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC4KICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkgewogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7CiAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikgcmV0dXJuIG9iai5maWx0ZXIoaXRlcmF0b3IsIGNvbnRleHQpOwogICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkgewogICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlOwogICAgfSk7CiAgICByZXR1cm4gcmVzdWx0czsKICB9OwoKICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLgogIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkgewogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIGlmICghaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlOwogICAgfSk7CiAgICByZXR1cm4gcmVzdWx0czsKICB9OwoKICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZXZlcnlgIGlmIGF2YWlsYWJsZS4KICAvLyBBbGlhc2VkIGFzIGBhbGxgLgogIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIHZhciByZXN1bHQgPSB0cnVlOwogICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0OwogICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkoaXRlcmF0b3IsIGNvbnRleHQpOwogICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkgewogICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7CiAgICB9KTsKICAgIHJldHVybiAhIXJlc3VsdDsKICB9OwoKICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLgogIC8vIEFsaWFzZWQgYXMgYGFueWAuCiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkgewogICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7CiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7CiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7CiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTsKICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7CiAgICB9KTsKICAgIHJldHVybiAhIXJlc3VsdDsKICB9OwoKICAvLyBEZXRlcm1pbmUgaWYgYSBnaXZlbiB2YWx1ZSBpcyBpbmNsdWRlZCBpbiB0aGUgYXJyYXkgb3Igb2JqZWN0IHVzaW5nIGA9PT1gLgogIC8vIEFsaWFzZWQgYXMgYGNvbnRhaW5zYC4KICBfLmluY2x1ZGUgPSBfLmNvbnRhaW5zID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHsKICAgIHZhciBmb3VuZCA9IGZhbHNlOwogICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZm91bmQ7CiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7CiAgICBmb3VuZCA9IGFueShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0OwogICAgfSk7CiAgICByZXR1cm4gZm91bmQ7CiAgfTsKCiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uCiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkgewogICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7CiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkgewogICAgICByZXR1cm4gKF8uaXNGdW5jdGlvbihtZXRob2QpID8gbWV0aG9kIHx8IHZhbHVlIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpOwogICAgfSk7CiAgfTsKCiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS4KICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHsKICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuIHZhbHVlW2tleV07IH0pOwogIH07CgogIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS4KICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdKSByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2JqKTsKICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiAtSW5maW5pdHk7CiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogLUluZmluaXR5fTsKICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTsKICAgICAgY29tcHV0ZWQgPj0gcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pOwogICAgfSk7CiAgICByZXR1cm4gcmVzdWx0LnZhbHVlOwogIH07CgogIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS4KICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdKSByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTsKICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiBJbmZpbml0eTsKICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiBJbmZpbml0eX07CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7CiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pOwogICAgfSk7CiAgICByZXR1cm4gcmVzdWx0LnZhbHVlOwogIH07CgogIC8vIFNodWZmbGUgYW4gYXJyYXkuCiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7CiAgICB2YXIgc2h1ZmZsZWQgPSBbXSwgcmFuZDsKICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpbmRleCArIDEpKTsKICAgICAgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07CiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7CiAgICB9KTsKICAgIHJldHVybiBzaHVmZmxlZDsKICB9OwoKICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuCiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIHZhbCwgY29udGV4dCkgewogICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9ialt2YWxdOyB9OwogICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICB2YWx1ZSA6IHZhbHVlLAogICAgICAgIGNyaXRlcmlhIDogaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpCiAgICAgIH07CiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7CiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhOwogICAgICBpZiAoYSA9PT0gdm9pZCAwKSByZXR1cm4gMTsKICAgICAgaWYgKGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xOwogICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7CiAgICB9KSwgJ3ZhbHVlJyk7CiAgfTsKCiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZQogIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLgogIF8uZ3JvdXBCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsKSB7CiAgICB2YXIgcmVzdWx0ID0ge307CiAgICB2YXIgaXRlcmF0b3IgPSBfLmlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gb2JqW3ZhbF07IH07CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7CiAgICAgIHZhciBrZXkgPSBpdGVyYXRvcih2YWx1ZSwgaW5kZXgpOwogICAgICAocmVzdWx0W2tleV0gfHwgKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTsKICAgIH0pOwogICAgcmV0dXJuIHJlc3VsdDsKICB9OwoKICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgYXQgd2hhdCBpbmRleCBhbiBvYmplY3Qgc2hvdWxkCiAgLy8gYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC4KICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0b3IpIHsKICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpOwogICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7CiAgICB3aGlsZSAobG93IDwgaGlnaCkgewogICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7CiAgICAgIGl0ZXJhdG9yKGFycmF5W21pZF0pIDwgaXRlcmF0b3Iob2JqKSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkOwogICAgfQogICAgcmV0dXJuIGxvdzsKICB9OwoKICAvLyBTYWZlbHkgY29udmVydCBhbnl0aGluZyBpdGVyYWJsZSBpbnRvIGEgcmVhbCwgbGl2ZSBhcnJheS4KICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHsKICAgIGlmICghb2JqKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107CiAgICBpZiAoXy5pc0FycmF5KG9iaikpICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTsKICAgIGlmIChfLmlzQXJndW1lbnRzKG9iaikpICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChvYmopOwogICAgaWYgKG9iai50b0FycmF5ICYmIF8uaXNGdW5jdGlvbihvYmoudG9BcnJheSkpIHJldHVybiBvYmoudG9BcnJheSgpOwogICAgcmV0dXJuIF8udmFsdWVzKG9iaik7CiAgfTsKCiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LgogIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDsKICB9OwoKICAvLyBBcnJheSBGdW5jdGlvbnMKICAvLyAtLS0tLS0tLS0tLS0tLS0KCiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOCiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVjawogIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC4KICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7CiAgICByZXR1cm4gKG4gIT0gbnVsbCkgJiYgIWd1YXJkID8gc2xpY2UuY2FsbChhcnJheSwgMCwgbikgOiBhcnJheVswXTsKICB9OwoKICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNjaWFseSB1c2VmdWwgb24KICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpbgogIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aAogIC8vIGBfLm1hcGAuCiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7CiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gKChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pKTsKICB9OwoKICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOCiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuCiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7CiAgICBpZiAoKG4gIT0gbnVsbCkgJiYgIWd1YXJkKSB7CiAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07CiAgICB9CiAgfTsKCiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYC4KICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKmluZGV4Kiogd2lsbCByZXR1cm4KICAvLyB0aGUgcmVzdCBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBmcm9tIHRoYXQgaW5kZXggb253YXJkLiBUaGUgKipndWFyZCoqCiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLgogIF8ucmVzdCA9IF8udGFpbCA9IGZ1bmN0aW9uKGFycmF5LCBpbmRleCwgZ3VhcmQpIHsKICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAoaW5kZXggPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogaW5kZXgpOwogIH07CgogIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS4KICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkgewogICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhIXZhbHVlOyB9KTsKICB9OwoKICAvLyBSZXR1cm4gYSBjb21wbGV0ZWx5IGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFuIGFycmF5LgogIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7CiAgICByZXR1cm4gXy5yZWR1Y2UoYXJyYXksIGZ1bmN0aW9uKG1lbW8sIHZhbHVlKSB7CiAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSByZXR1cm4gbWVtby5jb25jYXQoc2hhbGxvdyA/IHZhbHVlIDogXy5mbGF0dGVuKHZhbHVlKSk7CiAgICAgIG1lbW9bbWVtby5sZW5ndGhdID0gdmFsdWU7CiAgICAgIHJldHVybiBtZW1vOwogICAgfSwgW10pOwogIH07CgogIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLgogIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7CiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpOwogIH07CgogIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5CiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLgogIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuCiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yKSB7CiAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yKSA6IGFycmF5OwogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIC8vIFRoZSBgaXNTb3J0ZWRgIGZsYWcgaXMgaXJyZWxldmFudCBpZiB0aGUgYXJyYXkgb25seSBjb250YWlucyB0d28gZWxlbWVudHMuCiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgMykgaXNTb3J0ZWQgPSB0cnVlOwogICAgXy5yZWR1Y2UoaW5pdGlhbCwgZnVuY3Rpb24gKG1lbW8sIHZhbHVlLCBpbmRleCkgewogICAgICBpZiAoaXNTb3J0ZWQgPyBfLmxhc3QobWVtbykgIT09IHZhbHVlIHx8ICFtZW1vLmxlbmd0aCA6ICFfLmluY2x1ZGUobWVtbywgdmFsdWUpKSB7CiAgICAgICAgbWVtby5wdXNoKHZhbHVlKTsKICAgICAgICByZXN1bHRzLnB1c2goYXJyYXlbaW5kZXhdKTsKICAgICAgfQogICAgICByZXR1cm4gbWVtbzsKICAgIH0sIFtdKTsKICAgIHJldHVybiByZXN1bHRzOwogIH07CgogIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZgogIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLgogIF8udW5pb24gPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSkpOwogIH07CgogIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGUKICAvLyBwYXNzZWQtaW4gYXJyYXlzLiAoQWxpYXNlZCBhcyAiaW50ZXJzZWN0IiBmb3IgYmFjay1jb21wYXQuKQogIF8uaW50ZXJzZWN0aW9uID0gXy5pbnRlcnNlY3QgPSBmdW5jdGlvbihhcnJheSkgewogICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICByZXR1cm4gXy5maWx0ZXIoXy51bmlxKGFycmF5KSwgZnVuY3Rpb24oaXRlbSkgewogICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbihvdGhlcikgewogICAgICAgIHJldHVybiBfLmluZGV4T2Yob3RoZXIsIGl0ZW0pID49IDA7CiAgICAgIH0pOwogICAgfSk7CiAgfTsKCiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLgogIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uCiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHsKICAgIHZhciByZXN0ID0gXy5mbGF0dGVuKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgdHJ1ZSk7CiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuICFfLmluY2x1ZGUocmVzdCwgdmFsdWUpOyB9KTsKICB9OwoKICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlCiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuCiAgXy56aXAgPSBmdW5jdGlvbigpIHsKICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpOwogICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJncywgJ2xlbmd0aCcpKTsKICAgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGxlbmd0aCk7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSByZXN1bHRzW2ldID0gXy5wbHVjayhhcmdzLCAiIiArIGkpOwogICAgcmV0dXJuIHJlc3VsdHM7CiAgfTsKCiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSwKICAvLyB3ZSBuZWVkIHRoaXMgZnVuY3Rpb24uIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4KICAvLyBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LgogIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuCiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgCiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC4KICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHsKICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7CiAgICB2YXIgaSwgbDsKICAgIGlmIChpc1NvcnRlZCkgewogICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7CiAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTsKICAgIH0KICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pOwogICAgZm9yIChpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykgaWYgKGkgaW4gYXJyYXkgJiYgYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpOwogICAgcmV0dXJuIC0xOwogIH07CgogIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBsYXN0SW5kZXhPZmAgaWYgYXZhaWxhYmxlLgogIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSkgewogICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTsKICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHJldHVybiBhcnJheS5sYXN0SW5kZXhPZihpdGVtKTsKICAgIHZhciBpID0gYXJyYXkubGVuZ3RoOwogICAgd2hpbGUgKGktLSkgaWYgKGkgaW4gYXJyYXkgJiYgYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpOwogICAgcmV0dXJuIC0xOwogIH07CgogIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2YKICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZQogIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuCiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7CiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7CiAgICAgIHN0b3AgPSBzdGFydCB8fCAwOwogICAgICBzdGFydCA9IDA7CiAgICB9CiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7CgogICAgdmFyIGxlbiA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTsKICAgIHZhciBpZHggPSAwOwogICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbik7CgogICAgd2hpbGUoaWR4IDwgbGVuKSB7CiAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0OwogICAgICBzdGFydCArPSBzdGVwOwogICAgfQoKICAgIHJldHVybiByYW5nZTsKICB9OwoKICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zCiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tCgogIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy4KICB2YXIgY3RvciA9IGZ1bmN0aW9uKCl7fTsKCiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsCiAgLy8gb3B0aW9uYWxseSkuIEJpbmRpbmcgd2l0aCBhcmd1bWVudHMgaXMgYWxzbyBrbm93biBhcyBgY3VycnlgLgogIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZiBhdmFpbGFibGUuCiAgLy8gV2UgY2hlY2sgZm9yIGBmdW5jLmJpbmRgIGZpcnN0LCB0byBmYWlsIGZhc3Qgd2hlbiBgZnVuY2AgaXMgdW5kZWZpbmVkLgogIF8uYmluZCA9IGZ1bmN0aW9uIGJpbmQoZnVuYywgY29udGV4dCkgewogICAgdmFyIGJvdW5kLCBhcmdzOwogICAgaWYgKGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCAmJiBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpOwogICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3I7CiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOwogICAgcmV0dXJuIGJvdW5kID0gZnVuY3Rpb24oKSB7CiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpOwogICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlOwogICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yOwogICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTsKICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7CiAgICAgIHJldHVybiBzZWxmOwogICAgfTsKICB9OwoKICAvLyBCaW5kIGFsbCBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQKICAvLyBhbGwgY2FsbGJhY2tzIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC4KICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHsKICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgIGlmIChmdW5jcy5sZW5ndGggPT0gMCkgZnVuY3MgPSBfLmZ1bmN0aW9ucyhvYmopOwogICAgZWFjaChmdW5jcywgZnVuY3Rpb24oZikgeyBvYmpbZl0gPSBfLmJpbmQob2JqW2ZdLCBvYmopOyB9KTsKICAgIHJldHVybiBvYmo7CiAgfTsKCiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy4KICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHsKICAgIHZhciBtZW1vID0ge307CiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpOwogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7CiAgICB9OwogIH07CgogIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHMKICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuCiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHsKICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOwogICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7IH0sIHdhaXQpOwogIH07CgogIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcwogIC8vIGNsZWFyZWQuCiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHsKICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7CiAgfTsKCiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlCiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuCiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHsKICAgIHZhciBjb250ZXh0LCBhcmdzLCB0aW1lb3V0LCB0aHJvdHRsaW5nLCBtb3JlLCByZXN1bHQ7CiAgICB2YXIgd2hlbkRvbmUgPSBfLmRlYm91bmNlKGZ1bmN0aW9uKCl7IG1vcmUgPSB0aHJvdHRsaW5nID0gZmFsc2U7IH0sIHdhaXQpOwogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICBjb250ZXh0ID0gdGhpczsgYXJncyA9IGFyZ3VtZW50czsKICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdGltZW91dCA9IG51bGw7CiAgICAgICAgaWYgKG1vcmUpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7CiAgICAgICAgd2hlbkRvbmUoKTsKICAgICAgfTsKICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7CiAgICAgIGlmICh0aHJvdHRsaW5nKSB7CiAgICAgICAgbW9yZSA9IHRydWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTsKICAgICAgfQogICAgICB3aGVuRG9uZSgpOwogICAgICB0aHJvdHRsaW5nID0gdHJ1ZTsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH07CiAgfTsKCiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdAogIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3IKICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGUKICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLgogIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHsKICAgIHZhciB0aW1lb3V0OwogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7CiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRpbWVvdXQgPSBudWxsOwogICAgICAgIGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpOwogICAgICB9OwogICAgICBpZiAoaW1tZWRpYXRlICYmICF0aW1lb3V0KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpOwogICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7CiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTsKICAgIH07CiAgfTsKCiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93CiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi4KICBfLm9uY2UgPSBmdW5jdGlvbihmdW5jKSB7CiAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgIGlmIChyYW4pIHJldHVybiBtZW1vOwogICAgICByYW4gPSB0cnVlOwogICAgICByZXR1cm4gbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH07CiAgfTsKCiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsCiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZAogIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uCiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikgewogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICB2YXIgYXJncyA9IFtmdW5jXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTsKICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7CiAgICB9OwogIH07CgogIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoCiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy4KICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHsKICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50czsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7CiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldOwogICAgICB9CiAgICAgIHJldHVybiBhcmdzWzBdOwogICAgfTsKICB9OwoKICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuCiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7CiAgICBpZiAodGltZXMgPD0gMCkgcmV0dXJuIGZ1bmMoKTsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgaWYgKC0tdGltZXMgPCAxKSB7IHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0KICAgIH07CiAgfTsKCiAgLy8gT2JqZWN0IEZ1bmN0aW9ucwogIC8vIC0tLS0tLS0tLS0tLS0tLS0KCiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYAogIF8ua2V5cyA9IG5hdGl2ZUtleXMgfHwgZnVuY3Rpb24ob2JqKSB7CiAgICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTsKICAgIHZhciBrZXlzID0gW107CiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTsKICAgIHJldHVybiBrZXlzOwogIH07CgogIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy4KICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7CiAgfTsKCiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LgogIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgCiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHsKICAgIHZhciBuYW1lcyA9IFtdOwogICAgZm9yICh2YXIga2V5IGluIG9iaikgewogICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpOwogICAgfQogICAgcmV0dXJuIG5hbWVzLnNvcnQoKTsKICB9OwoKICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS4KICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikgewogICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkgewogICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkgewogICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTsKICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gb2JqOwogIH07CgogIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuCiAgXy5waWNrID0gZnVuY3Rpb24ob2JqKSB7CiAgICB2YXIgcmVzdWx0ID0ge307CiAgICBlYWNoKF8uZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCBmdW5jdGlvbihrZXkpIHsKICAgICAgaWYgKGtleSBpbiBvYmopIHJlc3VsdFtrZXldID0gb2JqW2tleV07CiAgICB9KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKCiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy4KICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7CiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7CiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7CiAgICAgICAgaWYgKG9ialtwcm9wXSA9PSBudWxsKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIG9iajsKICB9OwoKICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuCiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikgewogICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7CiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopOwogIH07CgogIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai4KICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvICJ0YXAgaW50byIgYSBtZXRob2QgY2hhaW4sIGluCiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uCiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7CiAgICBpbnRlcmNlcHRvcihvYmopOwogICAgcmV0dXJuIG9iajsKICB9OwoKICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbi4KICBmdW5jdGlvbiBlcShhLCBiLCBzdGFjaykgewogICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLgogICAgLy8gU2VlIHRoZSBIYXJtb255IGBlZ2FsYCBwcm9wb3NhbDogaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsLgogICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiOwogICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLgogICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiOwogICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuCiAgICBpZiAoYS5fY2hhaW4pIGEgPSBhLl93cmFwcGVkOwogICAgaWYgKGIuX2NoYWluKSBiID0gYi5fd3JhcHBlZDsKICAgIC8vIEludm9rZSBhIGN1c3RvbSBgaXNFcXVhbGAgbWV0aG9kIGlmIG9uZSBpcyBwcm92aWRlZC4KICAgIGlmIChhLmlzRXF1YWwgJiYgXy5pc0Z1bmN0aW9uKGEuaXNFcXVhbCkpIHJldHVybiBhLmlzRXF1YWwoYik7CiAgICBpZiAoYi5pc0VxdWFsICYmIF8uaXNGdW5jdGlvbihiLmlzRXF1YWwpKSByZXR1cm4gYi5pc0VxdWFsKGEpOwogICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy4KICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpOwogICAgaWYgKGNsYXNzTmFtZSAhPSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7CiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkgewogICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS4KICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzoKICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYCI1ImAgaXMKICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKCI1IilgLgogICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTsKICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzoKICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yCiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuCiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7CiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOgogICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzoKICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyCiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucwogICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC4KICAgICAgICByZXR1cm4gK2EgPT0gK2I7CiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyIHNvdXJjZSBwYXR0ZXJucyBhbmQgZmxhZ3MuCiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6CiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmCiAgICAgICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmCiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmCiAgICAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7CiAgICB9CiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTsKICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMKICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLgogICAgdmFyIGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsKICAgIHdoaWxlIChsZW5ndGgtLSkgewogICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YKICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLgogICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gdHJ1ZTsKICAgIH0KICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy4KICAgIHN0YWNrLnB1c2goYSk7CiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7CiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy4KICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykgewogICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS4KICAgICAgc2l6ZSA9IGEubGVuZ3RoOwogICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoOwogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy4KICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7CiAgICAgICAgICAvLyBFbnN1cmUgY29tbXV0YXRpdmUgZXF1YWxpdHkgZm9yIHNwYXJzZSBhcnJheXMuCiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBzaXplIGluIGEgPT0gc2l6ZSBpbiBiICYmIGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIHN0YWNrKSkpIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LgogICAgICBpZiAoJ2NvbnN0cnVjdG9yJyBpbiBhICE9ICdjb25zdHJ1Y3RvcicgaW4gYiB8fCBhLmNvbnN0cnVjdG9yICE9IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTsKICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuCiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7CiAgICAgICAgaWYgKF8uaGFzKGEsIGtleSkpIHsKICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy4KICAgICAgICAgIHNpemUrKzsKICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlci4KICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIHN0YWNrKSkpIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy4KICAgICAgaWYgKHJlc3VsdCkgewogICAgICAgIGZvciAoa2V5IGluIGIpIHsKICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7CiAgICAgICAgfQogICAgICAgIHJlc3VsdCA9ICFzaXplOwogICAgICB9CiAgICB9CiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy4KICAgIHN0YWNrLnBvcCgpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9CgogIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLgogIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHsKICAgIHJldHVybiBlcShhLCBiLCBbXSk7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/CiAgLy8gQW4gImVtcHR5IiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuCiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7CiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlOwogICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7CiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7CiAgICByZXR1cm4gdHJ1ZTsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/CiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09IDEpOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/CiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXkKICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0PwogIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gYXJndW1lbnRzIG9iamVjdD8KICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFyZ3VtZW50c10nOwogIH07CiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHsKICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHsKICAgICAgcmV0dXJuICEhKG9iaiAmJiBfLmhhcyhvYmosICdjYWxsZWUnKSk7CiAgICB9OwogIH0KCiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGZ1bmN0aW9uPwogIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBzdHJpbmc/CiAgXy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBTdHJpbmddJzsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgbnVtYmVyPwogIF8uaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgTnVtYmVyXSc7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyPwogIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgaXNGaW5pdGUob2JqKTsKICB9OwoKICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/CiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikgewogICAgLy8gYE5hTmAgaXMgdGhlIG9ubHkgdmFsdWUgZm9yIHdoaWNoIGA9PT1gIGlzIG5vdCByZWZsZXhpdmUuCiAgICByZXR1cm4gb2JqICE9PSBvYmo7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/CiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBkYXRlPwogIF8uaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IERhdGVdJzsKICB9OwoKICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYSByZWd1bGFyIGV4cHJlc3Npb24/CiAgXy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBSZWdFeHBdJzsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/CiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBvYmogPT09IG51bGw7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/CiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwOwogIH07CgogIC8vIEhhcyBvd24gcHJvcGVydHk/CiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkgewogICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpOwogIH07CgogIC8vIFV0aWxpdHkgRnVuY3Rpb25zCiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0KCiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cwogIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC4KICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHsKICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTsKICAgIHJldHVybiB0aGlzOwogIH07CgogIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuCiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfTsKCiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuCiAgXy50aW1lcyA9IGZ1bmN0aW9uIChuLCBpdGVyYXRvciwgY29udGV4dCkgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7CiAgfTsKCiAgLy8gRXNjYXBlIGEgc3RyaW5nIGZvciBIVE1MIGludGVycG9sYXRpb24uCiAgXy5lc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpIHsKICAgIHJldHVybiAoJycrc3RyaW5nKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiN4Mjc7JykucmVwbGFjZSgvXC8vZywnJiN4MkY7Jyk7CiAgfTsKCiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0OwogIC8vIG90aGVyd2lzZSwgcmV0dXJuIGl0LgogIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgewogICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gbnVsbDsKICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07CiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlOwogIH07CgogIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCwgZW5zdXJpbmcgdGhhdAogIC8vIHRoZXkncmUgY29ycmVjdGx5IGFkZGVkIHRvIHRoZSBPT1Agd3JhcHBlciBhcyB3ZWxsLgogIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHsKICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSl7CiAgICAgIGFkZFRvV3JhcHBlcihuYW1lLCBfW25hbWVdID0gb2JqW25hbWVdKTsKICAgIH0pOwogIH07CgogIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuCiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy4KICB2YXIgaWRDb3VudGVyID0gMDsKICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7CiAgICB2YXIgaWQgPSBpZENvdW50ZXIrKzsKICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkOwogIH07CgogIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZQogIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy4KICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7CiAgICBldmFsdWF0ZSAgICA6IC88JShbXHNcU10rPyklPi9nLAogICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcc1xTXSs/KSU+L2csCiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xzXFNdKz8pJT4vZwogIH07CgogIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW4KICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzCiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guCiAgdmFyIG5vTWF0Y2ggPSAvLl4vOwoKICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYQogIC8vIHN0cmluZyBsaXRlcmFsLgogIHZhciBlc2NhcGVzID0gewogICAgJ1xcJzogJ1xcJywKICAgICInIjogIiciLAogICAgJ3InOiAnXHInLAogICAgJ24nOiAnXG4nLAogICAgJ3QnOiAnXHQnLAogICAgJ3UyMDI4JzogJ1x1MjAyOCcsCiAgICAndTIwMjknOiAnXHUyMDI5JwogIH07CgogIGZvciAodmFyIHAgaW4gZXNjYXBlcykgZXNjYXBlc1tlc2NhcGVzW3BdXSA9IHA7CiAgdmFyIGVzY2FwZXIgPSAvXFx8J3xccnxcbnxcdHxcdTIwMjh8XHUyMDI5L2c7CiAgdmFyIHVuZXNjYXBlciA9IC9cXChcXHwnfHJ8bnx0fHUyMDI4fHUyMDI5KS9nOwoKICAvLyBXaXRoaW4gYW4gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiwgb3IgZXNjYXBpbmcsIHJlbW92ZSBIVE1MIGVzY2FwaW5nCiAgLy8gdGhhdCBoYWQgYmVlbiBwcmV2aW91c2x5IGFkZGVkLgogIHZhciB1bmVzY2FwZSA9IGZ1bmN0aW9uKGNvZGUpIHsKICAgIHJldHVybiBjb2RlLnJlcGxhY2UodW5lc2NhcGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlKSB7CiAgICAgIHJldHVybiBlc2NhcGVzW2VzY2FwZV07CiAgICB9KTsKICB9OwoKICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLgogIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSwKICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS4KICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHsKICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyhzZXR0aW5ncyB8fCB7fSwgXy50ZW1wbGF0ZVNldHRpbmdzKTsKCiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIHRha2luZyBjYXJlIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQKICAgIC8vIGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGVuIHVuZXNjYXBlIHRoZW0gaW4gY29kZQogICAgLy8gYmxvY2tzLgogICAgdmFyIHNvdXJjZSA9ICJfX3ArPSciICsgdGV4dAogICAgICAucmVwbGFjZShlc2NhcGVyLCBmdW5jdGlvbihtYXRjaCkgewogICAgICAgIHJldHVybiAnXFwnICsgZXNjYXBlc1ttYXRjaF07CiAgICAgIH0pCiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkgewogICAgICAgIHJldHVybiAiJytcbl8uZXNjYXBlKCIgKyB1bmVzY2FwZShjb2RlKSArICIpK1xuJyI7CiAgICAgIH0pCiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7CiAgICAgICAgcmV0dXJuICInK1xuKCIgKyB1bmVzY2FwZShjb2RlKSArICIpK1xuJyI7CiAgICAgIH0pCiAgICAgIC5yZXBsYWNlKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlKSB7CiAgICAgICAgcmV0dXJuICInO1xuIiArIHVuZXNjYXBlKGNvZGUpICsgIlxuO19fcCs9JyI7CiAgICAgIH0pICsgIic7XG4iOwoKICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuCiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcbicgKyBzb3VyY2UgKyAnfVxuJzsKCiAgICBzb3VyY2UgPSAidmFyIF9fcD0nJzsiICsKICAgICAgInZhciBwcmludD1mdW5jdGlvbigpe19fcCs9QXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKX07XG4iICsKICAgICAgc291cmNlICsgInJldHVybiBfX3A7XG4iOwoKICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTsKICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pOwogICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkgewogICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7CiAgICB9OwoKICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBidWlsZCB0aW1lCiAgICAvLyBwcmVjb21waWxhdGlvbi4KICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xuJyArCiAgICAgIHNvdXJjZSArICd9JzsKCiAgICByZXR1cm4gdGVtcGxhdGU7CiAgfTsKCiAgLy8gQWRkIGEgImNoYWluIiBmdW5jdGlvbiwgd2hpY2ggd2lsbCBkZWxlZ2F0ZSB0byB0aGUgd3JhcHBlci4KICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gXyhvYmopLmNoYWluKCk7CiAgfTsKCiAgLy8gVGhlIE9PUCBXcmFwcGVyCiAgLy8gLS0tLS0tLS0tLS0tLS0tCgogIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0CiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGUKICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLgogIHZhciB3cmFwcGVyID0gZnVuY3Rpb24ob2JqKSB7IHRoaXMuX3dyYXBwZWQgPSBvYmo7IH07CgogIC8vIEV4cG9zZSBgd3JhcHBlci5wcm90b3R5cGVgIGFzIGBfLnByb3RvdHlwZWAKICBfLnByb3RvdHlwZSA9IHdyYXBwZXIucHJvdG90eXBlOwoKICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuCiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKG9iaiwgY2hhaW4pIHsKICAgIHJldHVybiBjaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqOwogIH07CgogIC8vIEEgbWV0aG9kIHRvIGVhc2lseSBhZGQgZnVuY3Rpb25zIHRvIHRoZSBPT1Agd3JhcHBlci4KICB2YXIgYWRkVG9XcmFwcGVyID0gZnVuY3Rpb24obmFtZSwgZnVuYykgewogICAgd3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHsKICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7CiAgICAgIHVuc2hpZnQuY2FsbChhcmdzLCB0aGlzLl93cmFwcGVkKTsKICAgICAgcmV0dXJuIHJlc3VsdChmdW5jLmFwcGx5KF8sIGFyZ3MpLCB0aGlzLl9jaGFpbik7CiAgICB9OwogIH07CgogIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC4KICBfLm1peGluKF8pOwoKICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLgogIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkgewogICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07CiAgICB3cmFwcGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkgewogICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuX3dyYXBwZWQ7CiAgICAgIG1ldGhvZC5hcHBseSh3cmFwcGVkLCBhcmd1bWVudHMpOwogICAgICB2YXIgbGVuZ3RoID0gd3JhcHBlZC5sZW5ndGg7CiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIGxlbmd0aCA9PT0gMCkgZGVsZXRlIHdyYXBwZWRbMF07CiAgICAgIHJldHVybiByZXN1bHQod3JhcHBlZCwgdGhpcy5fY2hhaW4pOwogICAgfTsKICB9KTsKCiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuCiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHsKICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdOwogICAgd3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIHJlc3VsdChtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSwgdGhpcy5fY2hhaW4pOwogICAgfTsKICB9KTsKCiAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LgogIHdyYXBwZXIucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24oKSB7CiAgICB0aGlzLl9jaGFpbiA9IHRydWU7CiAgICByZXR1cm4gdGhpczsKICB9OwoKICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC4KICB3cmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7CiAgfTsKCn0pLmNhbGwodGhpcyk7Cgp9KX07CgovKioqKioqKioqKiBzaGExICoqKioqKioqKiovCgprYW5zby5tb2R1bGVDYWNoZVsic2hhMSJdID0ge2xvYWQ6IChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCByZXF1aXJlKSB7CgovKioNCiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZA0KICogaW4gRklQUyBQVUIgMTgwLTEuIFRoaXMgbW9kdWxlIGlzIHVzZWQgdG8gaGFzaCB1c2VyIHBhc3N3b3JkcyBpbiBhIHdheSB0aGF0J3MNCiAqIGNvbXBhdGlibGUgd2l0aCBDb3VjaERCLg0KICoNCiAqIFRoaXMgbW9kdWxlIGlzIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyIGFuZCBkaXN0cmlidXRlZCB1bmRlciB0aGUNCiAqIEJTRCBMaWNlbnNlLiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy4NCiAqDQogKiBAbW9kdWxlDQogKi8NCg0KLyoNCiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZA0KICogaW4gRklQUyBQVUIgMTgwLTENCiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi4NCiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXQNCiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZQ0KICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuDQogKi8NCg0KLyoNCiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGgNCiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuDQogKi8NCnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqLw0KdmFyIGI2NHBhZCAgPSAiPSI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gIj0iIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqLw0KdmFyIGNocnN6ICAgPSA4OyAgLyogYml0cyBwZXIgaW5wdXQgY2hhcmFjdGVyLiA4IC0gQVNDSUk7IDE2IC0gVW5pY29kZSAgICAgICovDQoNCi8qDQogKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGwNCiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5ncw0KICovDQpmdW5jdGlvbiBoZXhfc2hhMShzKXtyZXR1cm4gYmluYjJoZXgoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9DQpmdW5jdGlvbiBiNjRfc2hhMShzKXtyZXR1cm4gYmluYjJiNjQoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9DQpmdW5jdGlvbiBzdHJfc2hhMShzKXtyZXR1cm4gYmluYjJzdHIoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9DQpmdW5jdGlvbiBoZXhfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmhleChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9DQpmdW5jdGlvbiBiNjRfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmI2NChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9DQpmdW5jdGlvbiBzdHJfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMnN0cihjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9DQoNCi8qDQogKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmcNCiAqLw0KZnVuY3Rpb24gc2hhMV92bV90ZXN0KCkNCnsNCiAgcmV0dXJuIGhleF9zaGExKCJhYmMiKSA9PSAiYTk5OTNlMzY0NzA2ODE2YWJhM2UyNTcxNzg1MGMyNmM5Y2QwZDg5ZCI7DQp9DQoNCi8qDQogKiBDYWxjdWxhdGUgdGhlIFNIQS0xIG9mIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGgNCiAqLw0KZnVuY3Rpb24gY29yZV9zaGExKHgsIGxlbikNCnsNCiAgLyogYXBwZW5kIHBhZGRpbmcgKi8NCiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7DQogIHhbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjsNCg0KICB2YXIgdyA9IEFycmF5KDgwKTsNCiAgdmFyIGEgPSAgMTczMjU4NDE5MzsNCiAgdmFyIGIgPSAtMjcxNzMzODc5Ow0KICB2YXIgYyA9IC0xNzMyNTg0MTk0Ow0KICB2YXIgZCA9ICAyNzE3MzM4Nzg7DQogIHZhciBlID0gLTEwMDk1ODk3NzY7DQoNCiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KQ0KICB7DQogICAgdmFyIG9sZGEgPSBhOw0KICAgIHZhciBvbGRiID0gYjsNCiAgICB2YXIgb2xkYyA9IGM7DQogICAgdmFyIG9sZGQgPSBkOw0KICAgIHZhciBvbGRlID0gZTsNCg0KICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKQ0KICAgIHsNCiAgICAgIGlmKGogPCAxNikgd1tqXSA9IHhbaSArIGpdOw0KICAgICAgZWxzZSB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTsNCiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSwNCiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTsNCiAgICAgIGUgPSBkOw0KICAgICAgZCA9IGM7DQogICAgICBjID0gcm9sKGIsIDMwKTsNCiAgICAgIGIgPSBhOw0KICAgICAgYSA9IHQ7DQogICAgfQ0KDQogICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpOw0KICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTsNCiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7DQogICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpOw0KICAgIGUgPSBzYWZlX2FkZChlLCBvbGRlKTsNCiAgfQ0KICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCwgZSk7DQoNCn0NCg0KLyoNCiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50DQogKiBpdGVyYXRpb24NCiAqLw0KZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKQ0Kew0KICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTsNCiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkOw0KICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7DQogIHJldHVybiBiIF4gYyBeIGQ7DQp9DQoNCi8qDQogKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb24NCiAqLw0KZnVuY3Rpb24gc2hhMV9rdCh0KQ0Kew0KICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOg0KICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7DQp9DQoNCi8qDQogKiBDYWxjdWxhdGUgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhDQogKi8NCmZ1bmN0aW9uIGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkNCnsNCiAgdmFyIGJrZXkgPSBzdHIyYmluYihrZXkpOw0KICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gY29yZV9zaGExKGJrZXksIGtleS5sZW5ndGggKiBjaHJzeik7DQoNCiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7DQogIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKQ0KICB7DQogICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2Ow0KICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QzsNCiAgfQ0KDQogIHZhciBoYXNoID0gY29yZV9zaGExKGlwYWQuY29uY2F0KHN0cjJiaW5iKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiBjaHJzeik7DQogIHJldHVybiBjb3JlX3NoYTEob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDE2MCk7DQp9DQoNCi8qDQogKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5DQogKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLg0KICovDQpmdW5jdGlvbiBzYWZlX2FkZCh4LCB5KQ0Kew0KICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpOw0KICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7DQogIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpOw0KfQ0KDQovKg0KICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0Lg0KICovDQpmdW5jdGlvbiByb2wobnVtLCBjbnQpDQp7DQogIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTsNCn0NCg0KLyoNCiAqIENvbnZlcnQgYW4gOC1iaXQgb3IgMTYtYml0IHN0cmluZyB0byBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzDQogKiBJbiA4LWJpdCBmdW5jdGlvbiwgY2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGktYnl0ZSBzaWxlbnRseSBpZ25vcmVkLg0KICovDQpmdW5jdGlvbiBzdHIyYmluYihzdHIpDQp7DQogIHZhciBiaW4gPSBBcnJheSgpOw0KICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7DQogIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoICogY2hyc3o7IGkgKz0gY2hyc3opDQogICAgYmluW2k+PjVdIHw9IChzdHIuY2hhckNvZGVBdChpIC8gY2hyc3opICYgbWFzaykgPDwgKDMyIC0gY2hyc3ogLSBpJTMyKTsNCiAgcmV0dXJuIGJpbjsNCn0NCg0KLyoNCiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZw0KICovDQpmdW5jdGlvbiBiaW5iMnN0cihiaW4pDQp7DQogIHZhciBzdHIgPSAiIjsNCiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxOw0KICBmb3IodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aCAqIDMyOyBpICs9IGNocnN6KQ0KICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChiaW5baT4+NV0gPj4+ICgzMiAtIGNocnN6IC0gaSUzMikpICYgbWFzayk7DQogIHJldHVybiBzdHI7DQp9DQoNCi8qDQogKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBoZXggc3RyaW5nLg0KICovDQpmdW5jdGlvbiBiaW5iMmhleChiaW5hcnJheSkNCnsNCiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gIjAxMjM0NTY3ODlBQkNERUYiIDogIjAxMjM0NTY3ODlhYmNkZWYiOw0KICB2YXIgc3RyID0gIiI7DQogIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpKyspDQogIHsNCiAgICBzdHIgKz0gaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCs0KSkgJiAweEYpICsNCiAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCAgKSkgJiAweEYpOw0KICB9DQogIHJldHVybiBzdHI7DQp9DQoNCi8qDQogKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBiYXNlLTY0IHN0cmluZw0KICovDQpmdW5jdGlvbiBiaW5iMmI2NChiaW5hcnJheSkNCnsNCiAgdmFyIHRhYiA9ICJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIjsNCiAgdmFyIHN0ciA9ICIiOw0KICBmb3IodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSArPSAzKQ0KICB7DQogICAgdmFyIHRyaXBsZXQgPSAoKChiaW5hcnJheVtpICAgPj4gMl0gPj4gOCAqICgzIC0gIGkgICAlNCkpICYgMHhGRikgPDwgMTYpDQogICAgICAgICAgICAgICAgfCAoKChiaW5hcnJheVtpKzEgPj4gMl0gPj4gOCAqICgzIC0gKGkrMSklNCkpICYgMHhGRikgPDwgOCApDQogICAgICAgICAgICAgICAgfCAgKChiaW5hcnJheVtpKzIgPj4gMl0gPj4gOCAqICgzIC0gKGkrMiklNCkpICYgMHhGRik7DQogICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKykNCiAgICB7DQogICAgICBpZihpICogOCArIGogKiA2ID4gYmluYXJyYXkubGVuZ3RoICogMzIpIHN0ciArPSBiNjRwYWQ7DQogICAgICBlbHNlIHN0ciArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+IDYqKDMtaikpICYgMHgzRik7DQogICAgfQ0KICB9DQogIHJldHVybiBzdHI7DQp9DQoNCg0KLyoqDQogKiBIYXNoZXMgYSBzdHJpbmcgdXNpbmcgU0hBMSBhbmQgcmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiBvZiBpdC4NCiAqDQogKiBAbmFtZSBoZXgocykNCiAqIEBwYXJhbSB7U3RyaW5nfSBzDQogKiBAcmV0dXJucyB7U3RyaW5nfQ0KICogQGFwaSBwdWJsaWMNCiAqLw0KDQpleHBvcnRzLmhleCA9IGhleF9zaGExOw0KDQovKioNCiAqIEhhc2hlcyBhIHN0cmluZyB1c2luZyBTSEExIGFuZCByZXR1cm5zIGEgYmFzZTY0IHJlcHJlc2VudGF0aW9uIG9mIGl0Lg0KICoNCiAqIEBuYW1lIGJhc2U2NChzKQ0KICogQHBhcmFtIHtTdHJpbmd9IHMNCiAqIEByZXR1cm5zIHtTdHJpbmd9DQogKiBAYXBpIHB1YmxpYw0KICovDQoNCmV4cG9ydHMuYmFzZTY0ID0gYjY0X3NoYTE7DQoNCi8qKg0KICogSGFzaGVzIGEgc3RyaW5nIHVzaW5nIFNIQTEgYW5kIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaXQuDQogKg0KICogQG5hbWUgc3RyKHMpDQogKiBAcGFyYW0ge1N0cmluZ30gcw0KICogQHJldHVybnMge1N0cmluZ30NCiAqIEBhcGkgcHVibGljDQogKi8NCg0KZXhwb3J0cy5zdHIgPSBzdHJfc2hhMTsNCg0KLyoqDQogKiBDYWxjdWxhdGVzIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSwgcmV0dXJuaW5nIGEgaGV4DQogKiByZXByZXNlbnRhdGlvbiBvZiBpdC4NCiAqDQogKiBAbmFtZSBoZXhfaG1hYyhrZXksIGRhdGEpDQogKiBAcGFyYW0ge1N0cmluZ30ga2V5DQogKiBAcGFyYW0ge1N0cmluZ30gZGF0YQ0KICogQHJldHVybnMge1N0cmluZ30NCiAqIEBhcGkgcHVibGljDQogKi8NCg0KZXhwb3J0cy5oZXhfaG1hYyA9IGhleF9obWFjX3NoYTE7DQoNCi8qKg0KICogQ2FsY3VsYXRlcyB0aGUgSE1BQy1TSEExIG9mIGEga2V5IGFuZCBzb21lIGRhdGEsIHJldHVybmluZyBhIGJhc2U2NA0KICogcmVwcmVzZW50YXRpb24gb2YgaXQuDQogKg0KICogQG5hbWUgYmFzZTY0X2htYWMoa2V5LCBkYXRhKQ0KICogQHBhcmFtIHtTdHJpbmd9IGtleQ0KICogQHBhcmFtIHtTdHJpbmd9IGRhdGENCiAqIEByZXR1cm5zIHtTdHJpbmd9DQogKiBAYXBpIHB1YmxpYw0KICovDQoNCmV4cG9ydHMuYmFzZTY0X2htYWMgPSBiNjRfaG1hY19zaGExOw0KDQovKioNCiAqIENhbGN1bGF0ZXMgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhLCByZXR1cm5pbmcgYSBzdHJpbmcNCiAqIHJlcHJlc2VudGF0aW9uIG9mIGl0Lg0KICoNCiAqIEBuYW1lIHN0cl9obWFjKGtleSwgZGF0YSkNCiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkNCiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhDQogKiBAcmV0dXJucyB7U3RyaW5nfQ0KICogQGFwaSBwdWJsaWMNCiAqLw0KDQpleHBvcnRzLnN0cl9obWFjID0gc3RyX2htYWNfc2hhMTsNCgoKfSl9OwoKLyoqKioqKioqKiogZGIgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJkYiJdID0ge2xvYWQ6IChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCByZXF1aXJlKSB7CgovKmdsb2JhbCAkOiBmYWxzZSAqLwoKLyoqCiAqICMjIERCIE1vZHVsZQogKgogKiBUaGlzIGNvbnRhaW5zIHRoZSBjb3JlIGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENvdWNoREIuIFRoYXQgaW5jbHVkZXMKICogZG9jdW1lbnQgQ1JVRCBvcGVyYXRpb25zLCBxdWVyeWluZyB2aWV3cyBhbmQgY3JlYXRpbmcvZGVsZXRpbmcgZGF0YWJhc2VzLgogKgogKgogKiAjIyMgRXZlbnRzCiAqCiAqIFRoZSBkYiBtb2R1bGUgaXMgYW4gRXZlbnRFbWl0dGVyLiBTZWUgdGhlCiAqIFtldmVudHMgcGFja2FnZV0oaHR0cDovL2thbi5zby9wYWNrYWdlcy9kZXRhaWxzL2V2ZW50cykgZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAqCiAqICMjIyMgdW5hdXRob3JpemVkCiAqCiAqIEVtaXR0ZWQgYnkgdGhlIGRiIG1vZHVsZSB3aGVuIGEgcmVxdWVzdCByZXN1bHRzIGluIGEgNDAxIFVuYXV0aG9yaXplZAogKiByZXNwb25zZS4gVGhpcyBpcyBsaXN0ZW5lZCB0byB1c2VkIGJ5IHRoZSBzZXNzaW9uIG1vZHVsZSB0byBoZWxwIGRldGVjdAogKiBzZXNzaW9uIHRpbWVvdXRzIGV0Yy4KICoKICogYGBgamF2YXNjcmlwdAogKiB2YXIgZGIgPSByZXF1aXJlKCJkYiIpOwogKgogKiBkYi5vbigndW5hdXRob3JpemVkJywgZnVuY3Rpb24gKHJlcSkgewogKiAgICAgLy8gcmVxIGlzIHRoZSBhamF4IHJlcXVlc3Qgb2JqZWN0IHdoaWNoIHJldHVybmVkIDQwMQogKiB9KTsKICogYGBgCiAqCiAqIEBtb2R1bGUKICovCgoKdmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpLAogICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKS5fOwoKCi8qKgogKiBUZXN0cyBpZiBydW5uaW5nIGluIHRoZSBicm93c2VyCiAqCiAqIEByZXR1cm5zIHtCb29sZWFufQogKi8KCmZ1bmN0aW9uIGlzQnJvd3NlcigpIHsKICAgIHJldHVybiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKTsKfQoKCi8qKgogKiBUaGlzIG1vZHVsZSBpcyBhbiBFdmVudEVtaXR0ZXIsIHVzZWQgZm9yIGVtaXR0aW5nICd1bmF1dGhvcml6ZWQnIGV2ZW50cwogKi8KCnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpOwoKCi8qKgogKiBUYWtlbiBmcm9tIGpRdWVyeSAxLjQuNCBzbyB3ZSBjYW4gc3VwcG9ydCBtb3JlIHJlY2VudCB2ZXJzaW9ucyBvZiBqUXVlcnkuCiAqLwoKdmFyIGh0dHBEYXRhID0gZnVuY3Rpb24gKHhociwgdHlwZSwgcykgewogICAgdmFyIGN0ID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCJjb250ZW50LXR5cGUiKSB8fCAiIiwKICAgICAgICB4bWwgPSB0eXBlID09PSAieG1sIiB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKCJ4bWwiKSA+PSAwLAogICAgICAgIGRhdGEgPSB4bWwgPyB4aHIucmVzcG9uc2VYTUwgOiB4aHIucmVzcG9uc2VUZXh0OwoKICAgIGlmICh4bWwgJiYgZGF0YS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09ICJwYXJzZXJlcnJvciIpIHsKICAgICAgICAkLmVycm9yKCJwYXJzZXJlcnJvciIpOwogICAgfQogICAgaWYgKHMgJiYgcy5kYXRhRmlsdGVyKSB7CiAgICAgICAgZGF0YSA9IHMuZGF0YUZpbHRlcihkYXRhLCB0eXBlKTsKICAgIH0KICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gInN0cmluZyIpIHsKICAgICAgICBpZiAodHlwZSA9PT0gImpzb24iIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoImpzb24iKSA+PSAwKSB7CiAgICAgICAgICAgIGRhdGEgPSAkLnBhcnNlSlNPTihkYXRhKTsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gInNjcmlwdCIgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZigiamF2YXNjcmlwdCIpID49IDApIHsKICAgICAgICAgICAgJC5nbG9iYWxFdmFsKGRhdGEpOwogICAgICAgIH0KICAgIH0KICAgIHJldHVybiBkYXRhOwp9OwoKCi8qKgogKiBSZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFqYXggcmVzcG9uc2VzIGZyb20ganF1ZXJ5IGFuZCBjYWxscwogKiB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZGF0YSBvciBhcHByb3ByaWF0ZSBlcnJvci4KICoKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHByaXZhdGUKICovCgpmdW5jdGlvbiBvbkNvbXBsZXRlKG9wdGlvbnMsIGNhbGxiYWNrKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKHJlcSkgewogICAgICAgIHZhciByZXNwOwogICAgICAgIHZhciBjdHlwZSA9IHJlcS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7CiAgICAgICAgaWYgKGN0eXBlID09PSAnYXBwbGljYXRpb24vanNvbicgfHwgY3R5cGUgPT09ICd0ZXh0L2pzb24nKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICByZXNwID0gaHR0cERhdGEocmVxLCAianNvbiIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGlmIChvcHRpb25zLmV4cGVjdF9qc29uKSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgIHJlc3AgPSBodHRwRGF0YShyZXEsICJqc29uIik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soCiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignRXhwZWN0ZWQgSlNPTiByZXNwb25zZSwgZ290ICcgKyBjdHlwZSkKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgcmVzcCA9IHJlcS5yZXNwb25zZVRleHQ7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDQwMSkgewogICAgICAgICAgICBleHBvcnRzLmVtaXQoJ3VuYXV0aG9yaXplZCcsIHJlcSk7CiAgICAgICAgfQogICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDAgfHwgcmVxLnN0YXR1cyA9PT0gMjAxIHx8IHJlcS5zdGF0dXMgPT09IDIwMikgewogICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwKTsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiAocmVzcC5lcnJvciB8fCByZXNwLnJlYXNvbikgewogICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHJlc3AucmVhc29uIHx8IHJlc3AuZXJyb3IpOwogICAgICAgICAgICBlcnIuZXJyb3IgPSByZXNwLmVycm9yOwogICAgICAgICAgICBlcnIucmVhc29uID0gcmVzcC5yZWFzb247CiAgICAgICAgICAgIGVyci5jb2RlID0gcmVzcC5jb2RlOwogICAgICAgICAgICBlcnIuc3RhdHVzID0gcmVxLnN0YXR1czsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIC8vIFRPRE86IG1hcCBzdGF0dXMgY29kZSB0byBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2UKICAgICAgICAgICAgdmFyIGVycjIgPSBuZXcgRXJyb3IoJ1JldHVybmVkIHN0YXR1cyBjb2RlOiAnICsgcmVxLnN0YXR1cyk7CiAgICAgICAgICAgIGVycjIuc3RhdHVzID0gcmVxLnN0YXR1czsKICAgICAgICAgICAgY2FsbGJhY2soZXJyMik7CiAgICAgICAgfQogICAgfTsKfQoKCi8qKgogKiBBdHRlbXB0cyB0byBndWVzcyB0aGUgZGF0YWJhc2UgbmFtZSBhbmQgZGVzaWduIGRvYyBpZCBmcm9tIHRoZSBjdXJyZW50IFVSTCwKICogb3IgdGhlIGxvYyBwYXJhbXRlci4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCAnZGInLCAnZGVzaWduX2RvYycgYW5kICdyb290JwogKiBwcm9wZXJ0aWVzLCBvciBudWxsIGZvciBhIFVSTCBub3QgbWF0Y2hpbmcgdGhlIGV4cGVjdGVkIGZvcm1hdCAocGVyaGFwcwogKiBiZWhpbmcgYSB2aG9zdCkuCiAqCiAqIFlvdSB3b3VsZG4ndCBub3JtYWxseSB1c2UgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSwgYnV0IHVzZSBgZGIuY3VycmVudCgpYCB0bwogKiByZXR1cm4gYSBEQiBvYmplY3QgYm91bmQgdG8gdGhlIGN1cnJlbnQgZGF0YWJhc2UgaW5zdGVhZC4KICoKICogQG5hbWUgZ3Vlc3NDdXJyZW50KFtsb2NdKQogKiBAcGFyYW0ge1N0cmluZ30gbG9jIC0gQW4gYWx0ZXJuYXRpdmUgVVJMIHRvIHVzZSBpbnN0ZWFkIG9mIHdpbmRvdy5sb2NhdGlvbgogKiAgICAgKG9wdGlvbmFsKQogKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IC0gQW4gb2JqZWN0IHdpdGggJ2RiJywgJ2Rlc2lnbl9kb2MnIGFuZCAncm9vdCcKICogICAgIHByb3BlcnRpZXMsIG9yIG51bGwgZm9yIGEgVVJMIG5vdCBtYXRjaGluZyB0aGUKICogICAgIGV4cGVjdGVkIGZvcm1hdCAocGVyaGFwcyBiZWhpbmcgYSB2aG9zdCkKICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLmd1ZXNzQ3VycmVudCA9IGZ1bmN0aW9uIChsb2MpIHsKICAgIHZhciBsb2MgPSBsb2MgfHwgd2luZG93LmxvY2F0aW9uOwoKICAgIC8qKgogICAgICogQSBkYXRhYmFzZSBtdXN0IGJlIG5hbWVkIHdpdGggYWxsIGxvd2VyY2FzZSBsZXR0ZXJzIChhLXopLCBkaWdpdHMgKDAtOSksCiAgICAgKiBvciBhbnkgb2YgdGhlIF8kKCkrLS8gY2hhcmFjdGVycyBhbmQgbXVzdCBlbmQgd2l0aCBhIHNsYXNoIGluIHRoZSBVUkwuCiAgICAgKiBUaGUgbmFtZSBoYXMgdG8gc3RhcnQgd2l0aCBhIGxvd2VyY2FzZSBsZXR0ZXIgKGEteikuCiAgICAgKgogICAgICogaHR0cDovL3dpa2kuYXBhY2hlLm9yZy9jb3VjaGRiL0hUVFBfZGF0YWJhc2VfQVBJCiAgICAgKi8KCiAgICB2YXIgcmUgPSAvXC8oW2Etel1bYS16MC05X1wkXChcKVwrLVwvXSopXC9fZGVzaWduXC8oW15cL10rKVwvLzsKICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMobG9jLnBhdGhuYW1lKTsKCiAgICBpZiAobWF0Y2gpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBkYjogbWF0Y2hbMV0sCiAgICAgICAgICAgIGRlc2lnbl9kb2M6IG1hdGNoWzJdLAogICAgICAgICAgICByb290OiAnLycKICAgICAgICB9CiAgICB9CiAgICByZXR1cm4gbnVsbDsKfTsKCi8qKgogKiBDb252ZXJ0cyBhbiBvYmplY3QgdG8gYSBzdHJpbmcgb2YgcHJvcGVybHkgZXNjYXBlZCBVUkwgcGFyYW1ldGVycy4KICoKICogQG5hbWUgZXNjYXBlVXJsUGFyYW1zKFtvYmpdKQogKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdXJsIHBhcmFtZXRlcnMsIHdpdGgKICogICAgICAgcGFyYW1ldGVyIG5hbWVzIHN0b3JlZCBhcyBwcm9wZXJ0eSBuYW1lcyAob3Iga2V5cykuCiAqIEByZXR1cm5zIHtTdHJpbmd9CiAqIEBhcGkgcHVibGljCiAqLwoKZXhwb3J0cy5lc2NhcGVVcmxQYXJhbXMgPSBmdW5jdGlvbiAob2JqKSB7CiAgICB2YXIgcnYgPSBbIF07CiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7CiAgICAgICAgcnYucHVzaCgKICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKwogICAgICAgICAgICAgICAgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKQogICAgICAgICk7CiAgICB9CiAgICByZXR1cm4gKHJ2Lmxlbmd0aCA+IDAgPyAoJz8nICsgcnYuam9pbignJicpKSA6ICcnKTsKfTsKCi8qKgogKiBFbmNvZGVzIGEgZG9jdW1lbnQgaWQgb3IgdmlldywgbGlzdCBvciBzaG93IG5hbWUuIFRoaXMgYWxzbyB3aWxsIG1ha2Ugc3VyZQogKiB0aGUgZm9yd2FyZC1zbGFzaCBpcyBub3QgZXNjYXBlZCBmb3IgZG9jdW1lbnRzIHdpdGggaWQncyBiZWdpbm5pbmcgd2l0aAogKiAiXF9kZXNpZ24vIi4KICoKICogQG5hbWUgZW5jb2RlKHN0cikKICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHRoZSBuYW1lIG9yIGlkIHRvIGVzY2FwZQogKiBAcmV0dXJucyB7U3RyaW5nfQogKiBAYXBpIHB1YmxpYwogKi8KCmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikgewogICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL15fZGVzaWduJTJGLywgJ19kZXNpZ24vJyk7Cn07CgoKLyoqCiAqIFByb3Blcmx5IGVuY29kZXMgcXVlcnkgcGFyYW1ldGVycyB0byBDb3VjaERCIHZpZXdzIGV0Yy4gSGFuZGxlIGNvbXBsZXgKICoga2V5cyBhbmQgb3RoZXIgbm9uLXN0cmluZyBwYXJhbWV0ZXJzIGJ5IHBhc3NpbmcgdGhyb3VnaCBKU09OLnN0cmluZ2lmeS4KICogUmV0dXJucyBhIHNoYWxsb3ctY29waWVkIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBxdWVyeSBhZnRlciBjb21wbGV4IHZhbHVlcwogKiBoYXZlIGJlZW4gc3RyaW5naWZpZWQuCiAqCiAqIEBuYW1lIHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KQogKiBAcGFyYW0ge09iamVjdH0gcXVlcnkKICogQHJldHVybnMge09iamVjdH0KICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLnN0cmluZ2lmeVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7CiAgICB2YXIgcSA9IHt9OwogICAgZm9yICh2YXIgayBpbiBxdWVyeSkgewogICAgICAgIGlmICh0eXBlb2YgcXVlcnlba10gIT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgIHFba10gPSBKU09OLnN0cmluZ2lmeShxdWVyeVtrXSk7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICBxW2tdID0gcXVlcnlba107CiAgICAgICAgfQogICAgfQogICAgcmV0dXJuIHE7Cn07CgoKLyoqCiAqIE1ha2UgYSByZXF1ZXN0LCB3aXRoIHNvbWUgZGVmYXVsdCBzZXR0aW5ncywgcHJvcGVyIGNhbGxiYWNrCiAqIGhhbmRsaW5nLCBhbmQgb3B0aW9uYWwgY2FjaGluZy4gVXNlZCBiZWhpbmQtdGhlLXNjZW5lcyBieQogKiBtb3N0IG90aGVyIERCIG1vZHVsZSBmdW5jdGlvbnMuCiAqCiAqIEBuYW1lIHJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spCiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHsKICAgIG9wdGlvbnMuY29tcGxldGUgPSBvbkNvbXBsZXRlKG9wdGlvbnMsIGNhbGxiYWNrKTsKICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAnanNvbic7CiAgICAkLmFqYXgob3B0aW9ucyk7Cn07CgoKLyoqCiAqIENyZWF0ZXMgYSBDb3VjaERCIGRhdGFiYXNlLgogKgogKiBJZiB5b3UncmUgcnVubmluZyBiZWhpbmQgYSB2aXJ0dWFsIGhvc3QgeW91J2xsIG5lZWQgdG8gc2V0IHVwCiAqIGFwcHJvcHJpYXRlIHJld3JpdGVzIGZvciBhIERFTEVURSByZXF1ZXN0IHRvICcvJyBlaXRoZXIgdHVybmluZyBvZmYgc2FmZQogKiByZXdyaXRlcyBvciBzZXR0aW5nIHVwIGEgbmV3IHZob3N0IGVudHJ5LgogKgogKiBAbmFtZSBjcmVhdGVEYXRhYmFzZShuYW1lLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCmV4cG9ydHMuY3JlYXRlRGF0YWJhc2UgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsKICAgIHZhciByZXEgPSB7CiAgICAgICAgdHlwZTogJ1BVVCcsCiAgICAgICAgdXJsOiAnLycgKyBleHBvcnRzLmVuY29kZShuYW1lLnJlcGxhY2UoL15cLysvLCAnJykpCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKLyoqCiAqIERlbGV0ZXMgYSBDb3VjaERCIGRhdGFiYXNlLgogKgogKiBJZiB5b3UncmUgcnVubmluZyBiZWhpbmQgYSB2aXJ0dWFsIGhvc3QgeW91J2xsIG5lZWQgdG8gc2V0IHVwCiAqIGFwcHJvcHJpYXRlIHJld3JpdGVzIGZvciBhIERFTEVURSByZXF1ZXN0IHRvICcvJyBlaXRoZXIgdHVybmluZyBvZmYgc2FmZQogKiByZXdyaXRlcyBvciBzZXR0aW5nIHVwIGEgbmV3IHZob3N0IGVudHJ5LgogKgogKiBAbmFtZSBkZWxldGVEYXRhYmFzZShuYW1lLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCi8vIFRPRE86IGRldGVjdCB3aGVuICduYW1lJyBhcmd1bWVudCBpcyBhIHVybCBhbmQgZG9uJ3QgY29uc3RydWN0IGEgdXJsIHRoZW4KZXhwb3J0cy5kZWxldGVEYXRhYmFzZSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykgewogICAgdmFyIHJlcSA9IHsKICAgICAgICB0eXBlOiAnREVMRVRFJywKICAgICAgICB1cmw6ICcvJyArIGV4cG9ydHMuZW5jb2RlKG5hbWUucmVwbGFjZSgvXlwvKy8sICcnKSkKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIExpc3RzIGFsbCBkYXRhYnNlcwogKgogKiBJZiB5b3UncmUgcnVubmluZyBiZWhpbmQgYSB2aXJ0dWFsIGhvc3QgeW91J2xsIG5lZWQgdG8gc2V0IHVwCiAqIGFwcHJvcHJpYXRlIHJld3JpdGVzIGZvciBhIERFTEVURSByZXF1ZXN0IHRvICcvJyBlaXRoZXIgdHVybmluZyBvZmYgc2FmZQogKiByZXdyaXRlcyBvciBzZXR0aW5nIHVwIGEgbmV3IHZob3N0IGVudHJ5LgogKgogKiBAbmFtZSBhbGxEYnMoY2FsbGJhY2spCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLmFsbERicyA9IGZ1bmN0aW9uIChjYWxsYmFjaykgewogICAgdmFyIHJlcSA9IHsKICAgICAgICB0eXBlOiAnR0VUJywKICAgICAgICB1cmw6ICcvX2FsbF9kYnMnCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBSZXR1cm5zIGEgbmV3IFVVSUQgZ2VuZXJhdGVkIGJ5IENvdWNoREIuIEl0cyBwb3NzaWJsZSB0byBjYWNoZQogKiBtdWx0aXBsZSBVVUlEcyBmb3IgbGF0ZXIgdXNlLCB0byBhdm9pZCBtYWtpbmcgdG9vIG1hbnkgcmVxdWVzdHMuCiAqCiAqIEBuYW1lIG5ld1VVSUQoY2FjaGVOdW0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge051bWJlcn0gY2FjaGVOdW0gKG9wdGlvbmFsLCBkZWZhdWx0OiAxKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKdmFyIHV1aWRDYWNoZSA9IFtdOwoKZXhwb3J0cy5uZXdVVUlEID0gZnVuY3Rpb24gKGNhY2hlTnVtLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gY2FjaGVOdW07CiAgICAgICAgY2FjaGVOdW0gPSAxOwogICAgfQogICAgaWYgKHV1aWRDYWNoZS5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXVpZENhY2hlLnNoaWZ0KCkpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6ICcvX3V1aWRzJywKICAgICAgICBkYXRhOiB7Y291bnQ6IGNhY2hlTnVtfSwKICAgICAgICBleHBlY3RfanNvbjogdHJ1ZQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIH0KICAgICAgICB1dWlkQ2FjaGUgPSByZXNwLnV1aWRzOwogICAgICAgIGNhbGxiYWNrKG51bGwsIHV1aWRDYWNoZS5zaGlmdCgpKTsKICAgIH0pOwp9OwoKCi8qKgogKiBEQiBvYmplY3QgY3JlYXRlZCBieSB1c2UoZGJuYW1lKSBmdW5jdGlvbgogKi8KCmZ1bmN0aW9uIERCKHVybCkgewogICAgdGhpcy51cmwgPSB1cmw7CiAgICAvLyBhZGQgdGhlIG1vZHVsZSBmdW5jdGlvbnMgdG8gdGhlIERCIG9iamVjdAogICAgZm9yICh2YXIgayBpbiBleHBvcnRzKSB7CiAgICAgICAgdGhpc1trXSA9IGV4cG9ydHNba107CiAgICB9Cn07CgoKLyoqCiAqIENyZWF0ZXMgYSBuZXcgREIgb2JqZWN0IHdpdGggbWV0aG9kcyBvcGVyYXRpbmcgb24gdGhlIGRhdGFiYXNlIGF0ICd1cmwnCiAqCiAqIFRoZSBEQiBvYmplY3QgYWxzbyBleHBvc2VzIHRoZSBzYW1lIG1vZHVsZS1sZXZlbCBtZXRob2RzIChlZywgY3JlYXRlRGF0YWJhc2UpCiAqIHNvIGl0IGNhbiBiZSB1c2VkIGluLXBsYWNlIG9mIHRoZSBkYiBleHBvcnRzIG9iamVjdCwgZm9yIGV4YW1wbGU6CiAqCiAqIGBgYGphdmFzY3JpcHQKICogdmFyIGRiID0gcmVxdWlyZSgnZGInKS51c2UoJ215ZGInKTsKICoKICogZGIuY3JlYXRlRGF0YWJhc2UoJ2V4YW1wbGUnLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcKICogfSk7CiAqIGBgYAogKgogKiBAbmFtZSB1c2UodXJsKQogKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIHVybCB0byBiaW5kIHRoZSBuZXcgREIgb2JqZWN0IHRvCiAqIEByZXR1cm5zIHtEQn0KICogQGFwaSBwdWJsaWMKICovCgovLyBUT0RPOiBoYW5kbGUgZnVsbCB1cmxzLCBub3QganVzdCBkYiBuYW1lcwpleHBvcnRzLnVzZSA9IGZ1bmN0aW9uICh1cmwpIHsKICAgIC8qIEZvcmNlIGxlYWRpbmcgc2xhc2g7IG1ha2UgYWJzb2x1dGUgcGF0aCAqLwogICAgcmV0dXJuIG5ldyBEQigodXJsLnN1YnN0cigwLCAxKSAhPT0gJy8nID8gJy8nIDogJycpICsgdXJsKTsKfTsKCi8qKgogKiBBdHRlbXB0cyB0byBndWVzcyB0aGUgY3VycmVudCBEQiBuYW1lIGFuZCByZXR1cm4gYSBEQiBvYmplY3QgdXNpbmcgdGhhdC4KICogU2hvdWxkIHdvcmsgcmVsaWFibHkgdW5sZXNzIHJ1bm5pbmcgYmVoaW5kIGEgdmlydHVhbCBob3N0LgogKgogKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGN1cnJlbnQgZGF0YWJhc2UgdXJsIGNhbm5vdCBiZSBkZXRlY3RlZC4KICoKICogVGhlIERCIG9iamVjdCBhbHNvIGV4cG9zZXMgdGhlIHNhbWUgbW9kdWxlLWxldmVsIG1ldGhvZHMgKGVnLCBjcmVhdGVEYXRhYmFzZSkKICogc28gaXQgY2FuIGJlIHVzZWQgaW4tcGxhY2Ugb2YgdGhlIGRiIGV4cG9ydHMgb2JqZWN0LCBmb3IgZXhhbXBsZToKICoKICogYGBgamF2YXNjcmlwdAogKiB2YXIgZGIgPSByZXF1aXJlKCdkYicpLmN1cnJlbnQoKTsKICoKICogZGIuY3JlYXRlRGF0YWJhc2UoJ2V4YW1wbGUnLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcKICogfSk7CiAqIGBgYAogKgogKiBAbmFtZSBjdXJyZW50KCkKICogQHJldHVybnMge0RCfQogKiBAYXBpIHB1YmxpYwogKi8KCmV4cG9ydHMuY3VycmVudCA9IGZ1bmN0aW9uICgpIHsKICAgIC8vIGd1ZXNzIGN1cnJlbnQgZGIgdXJsIGV0YwogICAgdmFyIGN1cnIgPSBleHBvcnRzLmd1ZXNzQ3VycmVudCgpOwogICAgaWYgKCFjdXJyKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICAgICAnQ2Fubm90IGd1ZXNzIGN1cnJlbnQgZGF0YWJhc2UgVVJMLCBpZiBydW5uaW5nIGJlaGluZCBhIHZpcnR1YWwgJyArCiAgICAgICAgICAgICdob3N0IHlvdSBuZWVkIHRvIGV4cGxpY2l0bHkgc2V0IHRoZSBkYXRhYmFzZSBVUkwgdXNpbmcgJyArCiAgICAgICAgICAgICdkYi51c2UoZGF0YWJhc2VfdXJsKSBpbnN0ZWFkIG9mIGRiLmN1cnJlbnQoKScKICAgICAgICApOwogICAgfQogICAgcmV0dXJuIGV4cG9ydHMudXNlKGN1cnIuZGIpOwp9OwoKCi8qKgogKiBGZXRjaGVzIGEgcmV3cml0ZSBmcm9tIHRoZSBkYXRhYmFzZSB0aGUgYXBwIGlzIHJ1bm5pbmcgb24uIFJlc3VsdHMKICogYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjawogKiByZXNlcnZlZCBmb3IgYW55IGV4Y2VwdGlvbnMgdGhhdCBvY2N1cnJlZCAobm9kZS5qcyBzdHlsZSkuCiAqCiAqIEBuYW1lIERCLmdldFJld3JpdGUobmFtZSwgcGF0aCwgW3FdLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGVzaWduIGRvYwogKiBAcGFyYW0ge1N0cmluZ30gcGF0aAogKiBAcGFyYW0ge09iamVjdH0gcSAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuZ2V0UmV3cml0ZSA9IGZ1bmN0aW9uIChuYW1lLCBwYXRoLCAvKm9wdGlvbmFsKi9xLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CiAgICAvLyBwcmVwZW5kIGZvcndhcmQtc2xhc2ggaWYgbWlzc2luZwogICAgcGF0aCA9IChwYXRoWzBdID09PSAnLycpID8gcGF0aDogJy8nICsgcGF0aDsKCiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gZXhwb3J0cy5zdHJpbmdpZnlRdWVyeShxKTsKICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6IHRoaXMudXJsICsgJy9fZGVzaWduLycgKyBleHBvcnRzLmVuY29kZShuYW1lKSArICcvX3Jld3JpdGUnICsgcGF0aCwKICAgICAgICBkYXRhOiBkYXRhCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBRdWVyaWVzIGFsbCBkZXNpZ24gZG9jdW1lbnRzIGluIHRoZSBkYXRhYmFzZS4KICoKICogQG5hbWUgREIuYWxsRGVzaWduRG9jcyhbcV0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge09iamVjdH0gcSAtIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gcGFzcyB0byAvX2FsbF9kb2NzIChvcHRpb25hbCkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCkRCLnByb3RvdHlwZS5hbGxEZXNpZ25Eb2NzID0gZnVuY3Rpb24gKC8qb3B0aW9uYWwqL3EsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KICAgIHEuc3RhcnRrZXkgPSAnIl9kZXNpZ24iJzsKICAgIHEuZW5ka2V5ID0gJyJfZGVzaWduMCInOwogICAgdGhpcy5hbGxEb2NzKHEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogUXVlcmllcyBhbGwgZG9jdW1lbnRzIGluIHRoZSBkYXRhYmFzZSAoaW5jbHVkZSBkZXNpZ24gZG9jcykuCiAqCiAqIEBuYW1lIERCLmFsbERvY3MoW3FdLCBjYWxsYmFjaykKICogQHBhcmFtIHtPYmplY3R9IHEgLSBxdWVyeSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gL19hbGxfZG9jcyAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuYWxsRG9jcyA9IGZ1bmN0aW9uICgvKm9wdGlvbmFsKi9xLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gZXhwb3J0cy5zdHJpbmdpZnlRdWVyeShxKTsKICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6IHRoaXMudXJsICsgJy9fYWxsX2RvY3MnLAogICAgICAgIGRhdGE6IGRhdGEsCiAgICAgICAgZXhwZWN0X2pzb246IHRydWUKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIEZldGNoZXMgYSBkb2N1bWVudCBmcm9tIHRoZSBkYXRhYmFzZSB0aGUgYXBwIGlzIHJ1bm5pbmcgb24uIFJlc3VsdHMgYXJlCiAqIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjayByZXNlcnZlZAogKiBmb3IgYW55IGV4Y2VwdGlvbnMgdGhhdCBvY2N1cnJlZCAobm9kZS5qcyBzdHlsZSkuCiAqCiAqIEBuYW1lIERCLmdldERvYyhpZCwgW3FdLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IGlkCiAqIEBwYXJhbSB7T2JqZWN0fSBxIChvcHRpb25hbCkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCkRCLnByb3RvdHlwZS5nZXREb2MgPSBmdW5jdGlvbiAoaWQsIC8qb3B0aW9uYWwqL3EsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWlkKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXREb2MgcmVxdWlyZXMgYW4gaWQgcGFyYW1ldGVyIHRvIHdvcmsgcHJvcGVybHknKTsKICAgIH0KICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IGV4cG9ydHMuc3RyaW5naWZ5UXVlcnkocSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiB0aGlzLnVybCArICcvJyArIGV4cG9ydHMuZW5jb2RlKGlkKSwKICAgICAgICBleHBlY3RfanNvbjogdHJ1ZSwKICAgICAgICBkYXRhOiBkYXRhCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBTYXZlcyBhIGRvY3VtZW50IHRvIHRoZSBkYXRhYmFzZSB0aGUgYXBwIGlzIHJ1bm5pbmcgb24uIFJlc3VsdHMgYXJlCiAqIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjayByZXNlcnZlZAogKiBmb3IgYW55IGV4Y2VwdGlvbnMgdGhhdCBvY2N1cnJlZCAobm9kZS5qcyBzdHlsZSkuCiAqCiAqIEBuYW1lIERCLnNhdmVEb2MoZG9jLCBjYWxsYmFjaykKICogQHBhcmFtIHtPYmplY3R9IGRvYwogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLnNhdmVEb2MgPSBmdW5jdGlvbiAoZG9jLCBjYWxsYmFjaykgewogICAgdmFyIG1ldGhvZCwgdXJsID0gdGhpcy51cmw7CiAgICBpZiAoZG9jLl9pZCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgbWV0aG9kID0gIlBPU1QiOwogICAgfQogICAgZWxzZSB7CiAgICAgICAgbWV0aG9kID0gIlBVVCI7CiAgICAgICAgdXJsICs9ICcvJyArIGRvYy5faWQ7CiAgICB9CiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZG9jKTsKICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB0eXBlOiBtZXRob2QsCiAgICAgICAgdXJsOiB1cmwsCiAgICAgICAgZGF0YTogZGF0YSwKICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsCiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJywKICAgICAgICBleHBlY3RfanNvbjogdHJ1ZQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCi8qKgogKiBEZWxldGVzIGEgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcCBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZQogKiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQKICogZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5yZW1vdmVEb2MoZG9jLCBjYWxsYmFjaykKICogQHBhcmFtIHtPYmplY3R9IGRvYwogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLnJlbW92ZURvYyA9IGZ1bmN0aW9uIChkb2MsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWRvYy5faWQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZURvYyByZXF1aXJlcyBhbiBfaWQgZmllbGQgaW4geW91ciBkb2N1bWVudCcpOwogICAgfQogICAgaWYgKCFkb2MuX3JldikgewogICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlRG9jIHJlcXVpcmVzIGEgX3JldiBmaWVsZCBpbiB5b3VyIGRvY3VtZW50Jyk7CiAgICB9CiAgICB2YXIgcmVxID0gewogICAgICAgIHR5cGU6ICdERUxFVEUnLAogICAgICAgIHVybDogdGhpcy51cmwgKyAnLycgKyBleHBvcnRzLmVuY29kZShkb2MuX2lkKSArCiAgICAgICAgICAgICAnP3Jldj0nICsgZXhwb3J0cy5lbmNvZGUoZG9jLl9yZXYpCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBGZXRjaGVzIGEgdmlldyBmcm9tIHRoZSBkYXRhYmFzZSB0aGUgYXBwIGlzIHJ1bm5pbmcgb24uIFJlc3VsdHMgYXJlCiAqIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjayByZXNlcnZlZAogKiBmb3IgYW55IGV4Y2VwdGlvbnMgdGhhdCBvY2N1cnJlZCAobm9kZS5qcyBzdHlsZSkuCiAqCiAqIEBuYW1lIERCLmdldFZpZXcobmFtZSwgdmlldywgW3FdLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBkZXNpZ24gZG9jIHRvIHVzZQogKiBAcGFyYW0ge1N0cmluZ30gdmlldyAtIG5hbWUgb2YgdGhlIHZpZXcKICogQHBhcmFtIHtPYmplY3R9IHEgKG9wdGlvbmFsKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiAobmFtZSwgdmlldywgLypvcHQqL3EsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KICAgIHZhciB2aWV3bmFtZSA9IGV4cG9ydHMuZW5jb2RlKHZpZXcpOwogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IGV4cG9ydHMuc3RyaW5naWZ5UXVlcnkocSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiAodGhpcy51cmwgKwogICAgICAgICAgICAnL19kZXNpZ24vJyArIGV4cG9ydHMuZW5jb2RlKG5hbWUpICsKICAgICAgICAgICAgJy9fdmlldy8nICsgdmlld25hbWUKICAgICAgICApLAogICAgICAgIGV4cGVjdF9qc29uOiB0cnVlLAogICAgICAgIGRhdGE6IGRhdGEKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIEZldGNoZXMgYSBzcGF0aWFsIHZpZXcgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcCBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZQogKiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQKICogZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBfX1BhcmFtZXRlcnM6X18KICogKiBiYm94IC0gdGhlIGJvdW5kaW5nIGJveCBmaWx0ZXIgZS5nLjogYmJveDogJzAsMCwxODAsOTAnCiAqICogcGxhbmVfYm91bmRzIC0gZS5nLjogcGxhbmVfYm91bmRzOiAnLTE4MCwtOTAsMTgwLDkwJwogKiAqIHN0YWxlIC0gc3RhbGU6ICdvaycgcHJldmVudHMgdGhlIHNwYXRpYWwgaW5kZXggdG8gYmUgcmVidWlsdAogKiAqIGNvdW50IC0gY291bnQ6IHRydWUgd2lsbCBvbmx5IHJldHVybiB0aGUgbnVtYmVyIG9mIGdlb21ldHJpZXMKICoKICogQG5hbWUgREIuZ2V0U3BhdGlhbFZpZXcobmFtZSwgdmlldywgcSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgZGVzaWduIGRvYyB0byB1c2UKICogQHBhcmFtIHtTdHJpbmd9IHZpZXcgLSBuYW1lIG9mIHRoZSB2aWV3CiAqIEBwYXJhbSB7T2JqZWN0fSBxIC0gcXVlcnkgcGFyYW1ldGVycyAoc2VlIG9wdGlvbnMgYWJvdmUpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuZ2V0U3BhdGlhbFZpZXcgPSBmdW5jdGlvbiAobmFtZSwgdmlldywgcSwgY2FsbGJhY2spIHsKICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQogICAgdmFyIHZpZXduYW1lID0gZXhwb3J0cy5lbmNvZGUodmlldyk7CiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gZXhwb3J0cy5zdHJpbmdpZnlRdWVyeShxKTsKICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6ICh0aGlzLnVybCArCiAgICAgICAgICAgICcvX2Rlc2lnbi8nICsgZXhwb3J0cy5lbmNvZGUobmFtZSkgKwogICAgICAgICAgICAnL19zcGF0aWFsLycgKyB2aWV3bmFtZQogICAgICAgICksCiAgICAgICAgZXhwZWN0X2pzb246IHRydWUsCiAgICAgICAgZGF0YTogZGF0YQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogVHJhbnNmb3JtcyBhbmQgZmV0Y2hlcyBhIHZpZXcgdGhyb3VnaCBhIGxpc3QgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcAogKiBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdAogKiBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQgZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQKICogKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5nZXRMaXN0KG5hbWUsIGxpc3QsIHZpZXcsIFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgZGVzaWduIGRvYyB0byB1c2UKICogQHBhcmFtIHtTdHJpbmd9IGxpc3QgLSBuYW1lIG9mIHRoZSBsaXN0IGZ1bmN0aW9uCiAqIEBwYXJhbSB7U3RyaW5nfSB2aWV3IC0gbmFtZSBvZiB0aGUgdmlldyB0byBhcHBseSB0aGUgbGlzdCBmdW5jdGlvbiB0bwogKiBAcGFyYW0ge09iamVjdH0gcSAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgovLyBUT0RPOiBydW4gbGlzdCBmdW5jdGlvbiBjbGllbnQtc2lkZT8KREIucHJvdG90eXBlLmdldExpc3QgPSBmdW5jdGlvbiAobmFtZSwgbGlzdCwgdmlldywgLypvcHRpb25hbCovcSwgY2FsbGJhY2spIHsKICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQogICAgdmFyIGxpc3RuYW1lID0gZXhwb3J0cy5lbmNvZGUobGlzdCk7CiAgICB2YXIgdmlld25hbWUgPSBleHBvcnRzLmVuY29kZSh2aWV3KTsKICAgIHRyeSB7CiAgICAgICAgdmFyIGRhdGEgPSBleHBvcnRzLnN0cmluZ2lmeVF1ZXJ5KHEpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICB9CiAgICB2YXIgcmVxID0gewogICAgICAgIHVybDogdGhpcy51cmwgKyAnL19kZXNpZ24vJyArIGV4cG9ydHMuZW5jb2RlKG5hbWUpICsKICAgICAgICAgICAgJy9fbGlzdC8nICsgbGlzdG5hbWUgKyAnLycgKyB2aWV3bmFtZSwKICAgICAgICBkYXRhOiBkYXRhCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKLyoqCiAqIFRyYW5zZm9ybXMgYW5kIGZldGNoZXMgYSBkb2N1bWVudCB0aHJvdWdoIGEgc2hvdyBmcm9tIHRoZSBkYXRhYmFzZSB0aGUgYXBwCiAqIGlzIHJ1bm5pbmcgb24uIFJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2ssIHdpdGggdGhlIGZpcnN0CiAqIGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjayByZXNlcnZlZCBmb3IgYW55IGV4Y2VwdGlvbnMgdGhhdCBvY2N1cnJlZAogKiAobm9kZS5qcyBzdHlsZSkuCiAqCiAqIEBuYW1lIERCLmdldFNob3cobmFtZSwgc2hvdywgZG9jaWQsIFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgZGVzaWduIGRvYyB0byB1c2UKICogQHBhcmFtIHtTdHJpbmd9IHNob3cgLSBuYW1lIG9mIHRoZSBzaG93IGZ1bmN0aW9uCiAqIEBwYXJhbSB7U3RyaW5nfSBkb2NpZCAtIGlkIG9mIHRoZSBkb2N1bWVudCB0byBhcHBseSB0aGUgc2hvdyBmdW5jdGlvbiB0bwogKiBAcGFyYW0ge09iamVjdH0gcSAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgovLyBUT0RPOiBydW4gc2hvdyBmdW5jdGlvbiBjbGllbnQtc2lkZT8KREIucHJvdG90eXBlLmdldFNob3cgPSBmdW5jdGlvbiAobmFtZSwgc2hvdywgZG9jaWQsIC8qb3B0aW9uYWwqL3EsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KICAgIHRyeSB7CiAgICAgICAgdmFyIGRhdGEgPSBleHBvcnRzLnN0cmluZ2lmeVF1ZXJ5KHEpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICB9CiAgICB2YXIgc2hvd25hbWUgPSBleHBvcnRzLmVuY29kZShzaG93KTsKICAgIHZhciBzaG93X3VybCA9IHRoaXMudXJsICsgJy9fZGVzaWduLycgKwogICAgICAgIGV4cG9ydHMuZW5jb2RlKG5hbWUpICsgJy9fc2hvdy8nICsgZXhwb3J0cy5lbmNvZGUoc2hvd25hbWUpOwogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6IHNob3dfdXJsICsgKGRvY2lkID8gJy8nICsgZXhwb3J0cy5lbmNvZGUoZG9jaWQpOiAnJyksCiAgICAgICAgZGF0YTogZGF0YQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogRmV0Y2ggYSBkZXNpZ24gZG9jdW1lbnQgZnJvbSBDb3VjaERCLgogKgogKiBAbmFtZSBEQi5nZXREZXNpZ25Eb2MobmFtZSwgY2FsbGJhY2spCiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIChpLmUuIHBhdGggdG8pIHRoZSBkZXNpZ24gZG9jdW1lbnQgd2l0aG91dCB0aGUKICogICAgIHByZWNlZWRpbmcgIlxfZGVzaWduLyIuCiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIHJlcXVlc3QgY29tcGxldGVzLgogKiBAYXBpIHB1YmxpYwogKi8KCkRCLnByb3RvdHlwZS5nZXREZXNpZ25Eb2MgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsKICAgIHRoaXMuZ2V0RG9jKCdfZGVzaWduLycgKyBuYW1lLCBmdW5jdGlvbiAoZXJyLCBkZG9jKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRkb2MpOwogICAgfSk7Cn07CgovKioKICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZGF0YWJhc2UuCiAqCiAqIEBuYW1lIERCLmluZm8oY2FsbGJhY2spCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChjYWxsYmFjaykgewogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6IHRoaXMudXJsLAogICAgICAgIGV4cGVjdF9qc29uOiB0cnVlLAogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogTGlzdGVuIHRvIHRoZSBjaGFuZ2VzIGZlZWQgZm9yIGEgZGF0YWJhc2UuCiAqCiAqIF9fT3B0aW9uczpfXwogKiAqIF9maWx0ZXJfIC0gdGhlIGZpbHRlciBmdW5jdGlvbiB0byB1c2UKICogKiBfc2luY2VfIC0gdGhlIHVwZGF0ZV9zZXEgdG8gc3RhcnQgbGlzdGVuaW5nIGZyb20KICogKiBfaGVhcnRiZWF0XyAtIHRoZSBoZWFydGJlYXQgdGltZSAoZGVmYXVsdHMgdG8gMTAgc2Vjb25kcykKICogKiBfaW5jbHVkZV9kb2NzXyAtIHdoZXRoZXIgdG8gaW5jbHVkZSBkb2NzIGluIHRoZSByZXN1bHRzCiAqCiAqIFJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBjYWxsYmFjayB3aWxsIGNhbmNlbCB0aGUgY2hhbmdlcyBsaXN0ZW5lcgogKgogKiBAbmFtZSBEQi5jaGFuZ2VzKFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7T2JqZWN0fSBxIChvcHRpb25hbCkgcXVlcnkgcGFyYW1ldGVycyAoc2VlIG9wdGlvbnMgYWJvdmUpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgovLyBUT0RPOiBjaGFuZ2UgdGhpcyB0byB1c2UgYW4gRXZlbnRFbWl0dGVyCkRCLnByb3RvdHlwZS5jaGFuZ2VzID0gZnVuY3Rpb24gKC8qb3B0aW9uYWwqL3EsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KCiAgICB2YXIgdGhhdCA9IHRoaXM7CgogICAgcSA9IHEgfHwge307CiAgICBxLmZlZWQgPSAnbG9uZ3BvbGwnOwogICAgcS5oZWFydGJlYXQgPSBxLmhlYXJ0YmVhdCB8fCAxMDAwMDsKCiAgICBmdW5jdGlvbiBnZXRDaGFuZ2VzKHNpbmNlKSB7CiAgICAgICAgcS5zaW5jZSA9IHNpbmNlOwogICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBkYXRhID0gZXhwb3J0cy5zdHJpbmdpZnlRdWVyeShxKTsKICAgICAgICB9CiAgICAgICAgY2F0Y2ggKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgICAgIH0KICAgICAgICB2YXIgcmVxID0gewogICAgICAgICAgICB0eXBlOiAnR0VUJywKICAgICAgICAgICAgZXhwZWN0X2pzb246IHRydWUsCiAgICAgICAgICAgIHVybDogdGhhdC51cmwgKyAnL19jaGFuZ2VzJywKICAgICAgICAgICAgZGF0YTogZGF0YQogICAgICAgIH07CiAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKGVyciwgZGF0YSkgewogICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgIGdldENoYW5nZXMoZGF0YS5sYXN0X3NlcSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2IpOwogICAgfQoKICAgIC8vIHVzZSBzZXRUaW1lb3V0IHRvIHBhc3MgY29udHJvbCBiYWNrIHRvIHRoZSBicm93c2VyIGJyaWVmbHkgdG8KICAgIC8vIGFsbG93IHRoZSBsb2FkaW5nIHNwaW5uZXIgdG8gc3RvcCBvbiBwYWdlIGxvYWQKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgIGlmIChxLmhhc093blByb3BlcnR5KCdzaW5jZScpKSB7CiAgICAgICAgICAgIGdldENoYW5nZXMocS5zaW5jZSk7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICB0aGF0LmluZm8oZnVuY3Rpb24gKGVyciwgaW5mbykgewogICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZ2V0Q2hhbmdlcyhpbmZvLnVwZGF0ZV9zZXEpOwogICAgICAgICAgICB9KTsKICAgICAgICB9CiAgICB9LCAwKTsKfTsKCgovKioKICogU2F2ZXMgYSBsaXN0IG9mIGRvY3VtZW50cywgd2l0aG91dCB1c2luZyBzZXBhcmF0ZSByZXF1ZXN0cy4KICogVGhpcyBmdW5jdGlvbiB1c2VzIENvdWNoREIncyBIVFRQIGJ1bGsgZG9jdW1lbnQgQVBJIChfYnVsa19kb2NzKS4KICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBhcnJheSBvZiBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgYW4gJ2lkJwogKiBhbmQgYSAncmV2JyBmaWVsZC4gVGhlIHJldHVybiB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHlvdQogKiBwcm92aWRlIHZpYSBpdHMgc2Vjb25kIGFyZ3VtZW50OyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrCiAqIGlzIHJlc2VydmVkIGZvciBhbnkgZXhjZXB0aW9ucyB0aGF0IG9jY3VycmVkIChub2RlLmpzIHN0eWxlKS4KICoKICogKipPcHRpb25zOioqCiAqICogKmFsbF9vclxfbm90aGluZyogLSBSZXF1aXJlIHRoYXQgYWxsIGRvY3VtZW50cyBiZSBzYXZlZAogKiAgIHN1Y2Nlc3NmdWxseSAob3Igc2F2ZWQgd2l0aCBhIGNvbmZsaWN0KTsgb3RoZXJ3aXNlIHJvbGwKICogICBiYWNrIHRoZSBvcGVyYXRpb24uCiAqCiAqIEBuYW1lIERCLmJ1bGtTYXZlKGRvY3MsIFtvcHRpb25zXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7QXJyYXl9IGRvY3MgQW4gYXJyYXkgb2YgZG9jdW1lbnRzOyBlYWNoIGRvY3VtZW50IGlzIGFuIG9iamVjdAogKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAob3B0aW9uYWwpIE9wdGlvbnMgZm9yIHRoZSBidWxrLXNhdmUgb3BlcmF0aW9uLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpIC0gQSBmdW5jdGlvbiB0byBhY2NlcHQgcmVzdWx0cwogKiAgICAgICAgICBhbmQvb3IgZXJyb3JzLiBEb2N1bWVudCB1cGRhdGUgY29uZmxpY3RzIGFyZSByZXBvcnRlZCBpbiB0aGUKICogICAgICAgICAgcmVzdWx0cyBhcnJheS4KICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuYnVsa1NhdmUgPSBmdW5jdGlvbiAoZG9jcywgLypvcHRpb25hbCovIG9wdGlvbnMsIGNhbGxiYWNrKSB7CiAgICBpZiAoIV8uaXNBcnJheShkb2NzKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgICAgICAgJ2J1bGtTYXZlIHJlcXVpcmVzIGFuIGFycmF5IG9mIGRvY3VtZW50cyB0byB3b3JrIHByb3Blcmx5JwogICAgICAgICk7CiAgICB9CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zOwogICAgICAgIG9wdGlvbnMgPSB7fTsKICAgIH0KICAgIG9wdGlvbnMuZG9jcyA9IGRvY3M7CiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdHlwZTogJ1BPU1QnLAogICAgICAgIHVybDogdGhpcy51cmwgKyAnL19idWxrX2RvY3MnLAogICAgICAgIGRhdGE6IGRhdGEsCiAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLAogICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsCiAgICAgICAgZXhwZWN0X2pzb246IHRydWUKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIFJlcXVlc3RzIGEgbGlzdCBvZiBkb2N1bWVudHMsIHVzaW5nIG9ubHkgYSBzaW5nbGUgSFRUUCByZXF1ZXN0LgogKiBUaGlzIGZ1bmN0aW9uIHVzZXMgQ291Y2hEQidzIEhUVFAgYnVsayBkb2N1bWVudCBBUEkgKF9hbGxfZG9jcykuCiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvZiB3aGljaCBpcyBhIGRvY3VtZW50LgogKiBUaGUgcmV0dXJuIHZhbHVlIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgeW91IHByb3ZpZGUgdmlhIGl0cyBzZWNvbmQKICogYXJndW1lbnQ7IHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgaXMgcmVzZXJ2ZWQgZm9yIGFueQogKiBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5idWxrR2V0KGtleXMsIFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgQW4gYXJyYXkgb2YgZG9jdW1lbnRzIGlkZW50aWZpZXJzIChpLmUuIHN0cmluZ3MpLgogKiBAcGFyYW0ge09iamVjdH0gcSAob3B0aW9uYWwpIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIHRoZSBidWxrLXJlYWQgb3BlcmF0aW9uLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpIC0gQSBmdW5jdGlvbiB0byBhY2NlcHQgcmVzdWx0cwogKiAgICAgICAgICBhbmQvb3IgZXJyb3JzLiBEb2N1bWVudCB1cGRhdGUgY29uZmxpY3RzIGFyZSByZXBvcnRlZCBpbiB0aGUKICogICAgICAgICAgcmVzdWx0cyBhcnJheS4KICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuYnVsa0dldCA9IGZ1bmN0aW9uIChrZXlzLCAvKm9wdGlvbmFsKi8gcSwgY2FsbGJhY2spIHsKICAgIGlmIChrZXlzICYmICFfLmlzQXJyYXkoa2V5cykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICdidWxrR2V0IHJlcXVpcmVzIHRoYXQgX2lkIHZhbHVlcyBiZSBzdXBwbGllZCBhcyBhIGxpc3QnCiAgICAgICAgKTsKICAgIH0KICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQoKICAgIC8qIEVuY29kZSBldmVyeSBxdWVyeS1zdHJpbmcgb3B0aW9uOgogICAgICAgIENvdWNoREIgcmVxdWlyZXMgdGhhdCB0aGVzZSBiZSBKU09OLCBldmVuIHRob3VnaCB0aGV5CiAgICAgICAgd2lsbCBiZSBVUkwtZW5jb2RlZCBhcyBwYXJ0IG9mIHRoZSByZXF1ZXN0IHByb2Nlc3MuICovCgogICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBrIGluIHEpIHsKICAgICAgICAgICAgcVtrXSA9IEpTT04uc3RyaW5naWZ5KHFba10pOwogICAgICAgIH0KICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQoKICAgIC8qIE1ha2UgcmVxdWVzdDoKICAgICAgICBJZiB3ZSBoYXZlIGEgbGlzdCBvZiBrZXlzLCB1c2UgYSBwb3N0IHJlcXVlc3QgY29udGFpbmluZwogICAgICAgIGEgSlNPTi1lbmNvZGVkIGxpc3Qgb2Yga2V5cy4gT3RoZXJ3aXNlLCB1c2UgYSBnZXQgcmVxdWVzdC4gKi8KCiAgICB2YXIgcmVxID0gewogICAgICAgIGV4cGVjdF9qc29uOiB0cnVlLAogICAgICAgIHVybDogdGhpcy51cmwgKyAnL19hbGxfZG9jcycgKyBleHBvcnRzLmVzY2FwZVVybFBhcmFtcyhxKQogICAgfTsKICAgIGlmIChrZXlzKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh7IGtleXM6IGtleXN9KTsKICAgICAgICB9CiAgICAgICAgY2F0Y2ggKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgICAgIH0KICAgICAgICByZXEgPSBfLmV4dGVuZChyZXEsIHsKICAgICAgICAgICAgdHlwZTogJ1BPU1QnLAogICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsCiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsCiAgICAgICAgICAgIGRhdGE6IGRhdGEKICAgICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgICAgcmVxID0gXy5leHRlbmQocmVxLCB7CiAgICAgICAgICAgIHR5cGU6ICdHRVQnCiAgICAgICAgfSk7CiAgICB9CgogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBEQiBtZXRob2RzIGNhbiBvbmx5IGJlIGNhbGxlZCBjbGllbnQtc2lkZQogKi8KCl8uZWFjaChfLmtleXMoREIucHJvdG90eXBlKSwgZnVuY3Rpb24gKGspIHsKICAgIHZhciBfZm4gPSBEQi5wcm90b3R5cGVba107CiAgICBEQi5wcm90b3R5cGVba10gPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoayArICcgY2Fubm90IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZScpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9Owp9KTsKCgp9KX07CgovKioqKioqKioqKiBzZXNzaW9uICoqKioqKioqKiovCgprYW5zby5tb2R1bGVDYWNoZVsic2Vzc2lvbiJdID0ge2xvYWQ6IChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCByZXF1aXJlKSB7CgovKioKICogIyMgU2Vzc2lvbiBtb2R1bGUKICoKICogVGhpcyBtb2R1bGUgY29udGFpbnMgZnVuY3Rpb25zIHJlbGF0ZWQgdG8gc2Vzc2lvbiBtYW5hZ2VtZW50LiBMb2dnaW5nIGluLAogKiBsb2dnaW5nIG91dCBhbmQgY2hlY2tpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSB1c2VyJ3Mgc2Vzc2lvbi4KICoKICogRnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGZvbGxvdyB0aGUgbm9kZS5qcyBjYWxsYmFjayBzdHlsZS4gVGhlIGZpcnN0CiAqIGFyZ3VtZW50IGlzIGFuIGVycm9yIG9iamVjdCAoaWYgb25lIG9jY3VycmVkKSwgdGhlIGZvbGxvd2luZyBhcmd1bWVudHMgYXJlCiAqIHRoZSByZXN1bHRzIG9mIHRoZSBvcGVyYXRpb24uIFRoZSBjYWxsYmFjayBpcyBhbHdheXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gYQogKiBmdW5jdGlvbi4KICoKICoKICogIyMjIEV2ZW50cwogKgogKiBUaGUgc2Vzc2lvbiBtb2R1bGUgaXMgYW4gRXZlbnRFbWl0dGVyLiBTZWUgdGhlCiAqIFtldmVudHMgcGFja2FnZV0oaHR0cDovL2thbi5zby9wYWNrYWdlcy9kZXRhaWxzL2V2ZW50cykgZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAqCiAqICMjIyMgY2hhbmdlCiAqCiAqIEVtaXR0ZWQgd2hlbmV2ZXIgYSBjaGFuZ2UgdG8gdGhlIHVzZXIncyBzZXNzaW9uIGlzIGRldGVjdGVkLCB0aGlzCiAqIGNhbiBvY2N1ciBhcyB0aGUgcmVzdWx0IG9mIGEgbG9naW4vbG9nb3V0IGNhbGwgb3IgYnkgZ2V0dGluZyB0aGUgdXNlcidzCiAqIHNlc3Npb24gaW5mbyAoYW5kIGl0J3MgY2hhbmdlZCkuCiAqCiAqIGBgYGphdmFzY3JpcHQKICogdmFyIHNlc3Npb24gPSByZXF1aXJlKCJzZXNzaW9uIik7CiAqCiAqIHNlc3Npb24ub24oJ2NoYW5nZScsIGZ1bmN0aW9uICh1c2VyQ3R4KSB7CiAqICAgICAvLyB1cGRhdGUgc2Vzc2lvbiBpbmZvcm1hdGlvbiwgZWcgIkxvZ2dlZCBpbiBhcyAuLi4iCiAqIH0pOwogKiBgYGAKICoKICogQG1vZHVsZQogKi8KCgp2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyksCiAgICBkYiA9IHJlcXVpcmUoJ2RiJyk7CgoKLyoqCiAqIFF1aWNrIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHRlc3RpbmcgaWYgcnVubmluZyBpbiB0aGUgYnJvd3Nlciwgc2luY2UKICogdGhlc2UgZnVuY3Rpb25zIHdvbid0IHJ1biBvbiBDb3VjaERCIHNlcnZlci1zaWRlCiAqLwoKZnVuY3Rpb24gaXNCcm93c2VyKCkgewogICAgcmV0dXJuICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpOwp9CgovKioKICogV2hlbiBhIGRiIGNhbGwgcmVzdWx0cyBpbiBhbiB1bmF1dGhvcml6ZWQgcmVzcG9uc2UsIHRoZSB1c2VyJ3Mgc2Vzc2lvbiBpcwogKiBjaGVja2VkIHRvIHNlZSBpZiB0aGVpciBzZXNzaW9uIGhhcyB0aW1lZCBvdXQgb3IgdGhleSd2ZSBsb2dnZWQgb3V0IGluCiAqIGFub3RoZXIgc2NyZWVuLgogKgogKiBUaGlzIGNoZWNrIGlzIHRocm90dGxlZCB0byBvbmNlIHBlciBzZWNvbmQsIHRvIGF2b2lkIGZsb29kaW5nIHRoZSBzZXJ2ZXIgaWYKICogbXVsdGlwbGUgcmVxdWVzdHMgYXJlIG1hZGUgd2l0aCBpbmNvcnJlY3QgcGVybWlzc2lvbnMuCiAqLwoKdmFyIGxhc3Rfc2Vzc2lvbl9jaGVjayA9IDA7CgpkYi5vbigndW5hdXRob3JpemVkJywgZnVuY3Rpb24gKHJlcSkgewogICAgLy8gZGIgY2FsbCByZXR1cm5lZCAnVW5hdXRob3JpemVkJywgY2hlY2sgdGhlIHVzZXIncyBzZXNzaW9uIGlmIGl0J3Mgbm90CiAgICAvLyBiZWVuIGNoZWNrZWQgb24gYW4gJ1VuYXV0aG9yaXplZCcgcmVwc29uc2UgaW4gdGhlIGxhc3Qgc2Vjb25kCiAgICBpZiAobGFzdF9zZXNzaW9uX2NoZWNrIDwgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSAxMDAwKSB7CiAgICAgICAgZXhwb3J0cy5pbmZvKCk7CiAgICB9Cn0pOwoKCi8qKgogKiBUaGlzIG1vZHVsZSBpcyBhbiBFdmVudEVtaXR0ZXIsIHVzZWQgZm9yIGhhbmRsaW5nICdjaGFuZ2UnIGV2ZW50cwogKi8KCnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpOwoKCi8qKgogKiBBdHRlbXB0IHRvIGxvZ2luIHVzaW5nIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgcHJvdmlkZWQuCiAqCiAqIEBuYW1lIGxvZ2luKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSAtIHRoZSB1c2VybmFtZSB0byBsb2dpbiB3aXRoCiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIHRoZSB1c2VyJ3MgcGFzc3dvcmQgKHVuaGFzaGVkKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGxvZ2luCiAqICAgICBhdHRlbXB0CiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogc2Vzc2lvbi5sb2dpbigndGVzdHVzZXInLCAncGFzc3dvcmQnLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkgewogKiAgICAgaWYgKGVycikgLy8gYW4gZXJyb3Igb2NjdXJyZWQgbG9nZ2luZyBpbgogKiAgICAgZWxzZSAgICAgLy8gc3VjY2VzcwogKiB9KTsKICogYGBgCiAqLwoKZXhwb3J0cy5sb2dpbiA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWlzQnJvd3NlcigpKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2dpbiBjYW5ub3QgYmUgY2FsbGVkIHNlcnZlci1zaWRlJyk7CiAgICB9CiAgICBkYi5yZXF1ZXN0KHsKICAgICAgICB0eXBlOiAiUE9TVCIsCiAgICAgICAgdXJsOiAiL19zZXNzaW9uIiwKICAgICAgICBkYXRhOiB7bmFtZTogdXNlcm5hbWUsIHBhc3N3b3JkOiBwYXNzd29yZH0KICAgIH0sCiAgICBmdW5jdGlvbiAoZXJyLCByZXNwKSB7CiAgICAgICAgaWYgKHJlc3AgJiYgcmVzcC5vaykgewogICAgICAgICAgICAvLyBUT0RPOiBmb3Igc29tZSByZWFzb24gcmVzcC5uYW1lIGlzIHNldCB0byBudWxsIGluIHRoZSByZXNwb25zZQogICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGUgcm9sZXMgYXJlIGNvcnJlY3QgZm9yIHRoZSB1c2VyISBMb29rIGludG8gdGhpcwogICAgICAgICAgICAvLyBhbmQgc2VlIGlmIGl0cyBhIGJ1ZyBpbiBjb3VjaGRiLCBmb3Igbm93LCBqdXN0IHVzaW5nIHRoZSB1c2VybmFtZQogICAgICAgICAgICAvLyBnaXZlbiB0byB0aGUgbG9naW4gZnVuY3Rpb24gaW5zdGVhZCwgc2luY2Ugd2Uga25vdyB0aGUgbG9naW4KICAgICAgICAgICAgLy8gcmVxdWVzdCB3YXMgYWNjZXB0ZWQuCiAgICAgICAgICAgIGV4cG9ydHMudXNlckN0eCA9IHtuYW1lOiB1c2VybmFtZSwgcm9sZXM6IHJlc3Aucm9sZXN9OwogICAgICAgICAgICBleHBvcnRzLnNlc3Npb24gPSB7dXNlckN0eDogZXhwb3J0cy51c2VyQ3R4fTsKICAgICAgICAgICAgZXhwb3J0cy5lbWl0KCdjaGFuZ2UnLCBleHBvcnRzLnVzZXJDdHgpOwogICAgICAgIH0KICAgICAgICBpZiAoY2FsbGJhY2spIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTsKICAgICAgICB9CiAgICB9KTsKfTsKCgovKioKICogTG9ncyBvdXQgdGhlIGN1cnJlbnQgdXNlci4KICoKICogQG5hbWUgbG9nb3V0KGNhbGxiYWNrKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGxvZ291dAogKiAgICAgYXR0ZW1wdAogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHNlc3Npb24ubG9nb3V0KGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKSB7CiAqICAgICBpZiAoZXJyKSAvLyBhbiBlcnJvciBvY2N1cnJlZCBsb2dnaW5nIG91dAogKiAgICAgZWxzZSAgICAgLy8gc3VjY2VzcwogKiB9KTsKICogYGBgCiAqLwoKZXhwb3J0cy5sb2dvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsKICAgIGlmICghaXNCcm93c2VyKCkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvZ291dCBjYW5ub3QgYmUgY2FsbGVkIHNlcnZlci1zaWRlJyk7CiAgICB9CiAgICBkYi5yZXF1ZXN0KHsKICAgICAgICB0eXBlOiAiREVMRVRFIiwKICAgICAgICB1cmw6ICIvX3Nlc3Npb24iLCAvLyBkb24ndCBuZWVkIGJhc2VVUkwsIC9fc2Vzc2lvbiBhbHdheXMgYXZhaWxhYmxlCiAgICAgICAgdXNlcm5hbWU6ICJfIiwKICAgICAgICBwYXNzd29yZCA6ICJfIgogICAgfSwKICAgIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHsKICAgICAgICBpZiAocmVzcCAmJiByZXNwLm9rKSB7CiAgICAgICAgICAgIGV4cG9ydHMudXNlckN0eCA9IHtuYW1lOiBudWxsLCByb2xlczogW119OwogICAgICAgICAgICBleHBvcnRzLnNlc3Npb24gPSB7dXNlckN0eDogZXhwb3J0cy51c2VyQ3R4fTsKICAgICAgICAgICAgZXhwb3J0cy5lbWl0KCdjaGFuZ2UnLCBleHBvcnRzLnVzZXJDdHgpOwogICAgICAgIH0KICAgICAgICBpZiAoY2FsbGJhY2spIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTsKICAgICAgICB9CiAgICB9KTsKfTsKCgovKioKICogUmV0dXJucyB0aGUgY3VycmVudCB1c2VyJ3Mgc2Vzc2lvbiBpbmZvcm1hdGlvbi4gVGhlIGluZm8gb2JqZWN0IGNvbnRhaW5zIGEKICogYHVzZXJDdHhgIHByb3BlcnR5IGFuZCBhbiBgaW5mb2AgcHJvcGVydHkuIFRoZSBmaXJzdCBjb250YWlucyB0aGUgbmFtZSBhbmQKICogcm9sZXMgb2YgdGhlIGN1cnJlbnQgdXNlciwgdGhlIHNlY29uZCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlcgogKiBkYXRhYmFzZSBhbmQgYXV0aGVudGljYXRpb24gaGFuZGxlcnMuCiAqCiAqIEBuYW1lIGluZm8oY2FsbGJhY2spCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIHNlc3Npb24gaW5mb3JtYXRpb24KICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiBzZXNzaW9uLmluZm8oZnVuY3Rpb24gKGVyciwgaW5mbykgewogKiAgICAgaWYgKGVycikgLy8gYW4gZXJyb3Igb2NjdXJyZWQgZ2V0dGluZyBzZXNzaW9uIGluZm8KICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3MKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMuaW5mbyA9IGZ1bmN0aW9uIChjYWxsYmFjaykgewogICAgaWYgKCFpc0Jyb3dzZXIoKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignaW5mbyBjYW5ub3QgYmUgY2FsbGVkIHNlcnZlci1zaWRlJyk7CiAgICB9CiAgICBkYi5yZXF1ZXN0KHsKICAgICAgICB0eXBlOiAiR0VUIiwKICAgICAgICB1cmw6ICIvX3Nlc3Npb24iCiAgICB9LAogICAgZnVuY3Rpb24gKGVyciwgcmVzcCkgewogICAgICAgIHZhciBvbGRVc2VyQ3R4ID0gZXhwb3J0cy51c2VyQ3R4OwogICAgICAgIGV4cG9ydHMuc2Vzc2lvbiA9IHJlc3A7CiAgICAgICAgZXhwb3J0cy51c2VyQ3R4ID0gKHJlc3AgJiYgcmVzcC51c2VyQ3R4KSB8fCB7bmFtZTogbnVsbCwgcm9sZXM6IFtdfTsKICAgICAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBjaGVjayBmb3IgZGlmZmVyZW5jZXMgaW4gbW9yZSB0aGFuIGp1c3QgbmFtZT8KICAgICAgICBpZiAoIW9sZFVzZXJDdHggfHwgb2xkVXNlckN0eC5uYW1lICE9PSBleHBvcnRzLnVzZXJDdHgubmFtZSkgewogICAgICAgICAgICBleHBvcnRzLmVtaXQoJ2NoYW5nZScsIGV4cG9ydHMudXNlckN0eCk7CiAgICAgICAgfQogICAgICAgIGlmIChjYWxsYmFjaykgewogICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3ApOwogICAgICAgIH0KICAgIH0pOwp9OwoKCn0pfTsKCi8qKioqKioqKioqIGV2ZW50cyAqKioqKioqKioqLwoKa2Fuc28ubW9kdWxlQ2FjaGVbImV2ZW50cyJdID0ge2xvYWQ6IChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCByZXF1aXJlKSB7CgovKioKICogIyMgRXZlbnRzIG1vZHVsZQogKgogKiBUaGlzIGlzIGEgYnJvd3NlciBwb3J0IG9mIHRoZSBub2RlLmpzIGV2ZW50cyBtb2R1bGUuIE1hbnkgb2JqZWN0cyBhbmQKICogbW9kdWxlcyBlbWl0IGV2ZW50cyBhbmQgdGhlc2UgYXJlIGluc3RhbmNlcyBvZiBldmVudHMuRXZlbnRFbWl0dGVyLgogKgogKiBZb3UgY2FuIGFjY2VzcyB0aGlzIG1vZHVsZSBieSBkb2luZzogYHJlcXVpcmUoImV2ZW50cyIpYAogKgogKiBGdW5jdGlvbnMgY2FuIHRoZW4gYmUgYXR0YWNoZWQgdG8gb2JqZWN0cywgdG8gYmUgZXhlY3V0ZWQgd2hlbiBhbiBldmVudCBpcwogKiBlbWl0dGVkLiBUaGVzZSBmdW5jdGlvbnMgYXJlIGNhbGxlZCBsaXN0ZW5lcnMuCiAqCiAqIEBtb2R1bGUKICovCgoKLyoqCiAqIFRvIGFjY2VzcyB0aGUgRXZlbnRFbWl0dGVyIGNsYXNzLCByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIuCiAqCiAqIFdoZW4gYW4gRXZlbnRFbWl0dGVyIGluc3RhbmNlIGV4cGVyaWVuY2VzIGFuIGVycm9yLCB0aGUgdHlwaWNhbCBhY3Rpb24gaXMgdG8KICogZW1pdCBhbiAnZXJyb3InIGV2ZW50LiBFcnJvciBldmVudHMgYXJlIHRyZWF0ZWQgYXMgYSBzcGVjaWFsIGNhc2UuIElmIHRoZXJlCiAqIGlzIG5vIGxpc3RlbmVyIGZvciBpdCwgdGhlbiB0aGUgZGVmYXVsdCBhY3Rpb24gaXMgZm9yIHRoZSBlcnJvciB0byB0aHJvdy4KICoKICogQWxsIEV2ZW50RW1pdHRlcnMgZW1pdCB0aGUgZXZlbnQgJ25ld0xpc3RlbmVyJyB3aGVuIG5ldyBsaXN0ZW5lcnMgYXJlIGFkZGVkLgogKgogKiBAbmFtZSBldmVudHMuRXZlbnRFbWl0dGVyCiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogdmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjsKICoKICogLy8gY3JlYXRlIGFuIGV2ZW50IGVtaXR0ZXIKICogdmFyIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7CiAqIGBgYAogKi8KCnZhciBFdmVudEVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9OwoKdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHsKICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7Cn07CgoKLyoqCiAqIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZQogKiBhZGRlZCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZwogKiBtZW1vcnkgbGVha3MuIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzCiAqIGZ1bmN0aW9uIGFsbG93cyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC4KICoKICogQG5hbWUgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMobikKICogQHBhcmFtIHtOdW1iZXJ9IG4gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbGlzdGVuZXJzCiAqIEBhcGkgcHVibGljCiAqLwoKLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbgovLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2gKLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuCi8vCi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93cwovLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC4KdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDsKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7CiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9OwogIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuOwp9OwoKCi8qKgogKiBFeGVjdXRlIGVhY2ggb2YgdGhlIGxpc3RlbmVycyBpbiBvcmRlciB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuCiAqCiAqIEBuYW1lIGVtaXR0ZXIuZW1pdChldmVudCwgW2FyZzFdLCBbYXJnMl0sIFsuLi5dKQogKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS9pZCB0byBmaXJlCiAqIEBhcGkgcHVibGljCiAqLwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkgewogIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy4KICBpZiAodHlwZSA9PT0gJ2Vycm9yJykgewogICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50cy5lcnJvciB8fAogICAgICAgIChpc0FycmF5KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKQogICAgewogICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC4iKTsKICAgICAgfQogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgfQoKICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlOwogIHZhciBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdOwogIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlOwoKICBpZiAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykgewogICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7CiAgICAgIC8vIGZhc3QgY2FzZXMKICAgICAgY2FzZSAxOgogICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAyOgogICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDM6CiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgLy8gc2xvd2VyCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7CiAgICB9CiAgICByZXR1cm4gdHJ1ZTsKCiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7CiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CgogICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTsKICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7CiAgICB9CiAgICByZXR1cm4gdHJ1ZTsKCiAgfSBlbHNlIHsKICAgIHJldHVybiBmYWxzZTsKICB9Cn07CgoKLyoqCiAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuCiAqCiAqIEBuYW1lIGVtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyKSB8IGVtaXR0ZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKQogKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS9pZCB0byBsaXN0ZW4gZm9yCiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdG8gdGhlIGV2ZW50CiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogc2Vzc2lvbi5vbignY2hhbmdlJywgZnVuY3Rpb24gKHVzZXJDdHgpIHsKICogICAgIGNvbnNvbGUubG9nKCdzZXNzaW9uIGNoYW5nZWQhJyk7CiAqIH0pOwogKiBgYGAKICovCgovLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2MKLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHsKICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7CiAgfQoKICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307CgogIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gIm5ld0xpc3RlbmVycyIhIEJlZm9yZQogIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0ICJuZXdMaXN0ZW5lcnMiLgogIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7CgogIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7CiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC4KICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyOwogIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7CgogICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWsKICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkgewogICAgICB2YXIgbTsKICAgICAgaWYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkgewogICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzOwogICAgICB9IGVsc2UgewogICAgICAgIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzOwogICAgICB9CgogICAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkgewogICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlOwogICAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgKwogICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArCiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJywKICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpOwogICAgICAgIGNvbnNvbGUudHJhY2UoKTsKICAgICAgfQogICAgfQoKICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC4KICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTsKICB9IGVsc2UgewogICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07CiAgfQoKICByZXR1cm4gdGhpczsKfTsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyOwoKLyoqCiAqIEFkZHMgYSBvbmUgdGltZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50LiBUaGlzIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGUKICogbmV4dCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC4KICoKICogQG5hbWUgZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lcikKICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LSBUaGUgZXZlbnQgbmFtZS9pZCB0byBsaXN0ZW4gZm9yCiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdG8gdGhlIGV2ZW50CiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogZGIub25jZSgndW5hdXRob3JpemVkJywgZnVuY3Rpb24gKHJlcSkgewogKiAgICAgLy8gdGhpcyBldmVudCBsaXN0ZW5lciB3aWxsIGZpcmUgb25jZSwgdGhlbiBiZSB1bmJvdW5kCiAqIH0pOwogKiBgYGAKICovCgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikgewogIHZhciBzZWxmID0gdGhpczsKICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7CiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpOwogICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICB9KTsKCiAgcmV0dXJuIHRoaXM7Cn07CgovKioKICogUmVtb3ZlIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuIENhdXRpb246CiAqIGNoYW5nZXMgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci4KICoKICogQG5hbWUgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpCiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBldmVudCBuYW1lL2lkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUKICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5pdCkgewogKiAgICAgY29uc29sZS5sb2coJ2R1YWxpdHkgYXBwIGxvYWRlZCcpOwogKiB9OwogKiBkZXZlbnRzLm9uKCdpbml0JywgY2FsbGJhY2spOwogKiAvLyAuLi4KICogZGV2ZW50cy5yZW1vdmVMaXN0ZW5lcignaW5pdCcsIGNhbGxiYWNrKTsKICogYGBgCiAqLwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7CiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikgewogICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpOwogIH0KCiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdCiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7CgogIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdOwoKICBpZiAoaXNBcnJheShsaXN0KSkgewogICAgdmFyIGkgPSBsaXN0LmluZGV4T2YobGlzdGVuZXIpOwogICAgaWYgKGkgPCAwKSByZXR1cm4gdGhpczsKICAgIGxpc3Quc3BsaWNlKGksIDEpOwogICAgaWYgKGxpc3QubGVuZ3RoID09IDApCiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07CiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7CiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwogIH0KCiAgcmV0dXJuIHRoaXM7Cn07CgovKioKICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LgogKgogKiBAbmFtZSBlbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhbZXZlbnRdKQogKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBFdmVudCBuYW1lL2lkIHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciAob3B0aW9uYWwpCiAqIEBhcGkgcHVibGljCiAqLwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7CiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdCiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDsKICByZXR1cm4gdGhpczsKfTsKCi8qKgogKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudC4gVGhpcyBhcnJheSBjYW4gYmUKICogbWFuaXB1bGF0ZWQsIGUuZy4gdG8gcmVtb3ZlIGxpc3RlbmVycy4KICoKICogQG5hbWUgZW1pdHRlci5saXN0ZW5lcnMoZXZlbnQpCiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHMgLSBUaGUgZXZlbnQgbmFtZS9pZCB0byByZXR1cm4gbGlzdGVuZXJzIGZvcgogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHNlc3Npb24ub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChzdHJlYW0pIHsKICogICAgIGNvbnNvbGUubG9nKCdzZXNzaW9uIGNoYW5nZWQnKTsKICogfSk7CiAqIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdChzZXNzaW9uLmxpc3RlbmVycygnY2hhbmdlJykpKTsgLy8gWyBbRnVuY3Rpb25dIF0KICogYGBgCiAqLwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7CiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9OwogIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTsKICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkgewogICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07CiAgfQogIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07Cn07CgoKLyoqCiAqIEBuYW1lIGVtaXR0ZXIgRXZlbnQ6ICduZXdMaXN0ZW5lcicKICoKICogVGhpcyBldmVudCBpcyBlbWl0dGVkIGFueSB0aW1lIHNvbWVvbmUgYWRkcyBhIG5ldyBsaXN0ZW5lci4KICoKICogYGBgamF2YXNjcmlwdAogKiBlbWl0dGVyLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHsKICogICAgIC8vIG5ldyBsaXN0ZW5lciBhZGRlZAogKiB9KTsKICogYGBgCiAqLwoKCn0pfTsKCg=="
        }
    },
    "lib": {
        "app": "",
        "manage-tokens": "\nvar session = require(\"session\"),\n    users = require(\"users\"),\n    _ = require(\"underscore\")._;\n\nfunction getOAuth(email, doc, regenerate) {\n    if (regenerate || !(doc.oauth \n        && doc.oauth.consumer_keys \n        && doc.oauth.consumer_keys[email]\n        && doc.oauth.tokens\n        && doc.oauth.tokens.node_sign_token)) {\n\n        doc.oauth = doc.oauth || {};\n        doc.oauth.consumer_keys = doc.oauth.consumer_keys || {};\n        doc.oauth.tokens = doc.oauth.tokens || {};\n\n        doc.oauth.consumer_keys[email] = exports.generateSecret(32);\n        doc.oauth.tokens.node_sign_token = exports.generateSecret(32);\n\n        if (!doc.roles || _.indexOf(doc.roles, \"node_sign\") == -1) {\n            doc.roles = doc.roles || [];\n            // doc.roles.push(\"node_sign\");\n        }\n\n        users.update(email, null, doc, function(err) {\n            if (err) {\n                console.log(err);\n            } else {\n                getUserInfo(email);\n            }\n        });\n\n    } else {\n        $(\".oauth\").show(500);\n        $(\"#consumer_key\").val(email)\n        $(\"#consumer_secret\").val(doc.oauth.consumer_keys[email]);\n        $(\"#token_secret\").val(doc.oauth.tokens.node_sign_token);\n    }\n}\n\nfunction getSigningInfo(email, doc) {\n    if (doc.lrsignature && doc.lrsignature.full_name) {\n        $(\"#full_name\").val(doc.lrsignature.full_name);\n    }\n}\n\nfunction setMessage(msg, wait, cb) {\n    if (!wait) {\n        wait = 10000;\n    }\n\n    $(\".msg\").fadeOut('fast').empty().text(msg).fadeIn('fast').delay(wait).fadeOut('slow').hide('fast');\n\n    if (cb) {\n        cb();\n    }\n}\n\nfunction setSigningInfo() {\n    full_name = $(\"#full_name\").val();\n    if ($.trim(full_name) !== \"\") {\n        session.info(function(err, session_info){\n            if (session_info.userCtx.name) {\n                users.get(session_info.userCtx.name, function(err, doc){\n                    doc.lrsignature = doc.lrsignature || {}\n                    doc.lrsignature.full_name = full_name;\n\n                    users.update(session_info.userCtx.name, null, doc, function(err) {\n                        if (err) {\n                            console.log(err);\n                            setMessage(\"Unable to save signing information.\");\n                        } else {\n                            setMessage(\"Information saved.\")\n                        }\n                    });\n                }); \n            };\n        });\n    }\n}\n\nfunction setPasswordInfo(email, doc) {\n    if (doc.password_sha) {\n        $(\"#password_set\").prop(\"checked\", true);\n    } else {\n        $(\"#password_set\").prop(\"checked\", false);\n    }\n}\n\nfunction getUserInfo(email) {\n    users.get(email, function(err, doc) {\n        if (!err) {\n            getOAuth(email, doc);\n            getSigningInfo(email, doc);\n            setPasswordInfo(email, doc);\n        }\n        else {\n            setMessage(err);\n        }\n    });\n}\n\nfunction revokeAndGenerate() {\n    session.info(function(err, session_info){\n        if (session_info.userCtx.name) {\n            users.get(session_info.userCtx.name, function (err, doc){\n                if (!err) {\n                   getOAuth(session_info.userCtx.name, doc, true); \n                }\n            });\n        } else {\n            sessionTimeout();\n        }\n    });\n}\n\nfunction sessionTimeout () {\n    setMessage(\"Session has timed out.\", 50000, function(){\n        window.location.reload();\n    });\n}\n\nfunction checkPasswordMatch() {\n    var passwd1 = $(\"#password\").val();\n    var passwd2 = $(\"#verify_password\").val();\n    if (passwd1 === \"\" || passwd2 === \"\" || passwd1 !== passwd2)\n        return false;\n    return true;\n}\n\nfunction savePassword() {\n    var passwd1 = $(\"#password\").val();\n    var passwd2 = $(\"#verify_password\").val();\n    if ( checkPasswordMatch() ) {\n        session.info(function(err, session_info) {\n            if (session_info.userCtx.name) {\n                users.get(session_info.userCtx.name, function(err, doc){\n                    doc.password = passwd1;\n\n                    users.update(session_info.userCtx.name, null, doc, function(err) {\n                        if (err) {\n                            console.log(err);\n                            setMessage(\"Unable to save publish password.\");\n                        } else {\n                            setMessage(\"Password saved.\");\n                            $(\"#password\").val(\"\");\n                            $(\"#verify_password\").val(\"\");\n                            $(\"#password_set\").prop(\"checked\", true);\n                        }\n                    });\n                }); \n            };\n        });\n    } else {\n        setMessage(\"Passwords do no match.\");\n    }\n}\n\n\nexports.registerCallbacks = function() {\n    $.couch.browserid.login(function(evt, err, info) { \n        try {\n            if (info && info.email) {\n                console.log(info.email);\n                getUserInfo(info.email);\n            }\n        } catch (error) {\n\n        } finally {\n\n        } \n    });\n\n    $.couch.browserid.logout(function(evt, err, info){\n        window.location.reload();\n    });\n\n    $(\"#info_update\").bind('click', setSigningInfo);\n    $(\"#regenerate\").bind('click', revokeAndGenerate);\n    $(\"#save_password\").bind('click', savePassword);\n}\n\n\n// Simple secret key generator\nexports.generateSecret = function(length) {\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var secret = '';\n    for (var i = 0; i < length; i++) {\n        secret += tab.charAt(Math.floor(Math.random() * 64));\n    }\n    return secret;\n}\n\n"
    },
    "users": "/**\n * ## Users module\n *\n * Functions for querying, creating, updating and deleting user documents.\n *\n * Functions in this module follow the node.js callback style. The first\n * argument is an error object (if one occurred), the following arguments are\n * the results of the operation. The callback is always the last argument to a\n * function.\n *\n * @module\n */\n\n\nvar db = require('db'),\n    session = require('session'),\n    sha1 = require('sha1'),\n    _ = require('underscore')._;\n\n\n/**\n * Returns the authentication database for the current user's session.\n *\n * @name authdb(callback)\n * @param {Function} callback\n * @api private\n */\n\nvar authdb = function(callback) {\n    db.request({\n        type: \"GET\",\n        url: \"/_session\"\n    },\n    function (err, resp) {\n        if (err) {\n            return callback(err, null);\n        }\n        callback(null, resp.info.authentication_db);\n    });\n};\n\n\n/**\n * Returns successful if username is in admin database.\n *\n * @name getAdmin(username, callback)\n * @param {String} username\n * @param {Function} callback\n * @api private\n */\n\nvar getAdmin = function(username, callback) {\n    db.request({\n        type: 'GET',\n        url: '/_config/admins/' + encodeURIComponent(username),\n        contentType: 'application/json'\n    }, callback);\n};\n\n\n/**\n * Delete user from user database.\n *\n * @name deleteUser(authdb, id, user, callback)\n * @param {String} user database\n * @param {String} user id\n * @param {Object} user document\n * @param {Function} callback\n * @api private\n */\n\nvar deleteUser = function(authdb, id, user, callback) {\n    db.request({\n        type: 'DELETE',\n        url: '/' + db.encode(authdb) + '/' + db.encode(id) +\n             '?rev=' + db.encode(user._rev),\n        contentType: 'application/json'\n    }, callback);\n};\n\n/**\n * Delete user from admin database.\n *\n * @name deleteAdmin(username, callback)\n * @param {String} username\n * @param {Function} callback\n * @api private\n */\n\nvar deleteAdmin = function(username, callback) {\n    db.request({\n        type: 'DELETE',\n        url: '/_config/admins/' + encodeURIComponent(username),\n        contentType: 'application/json'\n    }, callback);\n};\n\n\n/**\n * Save user to user database.\n *\n * @name saveUser(authdb, doc, callback)\n * @param {String} user database\n * @param {Object} user document\n * @param {Function} callback\n * @api private\n */\n\nvar saveUser = function(authdb, doc, callback) {\n    var url = '/' + authdb + '/' + doc._id;\n    var req = {\n        type: 'PUT',\n        url: url,\n        data: JSON.stringify(doc),\n        processData: false,\n        contentType: 'application/json'\n    };\n    db.request(req, callback);\n};\n\n\n/**\n * Create a new user in the user database.\n *\n * @name createUser(username, password, properties, callback)\n * @param {String} username\n * @param {String} password\n * @param {Hash} properties\n * @param {Function} callback\n * @api private\n */\n\nvar createUser = function(username, password, properties, callback) {\n    var doc = {};\n    doc._id = 'org.couchdb.user:' + username;\n    doc.name = username;\n    doc.type = 'user';\n\n    _.extend(doc, properties);\n\n    db.newUUID(100, function (err, uuid) {\n        if (err) {\n            return callback(err);\n        }\n        doc.salt = uuid;\n        doc.password_sha = sha1.hex(password + doc.salt);\n\n        authdb(function (err, authdb) {\n            if (err) { return callback(err); }\n            saveUser(authdb, doc, callback);\n        });\n    });\n};\n\n\n/**\n * Create a new user in the admin database.\n *\n * @name createAdmin(username, password, callback)\n * @param {String} username\n * @param {String} password\n * @param {Function} callback\n * @api private\n */\n\nvar createAdmin = function(username, password, callback) {\n    var url = '/_config/admins/' + encodeURIComponent(username);\n    var req = {\n        type: 'PUT',\n        url: url,\n        data: JSON.stringify(password),\n        processData: false,\n        contentType: 'application/json'\n    };\n    db.request(req, callback);\n};\n\n\n/**\n * Sanitize the arguments by allowing to omit the properties and\n * predefining the roles if they're not set.\n *\n * @name sanitizeArguments(username, password, properties, cb, cb2)\n * @param {String} username\n * @param {String} password\n * @param {Hash} properties\n * @param {Function} cb\n * @param {Function} cb2\n * @api private\n */\n\nvar sanitizeArguments = function(username, password, properties, cb, cb2) {\n    if (!cb) {\n        cb = properties;\n        properties = {};\n    }\n    if (!properties.roles) {\n        properties.roles = [];\n    }\n    cb2(username, password, properties, cb);\n};\n\n\n/**\n * Deletes an existing user document, given its username. You\n * must be logged in as an administrative user for this function\n * to succeed.\n *\n * @name delete(username, callback)\n * @param {String} username - The username of the user to delete\n * @param {Function} callback(err,response) - Function called on completion of\n *     the operation\n * @api public\n *\n * ```javascript\n * users.delete('username', function (err) {\n *     if (err) // there was an error deleting the user\n *     else     // success\n * });\n * ```\n */\n\nexports.delete = function (username, callback) {\n    exports.get(username, function(err, user, options) {\n        if (err) { return callback(err); }\n\n        getAdmin(username, function(err, admin) {\n            if (err) {\n                if (err.status !== 404) {\n                    return callback(err);\n                }\n                deleteUser(options.authdb, options.id, user, callback);\n            }\n            else {\n                deleteAdmin(username, function(err) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    deleteUser(options.authdb, options.id, user, callback);\n                });\n            }\n        });\n    });\n};\n\n\n/**\n * Get a single user by username. The third argument to the callback is an info\n * object which returns the authdb used, and the real id of the user with\n * \"org.couchdb.user:\" prefix.\n *\n * @name get(username, callback)\n * @param {String} username - The username of the user to get\n * @param {Function} callback(err,user,info) - Function called on completion\n * @api public\n *\n * ```javascript\n * users.get('testuser', function (err, doc) {\n *     if (err) // there was an error fetching the user document\n *     else     // success\n * });\n * ```\n */\n\nexports.get = function(username, callback) {\n    var id = 'org.couchdb.user:' + username;\n\n    authdb(function (err, authdb) {\n        if (err) {\n            return callback(err);\n        }\n        db.request({\n            type: 'GET',\n            url: '/' + db.encode(authdb) + '/' + db.encode(id),\n            contentType: 'application/json'\n        },\n        function (err, user) {\n            callback(err, user, {authdb: authdb, id: id});\n        });\n    });\n};\n\n\n/**\n * List users in the auth database. By default, it will list all users.\n * By using the optional `q` parameter, you can pass additional options to the\n * `_all_docs` view for the auth database.\n *\n * @name list([q], callback)\n * @param {Object} q - Query parameters (optional)\n * @param {Function} callback(err,list) - Function called with the resulting\n *     list (or error)\n * @api public\n *\n * ```javascript\n * users.list(function (err, list) {\n *     if (err) // there was an error querying the auth database\n *     else     // success\n * });\n * ```\n */\n\nexports.list = function(q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    if (!q.startkey) {\n        q.startkey = '\"org.couchdb.user:\"';\n    }\n    if (!q.endkey) {\n        q.endkey = '\"org.couchdb.user_\"';\n    }\n    authdb(function (err, authdb) {\n        if (err) {\n            callback(err, null);\n        }\n        var req = {\n            type: 'GET',\n            url: '/' + db.encode(authdb) + '/_all_docs',\n            data: db.stringifyQuery(q),\n            expect_json: true\n        };\n        db.request(req, function(err, result) {\n            if (err) {\n                return callback(err, null);\n            }\n            var users = _(result.rows).select(function(row) {\n                return row.id.match(/^org\\.couchdb\\.user/);\n            });\n            callback(null, users);\n        });\n    });\n};\n\n\n/**\n * Creates a new user document with given username and password.\n * If properties.roles contains '_admin', user will be made admin.\n *\n * @name create(username, password, [properties], callback)\n * @param {String} username - The username of the new user\n * @param {String} password - The unhashed password for the new user\n * @param {Object} properties - Additional properties such as roles to extend\n *     the user document with (optional)\n * @param {Function} callback(err,response) - Function called on completion or\n *     error\n * @api public\n *\n * ```javascript\n * users.create('testuser', 'testing', {roles: ['example']}, function (err) {\n *     if (err) // an error occurred\n *     else     // successfully created new user\n * });\n * ```\n */\n\nexports.create = function (username, password, properties, callback) {\n    sanitizeArguments(username, password, properties, callback,\n        function(username, password, properties, callback) {\n            if (_.indexOf(properties.roles, \"_admin\") !== -1) {\n                createAdmin(username, password, function (err) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    properties.roles = [];\n                    createUser(username, password, properties, callback);\n                });\n            }\n            else {\n                createUser(username, password, properties, callback);\n            }\n    });\n};\n\n\n/**\n * Updates an existing user document. Similar usage to the create function.\n *\n * @name update(username, password, properties, callback)\n * @param {String} username - The username of the new user\n * @param {String} password - The unhashed password for the new user\n * @param {Object} properties - Additional properties such as roles to extend\n *     the user document with (optional)\n * @param {Function} callback(err,response) - Function called on completion or\n *     error\n * @api public\n *\n * ```javascript\n * users.update('testuser', 'testing', {roles: ['example']}, function (err) {\n *     if (err) // an error occurred\n *     else     // successfully updated user\n * });\n * ```\n */\n\nexports.update = function (username, password, properties, callback) {\n    sanitizeArguments(username, password, properties, callback,\n        function(username, password, properties, callback) {\n            exports.get(username, function (err, user, options) {\n                if (err) {\n                    return callback(err);\n                }\n                if (_.indexOf(properties.roles, \"_admin\") === -1) {\n                    _.extend(user, properties);\n                }\n                if (password) {\n                    user.password_sha = sha1.hex(password + user.salt);\n                }\n\n                saveUser(options.authdb, user, function (err, user) {\n                    \n                    session.info(function(err, session_info){\n                        if (session_info.userCtx.roles && _.indexOf(session_info.userCtx.roles, \"_admin\") !== -1) {\n                            if (_.indexOf(properties.roles, \"_admin\") !== -1) {\n                                createAdmin(username, password, function () {\n                                    callback(null, user);\n                                });\n                            }\n                            else {\n                                getAdmin(username, function(err, admin) {\n                                    if (err) {\n                                        if (err.status !== 404) {\n                                            return callback(err);\n                                        }\n                                        return callback(null, user);\n                                    }\n                                    else {\n                                        deleteAdmin(username, callback);\n                                    }\n                                });\n                            }\n                        } else {\n                            callback(err, user);\n                        }\n                    });\n                    \n                });\n            });\n    });\n};\n",
    "underscore": "//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);",
    "sha1": "/**\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS PUB 180-1. This module is used to hash user passwords in a way that's\r\n * compatible with CouchDB.\r\n *\r\n * This module is Copyright Paul Johnston 2000 - 2002 and distributed under the\r\n * BSD License. See http://pajhome.org.uk/crypt/md5 for details.\r\n *\r\n * @module\r\n */\r\n\r\n/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS PUB 180-1\r\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n */\r\n\r\n/*\r\n * Configurable variables. You may need to tweak these to be compatible with\r\n * the server-side, but the defaults work in most cases.\r\n */\r\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\r\nvar b64pad  = \"=\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\r\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\r\n\r\n/*\r\n * These are the functions you'll usually want to call\r\n * They take string arguments and return either hex or base-64 encoded strings\r\n */\r\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\r\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\r\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\r\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\r\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\r\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction sha1_vm_test()\r\n{\r\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\r\n}\r\n\r\n/*\r\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\r\n */\r\nfunction core_sha1(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << (24 - len % 32);\r\n  x[((len + 64 >> 9) << 4) + 15] = len;\r\n\r\n  var w = Array(80);\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n  var e = -1009589776;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n    var olde = e;\r\n\r\n    for(var j = 0; j < 80; j++)\r\n    {\r\n      if(j < 16) w[j] = x[i + j];\r\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\r\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\r\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\r\n      e = d;\r\n      d = c;\r\n      c = rol(b, 30);\r\n      b = a;\r\n      a = t;\r\n    }\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n    e = safe_add(e, olde);\r\n  }\r\n  return Array(a, b, c, d, e);\r\n\r\n}\r\n\r\n/*\r\n * Perform the appropriate triplet combination function for the current\r\n * iteration\r\n */\r\nfunction sha1_ft(t, b, c, d)\r\n{\r\n  if(t < 20) return (b & c) | ((~b) & d);\r\n  if(t < 40) return b ^ c ^ d;\r\n  if(t < 60) return (b & c) | (b & d) | (c & d);\r\n  return b ^ c ^ d;\r\n}\r\n\r\n/*\r\n * Determine the appropriate additive constant for the current iteration\r\n */\r\nfunction sha1_kt(t)\r\n{\r\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\r\n         (t < 60) ? -1894007588 : -899497514;\r\n}\r\n\r\n/*\r\n * Calculate the HMAC-SHA1 of a key and some data\r\n */\r\nfunction core_hmac_sha1(key, data)\r\n{\r\n  var bkey = str2binb(key);\r\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\r\n\r\n  var ipad = Array(16), opad = Array(16);\r\n  for(var i = 0; i < 16; i++)\r\n  {\r\n    ipad[i] = bkey[i] ^ 0x36363636;\r\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\r\n  }\r\n\r\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\r\n  return core_sha1(opad.concat(hash), 512 + 160);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\n/*\r\n * Convert an 8-bit or 16-bit string to an array of big-endian words\r\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\r\n */\r\nfunction str2binb(str)\r\n{\r\n  var bin = Array();\r\n  var mask = (1 << chrsz) - 1;\r\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\r\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\r\n  return bin;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a string\r\n */\r\nfunction binb2str(bin)\r\n{\r\n  var str = \"\";\r\n  var mask = (1 << chrsz) - 1;\r\n  for(var i = 0; i < bin.length * 32; i += chrsz)\r\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\r\n  return str;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a hex string.\r\n */\r\nfunction binb2hex(binarray)\r\n{\r\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n  var str = \"\";\r\n  for(var i = 0; i < binarray.length * 4; i++)\r\n  {\r\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\r\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\r\n  }\r\n  return str;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a base-64 string\r\n */\r\nfunction binb2b64(binarray)\r\n{\r\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n  var str = \"\";\r\n  for(var i = 0; i < binarray.length * 4; i += 3)\r\n  {\r\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\r\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\r\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\r\n    for(var j = 0; j < 4; j++)\r\n    {\r\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\r\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n\r\n/**\r\n * Hashes a string using SHA1 and returns a hex representation of it.\r\n *\r\n * @name hex(s)\r\n * @param {String} s\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.hex = hex_sha1;\r\n\r\n/**\r\n * Hashes a string using SHA1 and returns a base64 representation of it.\r\n *\r\n * @name base64(s)\r\n * @param {String} s\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.base64 = b64_sha1;\r\n\r\n/**\r\n * Hashes a string using SHA1 and returns a string representation of it.\r\n *\r\n * @name str(s)\r\n * @param {String} s\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.str = str_sha1;\r\n\r\n/**\r\n * Calculates the HMAC-SHA1 of a key and some data, returning a hex\r\n * representation of it.\r\n *\r\n * @name hex_hmac(key, data)\r\n * @param {String} key\r\n * @param {String} data\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.hex_hmac = hex_hmac_sha1;\r\n\r\n/**\r\n * Calculates the HMAC-SHA1 of a key and some data, returning a base64\r\n * representation of it.\r\n *\r\n * @name base64_hmac(key, data)\r\n * @param {String} key\r\n * @param {String} data\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.base64_hmac = b64_hmac_sha1;\r\n\r\n/**\r\n * Calculates the HMAC-SHA1 of a key and some data, returning a string\r\n * representation of it.\r\n *\r\n * @name str_hmac(key, data)\r\n * @param {String} key\r\n * @param {String} data\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.str_hmac = str_hmac_sha1;\r\n",
    "db": "/*global $: false */\n\n/**\n * ## DB Module\n *\n * This contains the core functions for dealing with CouchDB. That includes\n * document CRUD operations, querying views and creating/deleting databases.\n *\n *\n * ### Events\n *\n * The db module is an EventEmitter. See the\n * [events package](http://kan.so/packages/details/events) for more information.\n *\n * #### unauthorized\n *\n * Emitted by the db module when a request results in a 401 Unauthorized\n * response. This is listened to used by the session module to help detect\n * session timeouts etc.\n *\n * ```javascript\n * var db = require(\"db\");\n *\n * db.on('unauthorized', function (req) {\n *     // req is the ajax request object which returned 401\n * });\n * ```\n *\n * @module\n */\n\n\nvar events = require('events'),\n    _ = require('underscore')._;\n\n\n/**\n * Tests if running in the browser\n *\n * @returns {Boolean}\n */\n\nfunction isBrowser() {\n    return (typeof(window) !== 'undefined');\n}\n\n\n/**\n * This module is an EventEmitter, used for emitting 'unauthorized' events\n */\n\nvar exports = module.exports = new events.EventEmitter();\n\n\n/**\n * Taken from jQuery 1.4.4 so we can support more recent versions of jQuery.\n */\n\nvar httpData = function (xhr, type, s) {\n    var ct = xhr.getResponseHeader(\"content-type\") || \"\",\n        xml = type === \"xml\" || !type && ct.indexOf(\"xml\") >= 0,\n        data = xml ? xhr.responseXML : xhr.responseText;\n\n    if (xml && data.documentElement.nodeName === \"parsererror\") {\n        $.error(\"parsererror\");\n    }\n    if (s && s.dataFilter) {\n        data = s.dataFilter(data, type);\n    }\n    if (typeof data === \"string\") {\n        if (type === \"json\" || !type && ct.indexOf(\"json\") >= 0) {\n            data = $.parseJSON(data);\n        }\n        else if (type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0) {\n            $.globalEval(data);\n        }\n    }\n    return data;\n};\n\n\n/**\n * Returns a function for handling ajax responses from jquery and calls\n * the callback with the data or appropriate error.\n *\n * @param {Function} callback(err,response)\n * @api private\n */\n\nfunction onComplete(options, callback) {\n    return function (req) {\n        var resp;\n        var ctype = req.getResponseHeader('Content-Type');\n        if (ctype === 'application/json' || ctype === 'text/json') {\n            try {\n                resp = httpData(req, \"json\");\n            }\n            catch (e) {\n                return callback(e);\n            }\n        }\n        else {\n            if (options.expect_json) {\n                try {\n                    resp = httpData(req, \"json\");\n                }\n                catch (ex) {\n                    return callback(\n                        new Error('Expected JSON response, got ' + ctype)\n                    );\n                }\n            }\n            else {\n                resp = req.responseText;\n            }\n        }\n        if (req.status === 401) {\n            exports.emit('unauthorized', req);\n        }\n        if (req.status === 200 || req.status === 201 || req.status === 202) {\n            callback(null, resp);\n        }\n        else if (resp.error || resp.reason) {\n            var err = new Error(resp.reason || resp.error);\n            err.error = resp.error;\n            err.reason = resp.reason;\n            err.code = resp.code;\n            err.status = req.status;\n            callback(err);\n        }\n        else {\n            // TODO: map status code to meaningful error message\n            var err2 = new Error('Returned status code: ' + req.status);\n            err2.status = req.status;\n            callback(err2);\n        }\n    };\n}\n\n\n/**\n * Attempts to guess the database name and design doc id from the current URL,\n * or the loc paramter. Returns an object with 'db', 'design_doc' and 'root'\n * properties, or null for a URL not matching the expected format (perhaps\n * behing a vhost).\n *\n * You wouldn't normally use this function directly, but use `db.current()` to\n * return a DB object bound to the current database instead.\n *\n * @name guessCurrent([loc])\n * @param {String} loc - An alternative URL to use instead of window.location\n *     (optional)\n * @returns {Object|null} - An object with 'db', 'design_doc' and 'root'\n *     properties, or null for a URL not matching the\n *     expected format (perhaps behing a vhost)\n * @api public\n */\n\nexports.guessCurrent = function (loc) {\n    var loc = loc || window.location;\n\n    /**\n     * A database must be named with all lowercase letters (a-z), digits (0-9),\n     * or any of the _$()+-/ characters and must end with a slash in the URL.\n     * The name has to start with a lowercase letter (a-z).\n     *\n     * http://wiki.apache.org/couchdb/HTTP_database_API\n     */\n\n    var re = /\\/([a-z][a-z0-9_\\$\\(\\)\\+-\\/]*)\\/_design\\/([^\\/]+)\\//;\n    var match = re.exec(loc.pathname);\n\n    if (match) {\n        return {\n            db: match[1],\n            design_doc: match[2],\n            root: '/'\n        }\n    }\n    return null;\n};\n\n/**\n * Converts an object to a string of properly escaped URL parameters.\n *\n * @name escapeUrlParams([obj])\n * @param {Object} obj - An object containing url parameters, with\n *       parameter names stored as property names (or keys).\n * @returns {String}\n * @api public\n */\n\nexports.escapeUrlParams = function (obj) {\n    var rv = [ ];\n    for (var key in obj) {\n        rv.push(\n            encodeURIComponent(key) +\n                '=' + encodeURIComponent(obj[key])\n        );\n    }\n    return (rv.length > 0 ? ('?' + rv.join('&')) : '');\n};\n\n/**\n * Encodes a document id or view, list or show name. This also will make sure\n * the forward-slash is not escaped for documents with id's beginning with\n * \"\\_design/\".\n *\n * @name encode(str)\n * @param {String} str - the name or id to escape\n * @returns {String}\n * @api public\n */\n\nexports.encode = function (str) {\n    return encodeURIComponent(str).replace(/^_design%2F/, '_design/');\n};\n\n\n/**\n * Properly encodes query parameters to CouchDB views etc. Handle complex\n * keys and other non-string parameters by passing through JSON.stringify.\n * Returns a shallow-copied clone of the original query after complex values\n * have been stringified.\n *\n * @name stringifyQuery(query)\n * @param {Object} query\n * @returns {Object}\n * @api public\n */\n\nexports.stringifyQuery = function (query) {\n    var q = {};\n    for (var k in query) {\n        if (typeof query[k] !== 'string') {\n            q[k] = JSON.stringify(query[k]);\n        }\n        else {\n            q[k] = query[k];\n        }\n    }\n    return q;\n};\n\n\n/**\n * Make a request, with some default settings, proper callback\n * handling, and optional caching. Used behind-the-scenes by\n * most other DB module functions.\n *\n * @name request(options, callback)\n * @param {Object} options\n * @param {Function} callback(err,response)\n * @api public\n */\n\nexports.request = function (options, callback) {\n    options.complete = onComplete(options, callback);\n    options.dataType = 'json';\n    $.ajax(options);\n};\n\n\n/**\n * Creates a CouchDB database.\n *\n * If you're running behind a virtual host you'll need to set up\n * appropriate rewrites for a DELETE request to '/' either turning off safe\n * rewrites or setting up a new vhost entry.\n *\n * @name createDatabase(name, callback)\n * @param {String} name\n * @param {Function} callback(err,response)\n * @api public\n */\n\nexports.createDatabase = function (name, callback) {\n    var req = {\n        type: 'PUT',\n        url: '/' + exports.encode(name.replace(/^\\/+/, ''))\n    };\n    exports.request(req, callback);\n};\n\n/**\n * Deletes a CouchDB database.\n *\n * If you're running behind a virtual host you'll need to set up\n * appropriate rewrites for a DELETE request to '/' either turning off safe\n * rewrites or setting up a new vhost entry.\n *\n * @name deleteDatabase(name, callback)\n * @param {String} name\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: detect when 'name' argument is a url and don't construct a url then\nexports.deleteDatabase = function (name, callback) {\n    var req = {\n        type: 'DELETE',\n        url: '/' + exports.encode(name.replace(/^\\/+/, ''))\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Lists all databses\n *\n * If you're running behind a virtual host you'll need to set up\n * appropriate rewrites for a DELETE request to '/' either turning off safe\n * rewrites or setting up a new vhost entry.\n *\n * @name allDbs(callback)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nexports.allDbs = function (callback) {\n    var req = {\n        type: 'GET',\n        url: '/_all_dbs'\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Returns a new UUID generated by CouchDB. Its possible to cache\n * multiple UUIDs for later use, to avoid making too many requests.\n *\n * @name newUUID(cacheNum, callback)\n * @param {Number} cacheNum (optional, default: 1)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nvar uuidCache = [];\n\nexports.newUUID = function (cacheNum, callback) {\n    if (!callback) {\n        callback = cacheNum;\n        cacheNum = 1;\n    }\n    if (uuidCache.length) {\n        return callback(null, uuidCache.shift());\n    }\n    var req = {\n        url: '/_uuids',\n        data: {count: cacheNum},\n        expect_json: true\n    };\n    exports.request(req, function (err, resp) {\n        if (err) {\n            return callback(err);\n        }\n        uuidCache = resp.uuids;\n        callback(null, uuidCache.shift());\n    });\n};\n\n\n/**\n * DB object created by use(dbname) function\n */\n\nfunction DB(url) {\n    this.url = url;\n    // add the module functions to the DB object\n    for (var k in exports) {\n        this[k] = exports[k];\n    }\n};\n\n\n/**\n * Creates a new DB object with methods operating on the database at 'url'\n *\n * The DB object also exposes the same module-level methods (eg, createDatabase)\n * so it can be used in-place of the db exports object, for example:\n *\n * ```javascript\n * var db = require('db').use('mydb');\n *\n * db.createDatabase('example', function (err, resp) {\n *     // do something\n * });\n * ```\n *\n * @name use(url)\n * @param {String} url - The url to bind the new DB object to\n * @returns {DB}\n * @api public\n */\n\n// TODO: handle full urls, not just db names\nexports.use = function (url) {\n    /* Force leading slash; make absolute path */\n    return new DB((url.substr(0, 1) !== '/' ? '/' : '') + url);\n};\n\n/**\n * Attempts to guess the current DB name and return a DB object using that.\n * Should work reliably unless running behind a virtual host.\n *\n * Throws an error if the current database url cannot be detected.\n *\n * The DB object also exposes the same module-level methods (eg, createDatabase)\n * so it can be used in-place of the db exports object, for example:\n *\n * ```javascript\n * var db = require('db').current();\n *\n * db.createDatabase('example', function (err, resp) {\n *     // do something\n * });\n * ```\n *\n * @name current()\n * @returns {DB}\n * @api public\n */\n\nexports.current = function () {\n    // guess current db url etc\n    var curr = exports.guessCurrent();\n    if (!curr) {\n        throw new Error(\n            'Cannot guess current database URL, if running behind a virtual ' +\n            'host you need to explicitly set the database URL using ' +\n            'db.use(database_url) instead of db.current()'\n        );\n    }\n    return exports.use(curr.db);\n};\n\n\n/**\n * Fetches a rewrite from the database the app is running on. Results\n * are passed to the callback, with the first argument of the callback\n * reserved for any exceptions that occurred (node.js style).\n *\n * @name DB.getRewrite(name, path, [q], callback)\n * @param {String} name - the name of the design doc\n * @param {String} path\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getRewrite = function (name, path, /*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    // prepend forward-slash if missing\n    path = (path[0] === '/') ? path: '/' + path;\n\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/_design/' + exports.encode(name) + '/_rewrite' + path,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Queries all design documents in the database.\n *\n * @name DB.allDesignDocs([q], callback)\n * @param {Object} q - query parameters to pass to /_all_docs (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.allDesignDocs = function (/*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    q.startkey = '\"_design\"';\n    q.endkey = '\"_design0\"';\n    this.allDocs(q, callback);\n};\n\n\n/**\n * Queries all documents in the database (include design docs).\n *\n * @name DB.allDocs([q], callback)\n * @param {Object} q - query parameters to pass to /_all_docs (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.allDocs = function (/*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/_all_docs',\n        data: data,\n        expect_json: true\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetches a document from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.getDoc(id, [q], callback)\n * @param {String} id\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getDoc = function (id, /*optional*/q, callback) {\n    if (!id) {\n        throw new Error('getDoc requires an id parameter to work properly');\n    }\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/' + exports.encode(id),\n        expect_json: true,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Saves a document to the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.saveDoc(doc, callback)\n * @param {Object} doc\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.saveDoc = function (doc, callback) {\n    var method, url = this.url;\n    if (doc._id === undefined) {\n        method = \"POST\";\n    }\n    else {\n        method = \"PUT\";\n        url += '/' + doc._id;\n    }\n    try {\n        var data = JSON.stringify(doc);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        type: method,\n        url: url,\n        data: data,\n        processData: false,\n        contentType: 'application/json',\n        expect_json: true\n    };\n    exports.request(req, callback);\n};\n\n/**\n * Deletes a document from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.removeDoc(doc, callback)\n * @param {Object} doc\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.removeDoc = function (doc, callback) {\n    if (!doc._id) {\n        throw new Error('removeDoc requires an _id field in your document');\n    }\n    if (!doc._rev) {\n        throw new Error('removeDoc requires a _rev field in your document');\n    }\n    var req = {\n        type: 'DELETE',\n        url: this.url + '/' + exports.encode(doc._id) +\n             '?rev=' + exports.encode(doc._rev)\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetches a view from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.getView(name, view, [q], callback)\n * @param {String} name - name of the design doc to use\n * @param {String} view - name of the view\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getView = function (name, view, /*opt*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    var viewname = exports.encode(view);\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: (this.url +\n            '/_design/' + exports.encode(name) +\n            '/_view/' + viewname\n        ),\n        expect_json: true,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetches a spatial view from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * __Parameters:__\n * * bbox - the bounding box filter e.g.: bbox: '0,0,180,90'\n * * plane_bounds - e.g.: plane_bounds: '-180,-90,180,90'\n * * stale - stale: 'ok' prevents the spatial index to be rebuilt\n * * count - count: true will only return the number of geometries\n *\n * @name DB.getSpatialView(name, view, q, callback)\n * @param {String} name - name of the design doc to use\n * @param {String} view - name of the view\n * @param {Object} q - query parameters (see options above)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getSpatialView = function (name, view, q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    var viewname = exports.encode(view);\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: (this.url +\n            '/_design/' + exports.encode(name) +\n            '/_spatial/' + viewname\n        ),\n        expect_json: true,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Transforms and fetches a view through a list from the database the app\n * is running on. Results are passed to the callback, with the first\n * argument of the callback reserved for any exceptions that occurred\n * (node.js style).\n *\n * @name DB.getList(name, list, view, [q], callback)\n * @param {String} name - name of the design doc to use\n * @param {String} list - name of the list function\n * @param {String} view - name of the view to apply the list function to\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: run list function client-side?\nDB.prototype.getList = function (name, list, view, /*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    var listname = exports.encode(list);\n    var viewname = exports.encode(view);\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/_design/' + exports.encode(name) +\n            '/_list/' + listname + '/' + viewname,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n/**\n * Transforms and fetches a document through a show from the database the app\n * is running on. Results are passed to the callback, with the first\n * argument of the callback reserved for any exceptions that occurred\n * (node.js style).\n *\n * @name DB.getShow(name, show, docid, [q], callback)\n * @param {String} name - name of the design doc to use\n * @param {String} show - name of the show function\n * @param {String} docid - id of the document to apply the show function to\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: run show function client-side?\nDB.prototype.getShow = function (name, show, docid, /*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var showname = exports.encode(show);\n    var show_url = this.url + '/_design/' +\n        exports.encode(name) + '/_show/' + exports.encode(showname);\n    var req = {\n        url: show_url + (docid ? '/' + exports.encode(docid): ''),\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetch a design document from CouchDB.\n *\n * @name DB.getDesignDoc(name, callback)\n * @param name The name of (i.e. path to) the design document without the\n *     preceeding \"\\_design/\".\n * @param callback The callback to invoke when the request completes.\n * @api public\n */\n\nDB.prototype.getDesignDoc = function (name, callback) {\n    this.getDoc('_design/' + name, function (err, ddoc) {\n        if (err) {\n            return callback(err);\n        }\n        return callback(null, ddoc);\n    });\n};\n\n/**\n * Gets information about the database.\n *\n * @name DB.info(callback)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.info = function (callback) {\n    var req = {\n        url: this.url,\n        expect_json: true,\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Listen to the changes feed for a database.\n *\n * __Options:__\n * * _filter_ - the filter function to use\n * * _since_ - the update_seq to start listening from\n * * _heartbeat_ - the heartbeat time (defaults to 10 seconds)\n * * _include_docs_ - whether to include docs in the results\n *\n * Returning false from the callback will cancel the changes listener\n *\n * @name DB.changes([q], callback)\n * @param {Object} q (optional) query parameters (see options above)\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: change this to use an EventEmitter\nDB.prototype.changes = function (/*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n\n    var that = this;\n\n    q = q || {};\n    q.feed = 'longpoll';\n    q.heartbeat = q.heartbeat || 10000;\n\n    function getChanges(since) {\n        q.since = since;\n        try {\n            var data = exports.stringifyQuery(q);\n        }\n        catch (e) {\n            return callback(e);\n        }\n        var req = {\n            type: 'GET',\n            expect_json: true,\n            url: that.url + '/_changes',\n            data: data\n        };\n        var cb = function (err, data) {\n            var result = callback.apply(this, arguments);\n            if (result !== false) {\n                getChanges(data.last_seq);\n            }\n        }\n        exports.request(req, cb);\n    }\n\n    // use setTimeout to pass control back to the browser briefly to\n    // allow the loading spinner to stop on page load\n    setTimeout(function () {\n        if (q.hasOwnProperty('since')) {\n            getChanges(q.since);\n        }\n        else {\n            that.info(function (err, info) {\n                if (err) {\n                    return callback(err);\n                }\n                getChanges(info.update_seq);\n            });\n        }\n    }, 0);\n};\n\n\n/**\n * Saves a list of documents, without using separate requests.\n * This function uses CouchDB's HTTP bulk document API (_bulk_docs).\n * The return value is an array of objects, each containing an 'id'\n * and a 'rev' field. The return value is passed to the callback you\n * provide via its second argument; the first argument of the callback\n * is reserved for any exceptions that occurred (node.js style).\n *\n * **Options:**\n * * *all_or\\_nothing* - Require that all documents be saved\n *   successfully (or saved with a conflict); otherwise roll\n *   back the operation.\n *\n * @name DB.bulkSave(docs, [options], callback)\n * @param {Array} docs An array of documents; each document is an object\n * @param {Object} options (optional) Options for the bulk-save operation.\n * @param {Function} callback(err,response) - A function to accept results\n *          and/or errors. Document update conflicts are reported in the\n *          results array.\n * @api public\n */\n\nDB.prototype.bulkSave = function (docs, /*optional*/ options, callback) {\n    if (!_.isArray(docs)) {\n        throw new Error(\n            'bulkSave requires an array of documents to work properly'\n        );\n    }\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n    options.docs = docs;\n    try {\n        var data = JSON.stringify(options);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        type: 'POST',\n        url: this.url + '/_bulk_docs',\n        data: data,\n        processData: false,\n        contentType: 'application/json',\n        expect_json: true\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Requests a list of documents, using only a single HTTP request.\n * This function uses CouchDB's HTTP bulk document API (_all_docs).\n * The return value is an array of objects, each of which is a document.\n * The return value is passed to the callback you provide via its second\n * argument; the first argument of the callback is reserved for any\n * exceptions that occurred (node.js style).\n *\n * @name DB.bulkGet(keys, [q], callback)\n * @param {Array} keys An array of documents identifiers (i.e. strings).\n * @param {Object} q (optional) Query parameters for the bulk-read operation.\n * @param {Function} callback(err,response) - A function to accept results\n *          and/or errors. Document update conflicts are reported in the\n *          results array.\n * @api public\n */\n\nDB.prototype.bulkGet = function (keys, /*optional*/ q, callback) {\n    if (keys && !_.isArray(keys)) {\n        throw new Error(\n            'bulkGet requires that _id values be supplied as a list'\n        );\n    }\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n\n    /* Encode every query-string option:\n        CouchDB requires that these be JSON, even though they\n        will be URL-encoded as part of the request process. */\n\n    try {\n        for (var k in q) {\n            q[k] = JSON.stringify(q[k]);\n        }\n    }\n    catch (e) {\n        return callback(e);\n    }\n\n    /* Make request:\n        If we have a list of keys, use a post request containing\n        a JSON-encoded list of keys. Otherwise, use a get request. */\n\n    var req = {\n        expect_json: true,\n        url: this.url + '/_all_docs' + exports.escapeUrlParams(q)\n    };\n    if (keys) {\n        try {\n            var data = JSON.stringify({ keys: keys});\n        }\n        catch (e) {\n            return callback(e);\n        }\n        req = _.extend(req, {\n            type: 'POST',\n            processData: false,\n            contentType: 'application/json',\n            data: data\n        });\n    } else {\n        req = _.extend(req, {\n            type: 'GET'\n        });\n    }\n\n    exports.request(req, callback);\n};\n\n\n/**\n * DB methods can only be called client-side\n */\n\n_.each(_.keys(DB.prototype), function (k) {\n    var _fn = DB.prototype[k];\n    DB.prototype[k] = function () {\n        if (!isBrowser()) {\n            throw new Error(k + ' cannot be called server-side');\n        }\n        return _fn.apply(this, arguments);\n    };\n});\n",
    "session": "/**\n * ## Session module\n *\n * This module contains functions related to session management. Logging in,\n * logging out and checking the current state of a user's session.\n *\n * Functions in this module follow the node.js callback style. The first\n * argument is an error object (if one occurred), the following arguments are\n * the results of the operation. The callback is always the last argument to a\n * function.\n *\n *\n * ### Events\n *\n * The session module is an EventEmitter. See the\n * [events package](http://kan.so/packages/details/events) for more information.\n *\n * #### change\n *\n * Emitted whenever a change to the user's session is detected, this\n * can occur as the result of a login/logout call or by getting the user's\n * session info (and it's changed).\n *\n * ```javascript\n * var session = require(\"session\");\n *\n * session.on('change', function (userCtx) {\n *     // update session information, eg \"Logged in as ...\"\n * });\n * ```\n *\n * @module\n */\n\n\nvar events = require('events'),\n    db = require('db');\n\n\n/**\n * Quick utility function for testing if running in the browser, since\n * these functions won't run on CouchDB server-side\n */\n\nfunction isBrowser() {\n    return (typeof(window) !== 'undefined');\n}\n\n/**\n * When a db call results in an unauthorized response, the user's session is\n * checked to see if their session has timed out or they've logged out in\n * another screen.\n *\n * This check is throttled to once per second, to avoid flooding the server if\n * multiple requests are made with incorrect permissions.\n */\n\nvar last_session_check = 0;\n\ndb.on('unauthorized', function (req) {\n    // db call returned 'Unauthorized', check the user's session if it's not\n    // been checked on an 'Unauthorized' repsonse in the last second\n    if (last_session_check < new Date().getTime() - 1000) {\n        exports.info();\n    }\n});\n\n\n/**\n * This module is an EventEmitter, used for handling 'change' events\n */\n\nvar exports = module.exports = new events.EventEmitter();\n\n\n/**\n * Attempt to login using the username and password provided.\n *\n * @name login(username, password, callback)\n * @param {String} username - the username to login with\n * @param {String} password - the user's password (unhashed)\n * @param {Function} callback - function called with the result of the login\n *     attempt\n * @api public\n *\n * ```javascript\n * session.login('testuser', 'password', function (err, response) {\n *     if (err) // an error occurred logging in\n *     else     // success\n * });\n * ```\n */\n\nexports.login = function (username, password, callback) {\n    if (!isBrowser()) {\n        throw new Error('login cannot be called server-side');\n    }\n    db.request({\n        type: \"POST\",\n        url: \"/_session\",\n        data: {name: username, password: password}\n    },\n    function (err, resp) {\n        if (resp && resp.ok) {\n            // TODO: for some reason resp.name is set to null in the response\n            // even though the roles are correct for the user! Look into this\n            // and see if its a bug in couchdb, for now, just using the username\n            // given to the login function instead, since we know the login\n            // request was accepted.\n            exports.userCtx = {name: username, roles: resp.roles};\n            exports.session = {userCtx: exports.userCtx};\n            exports.emit('change', exports.userCtx);\n        }\n        if (callback) {\n            callback(err, resp);\n        }\n    });\n};\n\n\n/**\n * Logs out the current user.\n *\n * @name logout(callback)\n * @param {Function} callback - function called with the result of the logout\n *     attempt\n * @api public\n *\n * ```javascript\n * session.logout(function (err, response) {\n *     if (err) // an error occurred logging out\n *     else     // success\n * });\n * ```\n */\n\nexports.logout = function (callback) {\n    if (!isBrowser()) {\n        throw new Error('logout cannot be called server-side');\n    }\n    db.request({\n        type: \"DELETE\",\n        url: \"/_session\", // don't need baseURL, /_session always available\n        username: \"_\",\n        password : \"_\"\n    },\n    function (err, resp) {\n        if (resp && resp.ok) {\n            exports.userCtx = {name: null, roles: []};\n            exports.session = {userCtx: exports.userCtx};\n            exports.emit('change', exports.userCtx);\n        }\n        if (callback) {\n            callback(err, resp);\n        }\n    });\n};\n\n\n/**\n * Returns the current user's session information. The info object contains a\n * `userCtx` property and an `info` property. The first contains the name and\n * roles of the current user, the second contains information about the user\n * database and authentication handlers.\n *\n * @name info(callback)\n * @param {Function} callback - function called with the session information\n * @api public\n *\n * ```javascript\n * session.info(function (err, info) {\n *     if (err) // an error occurred getting session info\n *     else     // success\n * });\n * ```\n */\n\nexports.info = function (callback) {\n    if (!isBrowser()) {\n        throw new Error('info cannot be called server-side');\n    }\n    db.request({\n        type: \"GET\",\n        url: \"/_session\"\n    },\n    function (err, resp) {\n        var oldUserCtx = exports.userCtx;\n        exports.session = resp;\n        exports.userCtx = (resp && resp.userCtx) || {name: null, roles: []};\n        // TODO: should this check for differences in more than just name?\n        if (!oldUserCtx || oldUserCtx.name !== exports.userCtx.name) {\n            exports.emit('change', exports.userCtx);\n        }\n        if (callback) {\n            callback(err, resp);\n        }\n    });\n};\n",
    "events": "/**\n * ## Events module\n *\n * This is a browser port of the node.js events module. Many objects and\n * modules emit events and these are instances of events.EventEmitter.\n *\n * You can access this module by doing: `require(\"events\")`\n *\n * Functions can then be attached to objects, to be executed when an event is\n * emitted. These functions are called listeners.\n *\n * @module\n */\n\n\n/**\n * To access the EventEmitter class, require('events').EventEmitter.\n *\n * When an EventEmitter instance experiences an error, the typical action is to\n * emit an 'error' event. Error events are treated as a special case. If there\n * is no listener for it, then the default action is for the error to throw.\n *\n * All EventEmitters emit the event 'newListener' when new listeners are added.\n *\n * @name events.EventEmitter\n * @api public\n *\n * ```javascript\n * var EventEmitter = require('events').EventEmitter;\n *\n * // create an event emitter\n * var emitter = new EventEmitter();\n * ```\n */\n\nvar EventEmitter = exports.EventEmitter = function () {};\n\nvar isArray = Array.isArray || function (obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n\n/**\n * By default EventEmitters will print a warning if more than 10 listeners are\n * added for a particular event. This is a useful default which helps finding\n * memory leaks. Obviously not all Emitters should be limited to 10. This\n * function allows that to be increased. Set to zero for unlimited.\n *\n * @name emitter.setMaxListeners(n)\n * @param {Number} n - The maximum number of listeners\n * @api public\n */\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\n/**\n * Execute each of the listeners in order with the supplied arguments.\n *\n * @name emitter.emit(event, [arg1], [arg2], [...])\n * @param {String} event - The event name/id to fire\n * @api public\n */\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * Adds a listener to the end of the listeners array for the specified event.\n *\n * @name emitter.on(event, listener) | emitter.addListener(event, listener)\n * @param {String} event - The event name/id to listen for\n * @param {Function} listener - The function to bind to the event\n * @api public\n *\n * ```javascript\n * session.on('change', function (userCtx) {\n *     console.log('session changed!');\n * });\n * ```\n */\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds a one time listener for the event. This listener is invoked only the\n * next time the event is fired, after which it is removed.\n *\n * @name emitter.once(event, listener)\n * @param {String} event- The event name/id to listen for\n * @param {Function} listener - The function to bind to the event\n * @api public\n *\n * ```javascript\n * db.once('unauthorized', function (req) {\n *     // this event listener will fire once, then be unbound\n * });\n * ```\n */\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\n/**\n * Remove a listener from the listener array for the specified event. Caution:\n * changes array indices in the listener array behind the listener.\n *\n * @name emitter.removeListener(event, listener)\n * @param {String} event - The event name/id to remove the listener from\n * @param {Function} listener - The listener function to remove\n * @api public\n *\n * ```javascript\n * var callback = function (init) {\n *     console.log('duality app loaded');\n * };\n * devents.on('init', callback);\n * // ...\n * devents.removeListener('init', callback);\n * ```\n */\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\n/**\n * Removes all listeners, or those of the specified event.\n *\n * @name emitter.removeAllListeners([event])\n * @param {String} event - Event name/id to remove all listeners for (optional)\n * @api public\n */\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\n/**\n * Returns an array of listeners for the specified event. This array can be\n * manipulated, e.g. to remove listeners.\n *\n * @name emitter.listeners(event)\n * @param {String} events - The event name/id to return listeners for\n * @api public\n *\n * ```javascript\n * session.on('change', function (stream) {\n *     console.log('session changed');\n * });\n * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]\n * ```\n */\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n\n/**\n * @name emitter Event: 'newListener'\n *\n * This event is emitted any time someone adds a new listener.\n *\n * ```javascript\n * emitter.on('newListener', function (event, listener) {\n *     // new listener added\n * });\n * ```\n */\n",
    "rewrites": [],
    "kanso": {
        "config": {
            "name": "oauth-key-management",
            "version": "0.0.1",
            "description": "OAuth Key Management",
            "attachments": [
                "index.html",
                "css",
                "images"
            ],
            "modules": [
                "lib"
            ],
            "load": "lib/app",
            "dependencies": {
                "attachments": null,
                "modules": null,
                "users": null,
                "underscore": null,
                "properties": null
            },
            "minify": false
        },
        "build_time": "2012-06-14T15:43:53Z",
        "kanso_version": "0.2.1"
    }
}
