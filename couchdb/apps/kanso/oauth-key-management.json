{
    "_attachments": {
        "index.html": {
            "content_type": "text/html",
            "data": "PCFET0NUWVBFIGh0bWw+CjxodG1sPgogIDxoZWFkPgogICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vYnJvd3NlcmlkLm9yZy9pbmNsdWRlLmpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPjwvc2NyaXB0PgoKICAgIDwhLS0gT3B0aW9uYWwgc3R5bGVzIC0tPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiB0eXBlPSJ0ZXh0L2NzcyIgaHJlZj0iL19icm93c2VyaWQvc3R5bGUuY3NzIj4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgdHlwZT0idGV4dC9jc3MiIGhyZWY9ImNzcy9zdHlsZS5jc3MiPgogIDwvaGVhZD4KCiAgPGJvZHk+CiAgICA8ZGl2IGNsYXNzPSJoZWFkIj4KICAgICAgPGgyPk9BdXRoIE1hbmFnZW1lbnQgZm9yIFNpZ24gb24gUHVibGlzaDwvaDI+CiAgICAgIDxpbWcgY2xhc3M9ImxvZ28iIHNyYz0iaW1hZ2VzL2xlYXJuaW5nLXJlZ2lzdHJ5LWxvZ28ucG5nIj4KICAgIDwvZGl2PgoKICAgIDxkaXYgY2xhc3M9ImNyZWRlbnRpYWxzIj4KICAgICAgPGRpdiBpZD0iYnJvd3NlcmlkIj4KICAgICAgICA8ZGl2IGNsYXNzPSJwaWN0dXJlIj48L2Rpdj4KICAgICAgICA8ZGl2IGNsYXNzPSJsb2dpbiI+CiAgICAgICAgICA8aW1nIHNyYz0iL19icm93c2VyaWQvc2lnbl9pbl9ncmVlbi5wbmciPgogICAgICAgIDwvZGl2PgogICAgICA8L2Rpdj4KICAgIDwvZGl2PgogICAgPGRpdiBjbGFzcz0ibXNnIj48L2Rpdj4KICAgIDxkaXYgY2xhc3M9Im9hdXRoIj4KICAgICAgPGZpZWxkc2V0PgogICAgICAgIDxsZWdlbmQ+UHVibGlzaCBQYXNzd29yZDwvbGVnZW5kPgogICAgICAgIDxwPlVzaW5nIHlvdXIgZW1haWwgYWRkcmVzcyBhcyB1c2VybmFtZSBhbmQgdGhpcyBwYXNzd29yZCwgeW91IG1heSBwdWJsaXNoIHRvIHRoZSBCYXNpYyBQdWJsaXNoIG9yIFNXT1JEIGludGVyZmFjZXMgeW91ciBvd24gZGlnaXRhbGx5IHNpZ25lZCByZXNvdXJjZSBkYXRhIGVudmVsb3Blcy48L3A+CgogICAgICAgIDxsYWJlbCBmb3I9InBhc3N3b3JkX3NldCI+SXMgUGFzc3dvcmQgU2V0PzwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9ImNoZWNrYm94IiBpZD0icGFzc3dvcmRfc2V0IiBkaXNhYmxlZD0iZGlzYWJsZWQiPgoKICAgICAgICA8bGFiZWwgZm9yPSJwYXNzd29yZCI+UGFzc3dvcmQ8L2xhYmVsPgogICAgICAgIDxpbnB1dCB0eXBlPSJwYXNzd29yZCIgaWQ9InBhc3N3b3JkIj4KCiAgICAgICAgPGxhYmVsIGZvcj0idmVyaWZ5X3Bhc3N3b3JkIj5WZXJpZnkgUGFzc3dvcmQ8L2xhYmVsPgogICAgICAgIDxpbnB1dCB0eXBlPSJwYXNzd29yZCIgaWQ9InZlcmlmeV9wYXNzd29yZCI+CiAgICAgICAgPGJ1dHRvbiBpZD0ic2F2ZV9wYXNzd29yZCI+U2F2ZTwvYnV0dG9uPgogICAgICA8L2ZpZWxkc2V0PgogICAgICA8ZmllbGRzZXQ+CiAgICAgICAgPGxlZ2VuZD5TaWduaW5nIEluZm9ybWF0aW9uPC9sZWdlbmQ+CiAgICAgICAgPHA+VGhlIGZvbGxvd2luZyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSByZXNvdXJjZSBkYXRhIGRvY3VtZW50J3MgaWRlbnRpdHkgc2lnbmVyIGZpZWxkIGFsb25nIHdpdGggeW91ciBlbWFpbCBhZGRyZXNzIHNvIHRoYXQgeW91ciBzdWJtaXNzaW9ucyBtYXkgYmUgaWRlbnRpZmllZC48L3A+CiAgICAgICAgPGxhYmVsIGZvcj0iZnVsbF9uYW1lIj5GdWxsIE5hbWU8L2xhYmVsPgogICAgICAgIDxpbnB1dCB0eXBlPSJ0ZXh0IiBpZD0iZnVsbF9uYW1lIj4KCiAgICAgICAgPGJ1dHRvbiBpZD0iaW5mb191cGRhdGUiPlNhdmU8L2J1dHRvbj4KICAgICAgPC9maWVsZHNldD4KICAgICAgPGZpZWxkc2V0PgogICAgICAgIDxsZWdlbmQ+Mi1MZWdnZWQgT0F1dGggQ29uZmlnPC9sZWdlbmQ+CiAgICAgICAgPHA+VXNlIHRoZSBmb2xsb3dpbmcgd2hlbiBjb25uZWN0aW5nIHlvdXIgYXBwbGljYXRpb24gdG8gTFIgdG8gc2lnbiBvbiB5b3VyIGJlaGFsZi4gIElmIHRoZSBPQXV0aCBzaWduYXR1cmUgaXMgcHJlc2VudCB3aGVuIHlvdSBwdWJsaXNoLCB0aGUgZG9jdW1lbnRzIHlvdSBwdWJsaXNoIHdpbGwgYmUgc2lnbmVkIGJ5IHRoZSBub2RlLjwvcD4KICAgICAgICA8bGFiZWwgZm9yPSJjb25zdW1lcl9rZXkiPm9hdXRoX2NvbnN1bWVyX2tleTwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGRpc2FibGVkPSJkaXNhYmxlZCIgaWQ9ImNvbnN1bWVyX2tleSIgdmFsdWU9Im5vZGVfc2lnbl9rZXkiPgoKICAgICAgICA8bGFiZWwgZm9yPSJjb25zdW1lcl9zZWNyZXQiPm9hdXRoX2NvbnN1bWVyX3NlY3JldDwvbGFiZWw+CiAgICAgICAgPGlucHV0IHR5cGU9InRleHQiIGRpc2FibGVkPSJkaXNhYmxlZCIgaWQ9ImNvbnN1bWVyX3NlY3JldCI+CgoKICAgICAgICA8bGFiZWwgZm9yPSJ0b2tlbiI+b2F1dGhfdG9rZW48L2xhYmVsPgogICAgICAgIDxpbnB1dCB0eXBlPSJ0ZXh0IiBkaXNhYmxlZD0iZGlzYWJsZWQiIGlkPSJ0b2tlbiIgdmFsdWU9Im5vZGVfc2lnbl90b2tlbiI+CgogICAgICAgIDxsYWJlbCBmb3I9InRva2VuX3NlY3JldCI+b2F1dGhfdG9rZW5fc2VjcmV0PC9sYWJlbD4KICAgICAgICA8aW5wdXQgdHlwZT0idGV4dCIgZGlzYWJsZWQ9ImRpc2FibGVkIiBpZD0idG9rZW5fc2VjcmV0Ij4KCiAgICAgICAgPGJ1dHRvbiBpZD0icmVnZW5lcmF0ZSI+UmV2b2tlIGFuZCBSZWdlbmVyYXRlPC9idXR0b24+CiAgICAgIDwvZmllbGRzZXQ+CiAgICAgIAogICAgPC9kaXY+CiAgPC9ib2R5PgoKICA8IS0tIFJlY29tbWVuZGVkIGNvbnZlbmllbmNlIEFQSSAtLT4KICA8c2NyaXB0IHNyYz0iL191dGlscy9zY3JpcHQvanF1ZXJ5LmpzIiB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiPjwvc2NyaXB0PgogIDxzY3JpcHQgc3JjPSIvX3V0aWxzL3NjcmlwdC9vYXV0aC5qcyIgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij48L3NjcmlwdD4KICA8c2NyaXB0IHNyYz0iL191dGlscy9zY3JpcHQvc2hhMS5qcyIgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij48L3NjcmlwdD4KICA8c2NyaXB0IHNyYz0iL19icm93c2VyaWQvbWFpbi5qcyIgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij48L3NjcmlwdD4KICA8c2NyaXB0IHNyYz0ibW9kdWxlcy5qcyIgdHlwZT0idGV4dC9qYXZhc2NyaXB0Ij48L3NjcmlwdD4KICA8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCI+CiAgICB2YXIgbWFuYWdlX3Rva2VucyA9IHJlcXVpcmUoImxpYi9tYW5hZ2UtdG9rZW5zIik7CgogICAgbWFuYWdlX3Rva2Vucy5yZWdpc3RlckNhbGxiYWNrcygpOwogIDwvc2NyaXB0Pgo8L2h0bWw+"
        },
        "css/style.css": {
            "content_type": "text/css",
            "data": "CmRpdi5vYXV0aCB7CiAgICBkaXNwbGF5OiBub25lOwogICAgd2lkdGg6IDEwMCU7CiAgICBjbGVhcjogYm90aDsKfQoKZGl2Lm9hdXRoIGlucHV0W3R5cGU9Y2hlY2tib3hdLCBkaXYub2F1dGggbGFiZWxbZm9yPXBhc3N3b3JkX3NldF0gewogICAgZGlzcGxheTogaW5saW5lOwogICAgd2lkdGg6IDI1cHg7Cn0KCmRpdi5vYXV0aCBsYWJlbCwgZGl2Lm9hdXRoIGlucHV0IHsKICAgIGRpc3BsYXk6IGJsb2NrOwogICAgd2lkdGg6IDEwMCU7Cn0KCmRpdi5oZWFkICwgZGl2LmNyZWRlbnRpYWxzIHsKICAgIHdpZHRoOiAxMDAlOwogICAgY2xlYXI6IGJvdGg7Cn0KCiNicm93c2VyaWQgewogICAgd2lkdGg6IGF1dG87Cn0KCmRpdi5sb2dpbiB7IAoKfQoKLmhlYWQgaDIgewogICAgZmxvYXQ6IGxlZnQ7CiAgICB3aWR0aDogNjAlOwp9CgoKLnBpY3R1cmUgewogICAgZmxvYXQ6IGxlZnQ7Cn0KCmltZyB7CiAgICBib3JkZXI6IG5vbmU7Cn0KCi5sb2dvIHsKICAgIGZsb2F0OiByaWdodDsKfQoKLmNsZWFyIHsKICAgIGNsZWFyOiBib3RoOwp9"
        },
        "images/learning-registry-logo.png": {
            "content_type": "image/png",
            "data": "iVBORw0KGgoAAAANSUhEUgAAARMAAABxCAYAAAD24kddAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAGmhJREFUeNrsXUFy4zpzxkzNNvX0TvDoE4x8gX/kbTaWFllbOkDKViqVra1tKhVZlQNYXmdheZOt5FzAnBOY/wl+/ZUDvLA1H8YwDJAACJCUp78q1YwlkWo2Gh+6Gw1ACAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDEYJPrIKPj3/45/8elv9clq+sfN3/33/905q10pruR+U/9MpLvW+YTBjHbtAvIBKJGRNKK3q/Kf+5Vt66LfU+/6jP+6VnDK5jXyo/75PC/vN//kKj/EB//1/+8X93PfZKMu3t8/LFZJIel9rfV+WLySSicQ/g9n0rX0P8v+r7B1IhNxGvp/K1K0lmn5g0dDmNJKJ8X/53Bzm/l69NSTL7jtt44Pgeox3dCyaT5gQyLl8XdeRR0Sgy9rzCPSn+fKQOG5NYSlKgUXwJeUMwUp7xrrwfEcuqJ8TCaBe30l6Vvz8sPiUmkQwx4zghS1MHJWJZlKRSeJDbEu5/rsaxIJOXlHKWpFK01cAIH7fa2+TZnXFfb0X/Y3i1nIBt4Ilca6zc1kiwqPNUSvme0cASdM2NQih/JpaT8hXzNjwVJhPG0YY5pfFOMep3ES8SeU1LGWa2UQAZ9qH2NoVfN5oXkVJ+0tG4JC3yUo7C9dUS5IWrF+jguWba27lv2ArZ3iXr1fuXn+3q5LB9B4OjtBmvSQHl2srnSinD0XkmeNi7BrmG2CAymakNiAZ7NhFF+b1PimeyFWG5nRCQ8UxSeSmhngnacwqiHcYILxV5LqHfQU1IeF9FAgYvc11+f1Zhi2tdXgx+d8rvnsrP8dml4fmlfPMaghjj3gNcYxzkUsqg/c5QuddQuQ/p+FEtF0A7PUD2g15bIRMI+WAYZboGNciEWBwGtrV0DIEGzDsgE9mgZyWh5H0gE60TOIWXdfUTIPK7AL1aDRlyPujtCM94VKHrE9kBDTU4h1AZ9x25tJvNSzCE0+TRnRi+l0wGz7RDDsLLDTKd1RH754jG2jciEZBpC7JbVhCJ0DrOU8tyHoiuJLFpD8KZqTIiOYeX5XV3Ncb8HEjQU4SmJpjac1nzOwPtOt1upT2PHNvtAc/nIl9WYadJZFAGUZf85VDpLyaZRDIygeFtRb/n06UhTx2Ip2s577okFBjRnSUUI++AvJmJMBe8UadfWm5tyqHtMQJPcF96zTE66rj0eAyXDljUdCg1BFjDS7jF3ya7id1mMWW4rhhEC/FaF/VmYAsR+ksDwxtZDO9YkWnuXlcgQtmXIU8X04hLxzBjU7b/k6H9yUNZGXIoU0fXfFdevwb5q+0xIHurc7M1zCH7HiRJIdHX8rVyzPHkkFHNuS0MshHORZoakkYyILS8spDITNUnvivrq4Kcg8+BRDI0xKoxsNNebeIPzdh95NwnIJRhB16JPqoXtnwFknXrQC9iYovx0XHuHUOaqhzOreyE9Fs09V++Jo6EVOidWJFt1VA2V8SQ4dqSYznV9UAES/oRDZZZfAkwukFATG1T1kbUlMcr5ffnIm3xW2Zxg2XWnKptd7ZZF638ftwwbDrouLznaYtVsxeG9xY11ywMXsdYvF9/sla+d+vQoXeGjuDT7quGuqiqVdpZ2is2YshgCvnqZn/mof0sJMy5a9hRdnA1ndx4PPgGrxnyNKFl+XUd+ACqUC07MhEK1YE4MTU6vZRzXl4/Fq9ToKHkdoecQhsYOhrtm9EMa6cqc0+YrqUOPqip9xgqA0fwIBWhBqaoeObc8Mwp0EgGDMKmfrqp629YqjJNSiaYihs3UM68aUmxdK8TFMcNNXI4aXIz5Dw2IJVlIAFTYdvUldASkMnUoeMULs9mKSiTiUa5mHKQshN62FjbIXYKGUzt6VoQ+JSUTJRCoBC8KyCLoOw1GLRPhXJGUikJYQdCmQbcYlle38YiwYFjzF2HqiKuKbyOUcJwtRAM77aJoUMfz+Qq0ADIG4me6Vaq+UYx75miTBlEMCtJ4SmAkGXB0bHsg7Ew6JW8kAdRn6gsEFr9NZDIBK5ldIAvjp1sIPzm+iWi7uilrEIeiTR1IUnrZShcwb4nvoRyVV63anO1sY0Y6ohAz1coRVOZJSfzhH9zpSp11IBMGHYvZJCyH7h6JiFeySIBkTwn7vBZ6hYGocgtEHxwmdg72Rm8vNsIoemVQa/k/U1iLBZkWNMApiTtkMjdoU2/hfzmZw9D9sqRqEv6I2Eq0lfaZm00NFYK+yaipyChVDB1bOcQsjTSK7x0GU1TznVEMmI6iDZA6Bg7RCHTJGSCGRwfIz7kB1py244ZM+GX6BqItInmx5BBhIwPC9qWyquSoB08kgvmgWRtuqxYSyREgxlSF8/Et2HnifZnXYv0Ze7f2mplJGUXnpedp5IHU/Z6Jx+Rt1FBJEPxfiV2rXeHWR3bZ7Y6pm/MDUF9Zm8YlJ71DdwpjVC+HkSDdUYuORMfl7NIdYQCCOq0Yn+HowPyJz7PknoKnHIyD4aRjDryQs50KWtdLg2jmF4KvzHIvUQ8v0GRVAY7u64gIw59AvoM1vKYvEVaHVxgANFXUgdtDva5ZgQZed500YKCaPEW7VlxZmHeJuiCoLxKv0vyGSXULXX8WwuJ0Wj2J73Ej0T4tcE2NobBZGUJ2cgD+Rvu9yLeVlYXphDQchwKo7pNb4V9vY0k8Td7roSmKerCHJ/Gk+XkbSlph0VoJ3j4GCFQ61spoLrVhxB9O1Th+J7U6zxwUFhjodi7dhJ+K2rJhk6FeeZq1OTZHPVTRLwm9veCrkE/cWmDHLrPUpDJV497JT/LxubKKd7KqbDv+eCEmuRUKviQ8DdP/RSG+9/XXHMDXa4dZT+r2tYPBDWp6SQ73GeCNtW9pL1Bno3W1kXAgLYK8BQXjvp0vXdKGdQ2OIFOc4MTQDVhp+jDQX3gU03HevZw/Xt15CRmoS4C8gxnba/NwIZIroVsRci6IeSaMngQhcd1Mp7W186QjkI3fx5po2Fuk6lObm0qcx0yoCky7Vzb3vWa2N/zvcZ1Q2vtmhvxvmiwtn/XkYnPkQ+nfdwxG8k9mSzMekomQ+QhXEMjPiOa4WL7crZNbmh95tJHMaM29e0Xn2MJ3kcikW4+Nso5UVz3KoZuPQmbYiNpBkO83Zekbr9a1ZMZG/pR7QD7+VfSLHbcInftd/EjaWuKr7vaz9bZPW97FzbGhwF55lt46zYv3rSns1P64ktNPOaKogvNlJ1KFlRtfBfBKfui6OfD/NZRQ+fCfaaGDx73txXSbdHBYskusRbva4HIxl+wfcd35f1vFfa3akQmwm9GpCvjlsvzD3t+lP8++m4khKQUZbhvEWPyqP+xSESOthn+Xpc2MutIDlmUt2pjw3DshEezOHeWEMhlcmLmmsL4HCkH0oeR8nBwVNlofytfQRsyIwxadyR/7z3BI4VeVTvtKEyUperUzg/Yga+N0J7smXKFO89LycYmPv3hy5Ebyk6YNx6ewmgKuGibj+Te/mKueow8QaeDH8jLdL51K0WecAzOlGUQpm0y9wi16fUUsr1qNDIJONekLUNaNgmDWoznGWnwpHl9stO0HY537s2DVJI9e91sjg85dOE6+ozQjcOghPCRhaeR/by4G/GjNJ9smQaSsxaPD/ml8CViZ011qlmlu49tEH1HCRkGUcekMuR1xwbmUyLPIY6/ndy2bZu/Iuo8k+8e9xrZ5q97DHmgufRWWt/lHrun+fzudzZbxjF6JjvP+9GIf9PyM+xEnL0upLdSKN5KG17Alef3vRJj5fMs8Rvkec1lzgg1OuoSA9LjfV1OSSG/c5BxprUFeXtBm19j+pTa4auSUzgkBPWpVMh/juea1Zy0KI8ZKaCDjYMsU8sz5rgP7WJWewSJJfl68JCVXJmx/gWyP8C+6fMJVUvj/WvxupXpHronve+0e9yI1x3z5q45Q8Vufv5u3TW1azxKb+NFuC9Jpoc6aXP1cPnQW5Fu4xxS/CIVqcAonn30W8ryu8f9TWt+TmBcNhLLy984tdzvSpj3MbHpbu4SPkIPdecfFSCNHTrhViXY8v1JhcxL3UYryEeeo5052vsCYZTpXj4LZef6fQyyHxZ51tz3tvzOHNfrehJ49qKmPcbi7SZZTotLXcrpfbyTQcBI2xQpvQdi/meMmKm8Ep97+07XmTrnZU0bDU2zSxQGCr/9QUl327pNsNF5XxxCvQz3mxoGj6rB5Nxgo8Ma8s087H0J3bh6JK5ymt7L4DEMHT3dkaVd6nBheE4Rg0zuPQ34GvPZbSH1oUvBu3U7dCLfXf8fWwqr9gZX2aQDcn0XeG0sOSkroShuvM806Z2FIGLgwTTSix+7+tFrZhlcpzoBIyzwmXm7j9R+e6196ojCFGqOQxyK2joTqh3BXpE+I+hdec1ZF5slJcI+MpFIt96nExSRS7A3MOA9Or3MD6zU+FgpA9cx0+NvEKS+UGyIDnDj4ZnlCB82GvFOlXvGJvexQZYzPQdB4Rs8kanBO9pphHIKkhmK9/uw0jPOldDS18ZulcFFPXJ1rvz+BjnATPNuhhU5kHHoIOZatLYQfqfQDfH9SQsdfSfSnv6WC8dVkx5YBnSIVUydaTmGnbBPnZp0uzAl8pAcnBji9EudTECoJs/sXf4Dhh96vKqPzerPYxyRaW0PShKmdeE2cjy2/NcuUNYF6mdcPId7QxteVHhNF4aB1GkQc9qCAPX5vrmJMTZZOVZPZI3R9zRmDYplVHOVJxZ8TgYcG2Sx1mygg+jGPTBMu48MnlnlmUsgsHVbRmDKhaiEIl6L4eYtVlbvNSKpw9rR+5Be6NBA7k7271NO7+udHJgbS/xnCUOePPK9VikMQ5uiDBmJ9hGNMXeU2dThdw6y6CXscuTfVHkCjoa7SpHDgmzXllyIXIqhhzFdFMN5eTMo7NSPG7GFOuMGuRx3MiHvpCSGkPNqSEA643SSYjc2Mr6AKlgbBiLB7BBi/rvAWD+3TT22QL6mfMY+0lqibxYSqmtvCqWCNz2uue/OQIIZcjtXsLOdeK0xKUT7CClafDQQhSnU0UOcwicU891pLXQfCGoQOndlGWP3d8M9YjUqyblFNWwWwxvBVN6zCE8axj6sfN+QTKbIiVS9QnNYru2Yan3SxOHeI3iYL1Tj1MEiTW8P1XKcytghxPGayfUiE3gWTQ7aIoZ/AalkASQyRB7mJRGZqB3mJXRBIDUMSORFNKu7WTRI0sUc2WJgLXoO8nJRsDd3tKmRHHxaFDOPpP9Ms+3Lpm3mvQUBnamC4yJDGVkWtl2V98nhNpJ7u9e3MFBOFPwGJs3Uz1rY8mAqXkvsN1JOQ8myLLmWeokxdbnzTLS1hcKTvEln62Pag0XmQpA0ltOuVYMf2YjoYgc3D6wMA5sa6owN9lckJRPFHdxG6DSySvAKBBF6nyeR9izan3EzyKON0WfSAwM0jYL3kUjO1GYj4ZZgHLVEKhsMIjIMGIFcxhZCWfX1pAEkYvWcED3HXBkMg0OcYDLBgcgT5AK62rJxKPwXIh4DKheudeCF6HDeLgEzWIcDoAzPY+p01FFvau45TfGgkPUKz/duj1aM0uT2ryvW74xFv/ebudfIJEPOR68o3ofMaAYfdYHT1c5E5OpQz3Dpp0sW2DH6SCRnfRndIIeut5FLclpZ50Ie7IuhpN7UZsOqbSCU1bIpIBcxUueqTMBDLwtxfNgY+qvp1MugSutG5+YgIXvSERv/4fFdavjTno8aeZ+IpMbdvashkpFQdoQXhsV18FRMo59xXxl9l/kE+KYNVHVJ1X3DAat1jx463xi8qcyQX/FG4z1gEfKcifol5CnyGFUu80+WlTF+aZAkZ2jhWErQKD3p6XaClIzUz14ZYeuHmZqkU0KFa0PHyy0kP9bufVj8h13w5JqQry3Ylp7DoWd8MIWcFR7SzsMrPqzORrl9Bntu41wfvejvXZlF6IAWZUNpVLdOSlLR919oJcypKFx7U54No6B1Fd+F+74cqbHo6ayNqlvTepsRwpccerYu7ReWfU2QFLSd62Jbwr9Gxxu1QJpjkAqRxHfFIx4bbOfWRgR4TlOh3Va3WxrwEpQDvAnR0GbDCrIJQtTjQelMX4Q9uxbsfOgwKtiM+FaEnSUS2xs5TUwke8f36gxwB1LeW9phVEMk64p7r4V7MSR9d+4Z6jjpAHZiygHKneWuxdvdzfQQtS6Hsgmw6yjt50kYm16QCQiFDgqnRpmIdpOeuoLWNUZM7pzcp6JNOQu4zm3kRzYGQwwyFujy1OP6HXJAt473PhH2Q+Vz6EyGHD5koud8cpve8f6pcC/WkjutuSwGnYv6nF2h/fajq+wN7UJNCQT3hU+pe04Z+hCTX4g0tQFnauEaEndDxH1rnxvh2kuRroaB5Lxv+9weJENldeMqhgutbKDzhzaSFggHGhklZoIGSgfScxZ/6p26ajtLTCdfQD6nbTiVupKvBm/hO+TaBDwbyfJNvM/5fTfZRojsjnKYlnjMmtjnp7aMGuXzpJhz0bzY7ecRFbFXIysd5SKSnDsRuMHyRwc6ytIlHFKuIZL5m07U8DIZ7gPM1oeQXdDa8aCoS6H8wA0W6sk4W07JjSxuZK6OBmQ4KXdwQ6eX5dSqnHLH9KEwJ27liP8EOXMmkFqoiVeaEnZZpTq2kDbDHReWfFQjfGK9MjocIf80DB7WXJJlW0ghzNsrMty9EsJJ08GPyYTRpWHbjimhUfJRvCZjM3iwU5NXYjuag/X7l7HihZBn/5swz0ZFCRO/sMoZHYKmhE3ru6bCrbCwcptHxptNy8c17dAYn1nfjK4Atzq03qcQ/Vx+0Ce4FGXOYuX2OMxh9CmWlyUEWYUnQsTz2PYU+5HqlLw728FppMeom28xmTD62AlMpfl5T9cuHYM+38xAcrKawWAwGAwGg8FgMBgMBoPBYDAYDAaDkQD//h/LEb1YHn5W1uXHRhsVsCPR0jknRyoPPyvrksnkSLEWR3BU5RGO3FeshV8bv9xCv3/713nBzR4/BBA/Nr26ZW2wZ8JgMBjdeSbliJSJ16Xim3LUz2u+T2sExim+T6Nj+flOGSnptZPvaTIbPRR5j/JfuSM5fbfAb+89ZFXxToYafVq9J/oNmw4gc1bxeXTdKwnJw9oP5e/CxwPEbxU2Hdc8d1V7yj2BD+FtKq8U8u/V+6ty+epeaU9pg3tcVwS0ewbZ9nX9pjPPpBSCSETu2ESbrjyU7y0rvk97K6jb9D3gPaMCytez6/eBrSLXBWTaGmL5qbDvlbFFw9Nvy+0k6d8XvG9s9PK1VWSlTZbpSISvgardVnz2II3UgKWw7FmbUPfy+IcLGL38e+T5zENhOW8Jz/vgoy+0ybN4e1DWtso+G/SDG+hqb7IzH91rfetFsUGyqWfTdSCJKru4tgxyal/pzjOB4NQwJwrjzSumzmh39EX53Zlyj1soyMSMxLZz9X18nzr1qoKFx1DwDH/fC/+Dtui5zrRR5rt839JYhfZsKxjQrM6j0fM55bX0mpb/XxuebQBdzg3tMdbfT6378v9niodyLf8OAO3yvizvszCMvpfwesblZxtDZzB5QUQwj+X7N8p7N9QZqfNr7zchErn50JmlnX11L5+JrjvVbHABHd2p9wPuYYczi3dDZL222G60zaVCPRMy3lxXYIW7RK7+rYFRVyZmJIPV74Xv5zXkMFQ7oek+DpjrxgnZhxb2p8Zf6PJD1pAjLVeW0eJCvD/aUZVhbTHotnQfDNx/XfFsdTrRO+PeQhhz8XrsRxMSkd4oyT6pGDC8dI/OT4PWxGCDe8hvqneh3xjjel13G5Dx0BCi7mOFOMFkAgGGHtOB3y3v58LxQCU8fJ0x30Yw7NxT1oElFv+rCDhkG6NvpjY+SGyEDrJDh9FHwFXHum+Kld7R8Zw7PPdIJXPoJ9O9FRkakAeiv8SPc5D3tpDVwyuXns8sst3LPF9RQbqkp3PD+xsDGUu7WBlItMpm2s2ZwOU/L5X7gsaKamxgf7ovuYQvcMkyhxGubeSGzi1HzSJSx5oqbuq9OqopHa7oUvcRSLwwEOWFeD2RT/dcbJ0hq9H7vQg/YvM35NMedY8jEoYVBKQS0bDOZhTPI4fufnouyuC07gWZwB2Wx2v+UZWkDDFmsP8fcPlO8Ft93O9TxrJjJYH5oOQCQrDW3Naf7rziuWQpRpiOdf+zQ+D5VM/jZ2ig5AJsneGevJmKVyjx/h05hou+ldaDNApph5rNSM9lnMoraeqZ/BxR4O7R2cIPkeS6xmg763uRGYx9BkKhc2BepOcW6ikpOYQrGIeeZKTR9VKGHzHj3i51r03tXypeifRcZGehcMU2Xf+khwEJ2pts/c7ikTbych1kP68g9hXsQpLtxmAzA83T7Q+ZaIYQyxUmD+dRHA+GaDgild+RlGvaEeUorbr6QnP5L4WW/P0AupfPbTJ4GeJVPfdBN7awO0Y4Di/gFJ1zGZmoBjavRyGCVVW+TfxI4r4hW/TPgfJZ0QsyoXBGZ2UkY2ONkLmWFxgggTZS8gS9AEK787JxaBZoHStvI3MIpti26rOOdL/XB5LQTovnGZnyQFWfabqhzra1zGBsI7XPHiE+6echYs7Q6PXgWUj2eQ0RrCoIp+qzxgitgC3AyncwaqnIWIdHL2AML/itDAog5r1rkItIAZJvr8gqz0UuhEPlrMMobTOcR4dkXSu6p5G6/P5OuWYIW8gbPLft2o3BU9PloeTxHs8h22QI2eYRPYnDIWDwTui3zpoOJtDlBGHzNWQe4LVwGDzWGNxyi+7OXSpwQ9DoqAuwsSwlji4g2HigxNKZMvr0xTMZKXHu3/Hvb4hZ901yJz3wuLx0L68RhhqkjttHCM8S/57InoHM96kIoDdk8qtDVn6KH7Mee8Pnsh6BV9MyPjx41XAzEJk8VYzCyapGGQwmk48FCgEuTPU18FqmgjdiYvwi4DCneagzFa+rU2VMfsgjiR8L/XasJQaTCcOHVDLxOj1a8I5uDAaDwWAwGAwGg8FgMBgMBuP/BRgAZRDki4tS2fUAAAAASUVORK5CYII="
        },
        "modules.js": {
            "content_type": "application/json; charset=utf-8",
            "data": "LypnbG9iYWwgd2luZG93OiBmYWxzZSwgJDogZmFsc2UsIHBhZ2VUcmFja2VyOiBmYWxzZSwga2Fuc286IHRydWUgKi8KCi8qKgogKiBDb2RlIHJlcXVpcmVkIHRvIGJvb3RzdHJhcCB0aGUgYnJvd3NlciBDb21tb25KUyBlbnZpcm9ubWVudC4KICovCgooZnVuY3Rpb24gKGV4cG9ydHMpIHsKCiAgICBleHBvcnRzLm1vZHVsZUNhY2hlID0ge307CgogICAgZXhwb3J0cy5ub3JtYWxpemVQYXRoID0gZnVuY3Rpb24gKHApIHsKICAgICAgICB2YXIgcGF0aCA9IFtdOwogICAgICAgIHZhciBwYXJ0cyA9IHAuc3BsaXQoJy8nKTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gJy4uJykgewogICAgICAgICAgICAgICAgcGF0aC5wb3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1tpXSAhPT0gJy4nKSB7CiAgICAgICAgICAgICAgICBwYXRoLnB1c2gocGFydHNbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBwYXRoLmpvaW4oJy8nKTsKICAgIH07CgogICAgZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHApIHsKICAgICAgICBpZiAocCA9PT0gJy8nKSB7CiAgICAgICAgICAgIHJldHVybiBwOwogICAgICAgIH0KICAgICAgICB2YXIgcGFydHMgPSBwLnNwbGl0KCcvJyk7CiAgICAgICAgcGFydHMucG9wKCk7CiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSAmJiBwYXJ0c1swXSA9PT0gJycpIHsKICAgICAgICAgICAgcmV0dXJuICcvJzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTsKICAgIH07CgogICAgZXhwb3J0cy5jcmVhdGVSZXF1aXJlID0gZnVuY3Rpb24gKGN1cnJlbnQpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgewogICAgICAgICAgICB2YXIgcGF0aDsKICAgICAgICAgICAgaWYgKHRhcmdldC5jaGFyQXQoMCkgPT09ICcuJykgewogICAgICAgICAgICAgICAgdmFyIGRpciA9IGV4cG9ydHMuZGlybmFtZShjdXJyZW50KTsKICAgICAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLm5vcm1hbGl6ZVBhdGgoZGlyICsgJy8nICsgdGFyZ2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLm5vcm1hbGl6ZVBhdGgodGFyZ2V0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgbSA9IGthbnNvLm1vZHVsZUNhY2hlW3BhdGhdOwogICAgICAgICAgICBpZiAoIW0pIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBtb2R1bGU6ICcgKyBwYXRoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIW0ubG9hZGVkKSB7CiAgICAgICAgICAgICAgICBtLmV4cG9ydHMgPSB7fTsKICAgICAgICAgICAgICAgIG0uaWQgPSBwYXRoOwogICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvcGVydHkgbm90IHByb3ZpZGVkIGJ5IGNvdWNoZGIsIGJ1dCBpcyBieSBub2RlOgogICAgICAgICAgICAgICAgLy9tLnJlcXVpcmUgPSBleHBvcnRzLmNyZWF0ZVJlcXVpcmUocGF0aCk7CiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwcm9wZXJ0eSBub3QgcHJvdmlkZWQgYnkgY291Y2hkYiwgYnV0IGlzIGJ5IG5vZGU6CiAgICAgICAgICAgICAgICAvL20uZmlsZW5hbWUgPSAnJzsKICAgICAgICAgICAgICAgIC8vIFRPRE86IG1vZHVsZSBwcm9wZXJ0aWVzIHByb3ZpZGVkIGJ5IGNvdWNoZGIsIGJ1dCBub3QgYnkga2Fuc28KICAgICAgICAgICAgICAgIC8vICogY3VycmVudAogICAgICAgICAgICAgICAgLy8gKiBwYXJlbnQKICAgICAgICAgICAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgKmJlZm9yZSogY2FsbGluZyBtLmxvYWQgc28gY2lyY3VsYXIKICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVzIGRvbid0IGJsb3cgdGhlIGNhbGwgc3RhY2sKICAgICAgICAgICAgICAgIG0ubG9hZGVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgIC8vbS5sb2FkKG0sIG0uZXhwb3J0cywgbS5yZXF1aXJlKTsKICAgICAgICAgICAgICAgIG0ubG9hZChtLCBtLmV4cG9ydHMsIGV4cG9ydHMuY3JlYXRlUmVxdWlyZShwYXRoKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG0uZXhwb3J0czsKICAgICAgICB9OwogICAgfTsKCiAgICBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgLy8gbWFrZSByZXF1aXJlIGF2YWlsYWJsZSBnbG9iYWxseSwgdW5sZXNzIGFscmVhZHkgaW4gYSBjb21tb25qcwogICAgICAgIC8vIGVudmlyb25tZW50CiAgICAgICAgdGhpcy5yZXF1aXJlID0gZXhwb3J0cy5jcmVhdGVSZXF1aXJlKCcnKTsKICAgIH0KCn0oKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJykgPyB0aGlzLmthbnNvID0ge306IG1vZHVsZS5leHBvcnRzKSk7CgoKLyoqCiAqIENvbW1vbkpTIG1vZHVsZXMgYXJlIHdyYXBwZWQgYW5kIGFwcGVuZGVkIHRvIHRoaXMgZmlsZS4KICovCi8qKioqKioqKioqIGxpYi9hcHAgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJsaWIvYXBwIl0gPSB7bG9hZDogKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUpIHsKCgoKfSl9OwoKLyoqKioqKioqKiogbGliL21hbmFnZS10b2tlbnMgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJsaWIvbWFuYWdlLXRva2VucyJdID0ge2xvYWQ6IChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzLCByZXF1aXJlKSB7CgoKdmFyIHNlc3Npb24gPSByZXF1aXJlKCJzZXNzaW9uIiksCiAgICB1c2VycyA9IHJlcXVpcmUoInVzZXJzIiksCiAgICBfID0gcmVxdWlyZSgidW5kZXJzY29yZSIpLl87CgpmdW5jdGlvbiBsb2cobXNnKSB7CiAgICB0cnl7CiAgICAgICAgY29uc29sZS5sb2cobXNnKQogICAgfSBjYXRjaCAoZSkgewoKICAgIH0KfQoKCmZ1bmN0aW9uIGdldE9BdXRoKGVtYWlsLCBkb2MsIHJlZ2VuZXJhdGUpIHsKICAgIGlmIChyZWdlbmVyYXRlIHx8ICEoZG9jLm9hdXRoIAogICAgICAgICYmIGRvYy5vYXV0aC5jb25zdW1lcl9rZXlzIAogICAgICAgICYmIGRvYy5vYXV0aC5jb25zdW1lcl9rZXlzW2VtYWlsXQogICAgICAgICYmIGRvYy5vYXV0aC50b2tlbnMKICAgICAgICAmJiBkb2Mub2F1dGgudG9rZW5zLm5vZGVfc2lnbl90b2tlbikpIHsKCiAgICAgICAgZG9jLm9hdXRoID0gZG9jLm9hdXRoIHx8IHt9OwogICAgICAgIGRvYy5vYXV0aC5jb25zdW1lcl9rZXlzID0gZG9jLm9hdXRoLmNvbnN1bWVyX2tleXMgfHwge307CiAgICAgICAgZG9jLm9hdXRoLnRva2VucyA9IGRvYy5vYXV0aC50b2tlbnMgfHwge307CgogICAgICAgIGRvYy5vYXV0aC5jb25zdW1lcl9rZXlzW2VtYWlsXSA9IGV4cG9ydHMuZ2VuZXJhdGVTZWNyZXQoMzIpOwogICAgICAgIGRvYy5vYXV0aC50b2tlbnMubm9kZV9zaWduX3Rva2VuID0gZXhwb3J0cy5nZW5lcmF0ZVNlY3JldCgzMik7CgogICAgICAgIGlmICghZG9jLnJvbGVzIHx8IF8uaW5kZXhPZihkb2Mucm9sZXMsICJub2RlX3NpZ24iKSA9PSAtMSkgewogICAgICAgICAgICBkb2Mucm9sZXMgPSBkb2Mucm9sZXMgfHwgW107CiAgICAgICAgICAgIC8vIGRvYy5yb2xlcy5wdXNoKCJub2RlX3NpZ24iKTsKICAgICAgICB9CgogICAgICAgIHVzZXJzLnVwZGF0ZShlbWFpbCwgbnVsbCwgZG9jLCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgbG9nKGVycik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBnZXRVc2VySW5mbyhlbWFpbCk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICB9IGVsc2UgewogICAgICAgICQoIi5vYXV0aCIpLnNob3coNTAwKTsKICAgICAgICAkKCIjY29uc3VtZXJfa2V5IikudmFsKGVtYWlsKQogICAgICAgICQoIiNjb25zdW1lcl9zZWNyZXQiKS52YWwoZG9jLm9hdXRoLmNvbnN1bWVyX2tleXNbZW1haWxdKTsKICAgICAgICAkKCIjdG9rZW5fc2VjcmV0IikudmFsKGRvYy5vYXV0aC50b2tlbnMubm9kZV9zaWduX3Rva2VuKTsKICAgIH0KfQoKZnVuY3Rpb24gZ2V0U2lnbmluZ0luZm8oZW1haWwsIGRvYykgewogICAgaWYgKGRvYy5scnNpZ25hdHVyZSAmJiBkb2MubHJzaWduYXR1cmUuZnVsbF9uYW1lKSB7CiAgICAgICAgJCgiI2Z1bGxfbmFtZSIpLnZhbChkb2MubHJzaWduYXR1cmUuZnVsbF9uYW1lKTsKICAgIH0KfQoKZnVuY3Rpb24gc2V0TWVzc2FnZShtc2csIHdhaXQsIGNiKSB7CiAgICBpZiAoIXdhaXQpIHsKICAgICAgICB3YWl0ID0gMTAwMDA7CiAgICB9CgogICAgJCgiLm1zZyIpLmZhZGVPdXQoJ2Zhc3QnKS5lbXB0eSgpLnRleHQobXNnKS5mYWRlSW4oJ2Zhc3QnKS5kZWxheSh3YWl0KS5mYWRlT3V0KCdzbG93JykuaGlkZSgnZmFzdCcpOwoKICAgIGlmIChjYikgewogICAgICAgIGNiKCk7CiAgICB9Cn0KCmZ1bmN0aW9uIHJlc2V0Rm9ybXMoKSB7CiAgICAkKCIub2F1dGgiKS5oaWRlKDUwMCk7CiAgICAkKCIjcGFzc3dvcmQiKS52YWwoIiIpOwogICAgJCgiI3ZlcmlmeV9wYXNzd29yZCIpLnZhbCgiIik7CiAgICAkKCIjcGFzc3dvcmRfc2V0IikucHJvcCgiY2hlY2tlZCIsIGZhbHNlKTsKICAgICQoIiNjb25zdW1lcl9rZXkiKS52YWwoIiIpOwogICAgJCgiI2NvbnN1bWVyX3NlY3JldCIpLnZhbCgiIik7CiAgICAkKCIjdG9rZW5fc2VjcmV0IikudmFsKCIiKTsKICAgICQoIiNmdWxsX25hbWUiKS52YWwoIiIpOwp9CgpmdW5jdGlvbiBzZXRTaWduaW5nSW5mbygpIHsKICAgIGZ1bGxfbmFtZSA9ICQoIiNmdWxsX25hbWUiKS52YWwoKTsKICAgIGlmICgkLnRyaW0oZnVsbF9uYW1lKSAhPT0gIiIpIHsKICAgICAgICBzZXNzaW9uLmluZm8oZnVuY3Rpb24oZXJyLCBzZXNzaW9uX2luZm8pewogICAgICAgICAgICBpZiAoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSkgewogICAgICAgICAgICAgICAgdXNlcnMuZ2V0KHNlc3Npb25faW5mby51c2VyQ3R4Lm5hbWUsIGZ1bmN0aW9uKGVyciwgZG9jKXsKICAgICAgICAgICAgICAgICAgICBkb2MubHJzaWduYXR1cmUgPSBkb2MubHJzaWduYXR1cmUgfHwge30KICAgICAgICAgICAgICAgICAgICBkb2MubHJzaWduYXR1cmUuZnVsbF9uYW1lID0gZnVsbF9uYW1lOwoKICAgICAgICAgICAgICAgICAgICB1c2Vycy51cGRhdGUoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSwgbnVsbCwgZG9jLCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGVycik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlKCJVbmFibGUgdG8gc2F2ZSBzaWduaW5nIGluZm9ybWF0aW9uLiIpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZSgiSW5mb3JtYXRpb24gc2F2ZWQuIikKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfSk7IAogICAgICAgICAgICB9OwogICAgICAgIH0pOwogICAgfQp9CgpmdW5jdGlvbiBzZXRQYXNzd29yZEluZm8oZW1haWwsIGRvYykgewogICAgaWYgKGRvYy5wYXNzd29yZF9zaGEpIHsKICAgICAgICAkKCIjcGFzc3dvcmRfc2V0IikucHJvcCgiY2hlY2tlZCIsIHRydWUpOwogICAgfSBlbHNlIHsKICAgICAgICAkKCIjcGFzc3dvcmRfc2V0IikucHJvcCgiY2hlY2tlZCIsIGZhbHNlKTsKICAgIH0KfQoKZnVuY3Rpb24gZ2V0VXNlckluZm8oZW1haWwpIHsKICAgIHVzZXJzLmdldChlbWFpbCwgZnVuY3Rpb24oZXJyLCBkb2MpIHsKICAgICAgICBpZiAoIWVycikgewogICAgICAgICAgICBnZXRPQXV0aChlbWFpbCwgZG9jKTsKICAgICAgICAgICAgZ2V0U2lnbmluZ0luZm8oZW1haWwsIGRvYyk7CiAgICAgICAgICAgIHNldFBhc3N3b3JkSW5mbyhlbWFpbCwgZG9jKTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHNldE1lc3NhZ2UoZXJyKTsKICAgICAgICB9CiAgICB9KTsKfQoKZnVuY3Rpb24gcmV2b2tlQW5kR2VuZXJhdGUoKSB7CiAgICBzZXNzaW9uLmluZm8oZnVuY3Rpb24oZXJyLCBzZXNzaW9uX2luZm8pewogICAgICAgIGlmIChzZXNzaW9uX2luZm8udXNlckN0eC5uYW1lKSB7CiAgICAgICAgICAgIHVzZXJzLmdldChzZXNzaW9uX2luZm8udXNlckN0eC5uYW1lLCBmdW5jdGlvbiAoZXJyLCBkb2MpewogICAgICAgICAgICAgICAgaWYgKCFlcnIpIHsKICAgICAgICAgICAgICAgICAgIGdldE9BdXRoKHNlc3Npb25faW5mby51c2VyQ3R4Lm5hbWUsIGRvYywgdHJ1ZSk7IAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBzZXNzaW9uVGltZW91dCgpOwogICAgICAgIH0KICAgIH0pOwp9CgpmdW5jdGlvbiBzZXNzaW9uVGltZW91dCAoKSB7CiAgICBzZXRNZXNzYWdlKCJTZXNzaW9uIGhhcyB0aW1lZCBvdXQuIiwgNTAwMDAsIGZ1bmN0aW9uKCl7CiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpOwogICAgfSk7Cn0KCmZ1bmN0aW9uIGNoZWNrUGFzc3dvcmRNYXRjaCgpIHsKICAgIHZhciBwYXNzd2QxID0gJCgiI3Bhc3N3b3JkIikudmFsKCk7CiAgICB2YXIgcGFzc3dkMiA9ICQoIiN2ZXJpZnlfcGFzc3dvcmQiKS52YWwoKTsKICAgIGlmIChwYXNzd2QxID09PSAiIiB8fCBwYXNzd2QyID09PSAiIiB8fCBwYXNzd2QxICE9PSBwYXNzd2QyKQogICAgICAgIHJldHVybiBmYWxzZTsKICAgIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBzYXZlUGFzc3dvcmQoKSB7CiAgICB2YXIgcGFzc3dkMSA9ICQoIiNwYXNzd29yZCIpLnZhbCgpOwogICAgdmFyIHBhc3N3ZDIgPSAkKCIjdmVyaWZ5X3Bhc3N3b3JkIikudmFsKCk7CiAgICBpZiAoIGNoZWNrUGFzc3dvcmRNYXRjaCgpICkgewogICAgICAgIHNlc3Npb24uaW5mbyhmdW5jdGlvbihlcnIsIHNlc3Npb25faW5mbykgewogICAgICAgICAgICBpZiAoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSkgewogICAgICAgICAgICAgICAgdXNlcnMuZ2V0KHNlc3Npb25faW5mby51c2VyQ3R4Lm5hbWUsIGZ1bmN0aW9uKGVyciwgZG9jKXsKICAgICAgICAgICAgICAgICAgICBkb2MucGFzc3dvcmQgPSBwYXNzd2QxOwoKICAgICAgICAgICAgICAgICAgICB1c2Vycy51cGRhdGUoc2Vzc2lvbl9pbmZvLnVzZXJDdHgubmFtZSwgbnVsbCwgZG9jLCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGVycik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlKCJVbmFibGUgdG8gc2F2ZSBwdWJsaXNoIHBhc3N3b3JkLiIpOwogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZSgiUGFzc3dvcmQgc2F2ZWQuIik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCIjcGFzc3dvcmQiKS52YWwoIiIpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgiI3ZlcmlmeV9wYXNzd29yZCIpLnZhbCgiIik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCIjcGFzc3dvcmRfc2V0IikucHJvcCgiY2hlY2tlZCIsIHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9KTsgCiAgICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICB9IGVsc2UgewogICAgICAgIHNldE1lc3NhZ2UoIlBhc3N3b3JkcyBkbyBubyBtYXRjaC4iKTsKICAgIH0KfQoKCmV4cG9ydHMucmVnaXN0ZXJDYWxsYmFja3MgPSBmdW5jdGlvbigpIHsKICAgICQuY291Y2guYnJvd3NlcmlkLmxvZ2luKGZ1bmN0aW9uKGV2dCwgZXJyLCBpbmZvKSB7IAogICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBlbWFpbCA9IG51bGw7CiAgICAgICAgICAgIGlmIChpbmZvICYmIGluZm8ubmFtZSkgewogICAgICAgICAgICAgICAgZW1haWwgPSBpbmZvLm5hbWU7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5mbyAmJiBpbmZvLmVtYWlsKSB7CiAgICAgICAgICAgICAgICBlbWFpbCA9IGluZm8uZW1haWwKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKGVtYWlsKSB7CiAgICAgICAgICAgICAgICBsb2coZW1haWwpOwogICAgICAgICAgICAgICAgZ2V0VXNlckluZm8oZW1haWwpOwogICAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKCiAgICAgICAgfSBmaW5hbGx5IHsKCiAgICAgICAgfSAKICAgIH0pOwoKICAgICQuY291Y2guYnJvd3NlcmlkLmxvZ291dChmdW5jdGlvbihldnQsIGVyciwgaW5mbyl7CiAgICAgICAgcmVzZXRGb3JtcygpOwogICAgfSk7CgogICAgJCgiI2luZm9fdXBkYXRlIikuYmluZCgnY2xpY2snLCBzZXRTaWduaW5nSW5mbyk7CiAgICAkKCIjcmVnZW5lcmF0ZSIpLmJpbmQoJ2NsaWNrJywgcmV2b2tlQW5kR2VuZXJhdGUpOwogICAgJCgiI3NhdmVfcGFzc3dvcmQiKS5iaW5kKCdjbGljaycsIHNhdmVQYXNzd29yZCk7Cn0KCgovLyBTaW1wbGUgc2VjcmV0IGtleSBnZW5lcmF0b3IKZXhwb3J0cy5nZW5lcmF0ZVNlY3JldCA9IGZ1bmN0aW9uKGxlbmd0aCkgewogICAgdmFyIHRhYiA9ICJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIjsKICAgIHZhciBzZWNyZXQgPSAnJzsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKICAgICAgICBzZWNyZXQgKz0gdGFiLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCkpOwogICAgfQogICAgcmV0dXJuIHNlY3JldDsKfQoKCgp9KX07CgovKioqKioqKioqKiB1c2VycyAqKioqKioqKioqLwoKa2Fuc28ubW9kdWxlQ2FjaGVbInVzZXJzIl0gPSB7bG9hZDogKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUpIHsKCi8qKgogKiAjIyBVc2VycyBtb2R1bGUKICoKICogRnVuY3Rpb25zIGZvciBxdWVyeWluZywgY3JlYXRpbmcsIHVwZGF0aW5nIGFuZCBkZWxldGluZyB1c2VyIGRvY3VtZW50cy4KICoKICogRnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGZvbGxvdyB0aGUgbm9kZS5qcyBjYWxsYmFjayBzdHlsZS4gVGhlIGZpcnN0CiAqIGFyZ3VtZW50IGlzIGFuIGVycm9yIG9iamVjdCAoaWYgb25lIG9jY3VycmVkKSwgdGhlIGZvbGxvd2luZyBhcmd1bWVudHMgYXJlCiAqIHRoZSByZXN1bHRzIG9mIHRoZSBvcGVyYXRpb24uIFRoZSBjYWxsYmFjayBpcyBhbHdheXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gYQogKiBmdW5jdGlvbi4KICoKICogQG1vZHVsZQogKi8KCgp2YXIgZGIgPSByZXF1aXJlKCdkYicpLAogICAgc2Vzc2lvbiA9IHJlcXVpcmUoJ3Nlc3Npb24nKSwKICAgIHNoYTEgPSByZXF1aXJlKCdzaGExJyksCiAgICBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLl87CgoKLyoqCiAqIFJldHVybnMgdGhlIGF1dGhlbnRpY2F0aW9uIGRhdGFiYXNlIGZvciB0aGUgY3VycmVudCB1c2VyJ3Mgc2Vzc2lvbi4KICoKICogQG5hbWUgYXV0aGRiKGNhbGxiYWNrKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjawogKiBAYXBpIHByaXZhdGUKICovCgp2YXIgYXV0aGRiID0gZnVuY3Rpb24oY2FsbGJhY2spIHsKICAgIGRiLnJlcXVlc3QoewogICAgICAgIHR5cGU6ICJHRVQiLAogICAgICAgIHVybDogIi9fc2Vzc2lvbiIKICAgIH0sCiAgICBmdW5jdGlvbiAoZXJyLCByZXNwKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTsKICAgICAgICB9CiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcC5pbmZvLmF1dGhlbnRpY2F0aW9uX2RiKTsKICAgIH0pOwp9OwoKCi8qKgogKiBSZXR1cm5zIHN1Y2Nlc3NmdWwgaWYgdXNlcm5hbWUgaXMgaW4gYWRtaW4gZGF0YWJhc2UuCiAqCiAqIEBuYW1lIGdldEFkbWluKHVzZXJuYW1lLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBnZXRBZG1pbiA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYWxsYmFjaykgewogICAgZGIucmVxdWVzdCh7CiAgICAgICAgdHlwZTogJ0dFVCcsCiAgICAgICAgdXJsOiAnL19jb25maWcvYWRtaW5zLycgKyBlbmNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpLAogICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicKICAgIH0sIGNhbGxiYWNrKTsKfTsKCgovKioKICogRGVsZXRlIHVzZXIgZnJvbSB1c2VyIGRhdGFiYXNlLgogKgogKiBAbmFtZSBkZWxldGVVc2VyKGF1dGhkYiwgaWQsIHVzZXIsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlciBkYXRhYmFzZQogKiBAcGFyYW0ge1N0cmluZ30gdXNlciBpZAogKiBAcGFyYW0ge09iamVjdH0gdXNlciBkb2N1bWVudAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjawogKiBAYXBpIHByaXZhdGUKICovCgp2YXIgZGVsZXRlVXNlciA9IGZ1bmN0aW9uKGF1dGhkYiwgaWQsIHVzZXIsIGNhbGxiYWNrKSB7CiAgICBkYi5yZXF1ZXN0KHsKICAgICAgICB0eXBlOiAnREVMRVRFJywKICAgICAgICB1cmw6ICcvJyArIGRiLmVuY29kZShhdXRoZGIpICsgJy8nICsgZGIuZW5jb2RlKGlkKSArCiAgICAgICAgICAgICAnP3Jldj0nICsgZGIuZW5jb2RlKHVzZXIuX3JldiksCiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJwogICAgfSwgY2FsbGJhY2spOwp9OwoKLyoqCiAqIERlbGV0ZSB1c2VyIGZyb20gYWRtaW4gZGF0YWJhc2UuCiAqCiAqIEBuYW1lIGRlbGV0ZUFkbWluKHVzZXJuYW1lLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBkZWxldGVBZG1pbiA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYWxsYmFjaykgewogICAgZGIucmVxdWVzdCh7CiAgICAgICAgdHlwZTogJ0RFTEVURScsCiAgICAgICAgdXJsOiAnL19jb25maWcvYWRtaW5zLycgKyBlbmNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpLAogICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicKICAgIH0sIGNhbGxiYWNrKTsKfTsKCgovKioKICogU2F2ZSB1c2VyIHRvIHVzZXIgZGF0YWJhc2UuCiAqCiAqIEBuYW1lIHNhdmVVc2VyKGF1dGhkYiwgZG9jLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IHVzZXIgZGF0YWJhc2UKICogQHBhcmFtIHtPYmplY3R9IHVzZXIgZG9jdW1lbnQKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICogQGFwaSBwcml2YXRlCiAqLwoKdmFyIHNhdmVVc2VyID0gZnVuY3Rpb24oYXV0aGRiLCBkb2MsIGNhbGxiYWNrKSB7CiAgICB2YXIgdXJsID0gJy8nICsgYXV0aGRiICsgJy8nICsgZG9jLl9pZDsKICAgIHZhciByZXEgPSB7CiAgICAgICAgdHlwZTogJ1BVVCcsCiAgICAgICAgdXJsOiB1cmwsCiAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoZG9jKSwKICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsCiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJwogICAgfTsKICAgIGRiLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIENyZWF0ZSBhIG5ldyB1c2VyIGluIHRoZSB1c2VyIGRhdGFiYXNlLgogKgogKiBAbmFtZSBjcmVhdGVVc2VyKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZQogKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQKICogQHBhcmFtIHtIYXNofSBwcm9wZXJ0aWVzCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBjcmVhdGVVc2VyID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykgewogICAgdmFyIGRvYyA9IHt9OwogICAgZG9jLl9pZCA9ICdvcmcuY291Y2hkYi51c2VyOicgKyB1c2VybmFtZTsKICAgIGRvYy5uYW1lID0gdXNlcm5hbWU7CiAgICBkb2MudHlwZSA9ICd1c2VyJzsKCiAgICBfLmV4dGVuZChkb2MsIHByb3BlcnRpZXMpOwoKICAgIGRiLm5ld1VVSUQoMTAwLCBmdW5jdGlvbiAoZXJyLCB1dWlkKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB9CiAgICAgICAgZG9jLnNhbHQgPSB1dWlkOwogICAgICAgIGRvYy5wYXNzd29yZF9zaGEgPSBzaGExLmhleChwYXNzd29yZCArIGRvYy5zYWx0KTsKCiAgICAgICAgYXV0aGRiKGZ1bmN0aW9uIChlcnIsIGF1dGhkYikgewogICAgICAgICAgICBpZiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9CiAgICAgICAgICAgIHNhdmVVc2VyKGF1dGhkYiwgZG9jLCBjYWxsYmFjayk7CiAgICAgICAgfSk7CiAgICB9KTsKfTsKCgovKioKICogQ3JlYXRlIGEgbmV3IHVzZXIgaW4gdGhlIGFkbWluIGRhdGFiYXNlLgogKgogKiBAbmFtZSBjcmVhdGVBZG1pbih1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUKICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBjcmVhdGVBZG1pbiA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCwgY2FsbGJhY2spIHsKICAgIHZhciB1cmwgPSAnL19jb25maWcvYWRtaW5zLycgKyBlbmNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpOwogICAgdmFyIHJlcSA9IHsKICAgICAgICB0eXBlOiAnUFVUJywKICAgICAgICB1cmw6IHVybCwKICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShwYXNzd29yZCksCiAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLAogICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicKICAgIH07CiAgICBkYi5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBTYW5pdGl6ZSB0aGUgYXJndW1lbnRzIGJ5IGFsbG93aW5nIHRvIG9taXQgdGhlIHByb3BlcnRpZXMgYW5kCiAqIHByZWRlZmluaW5nIHRoZSByb2xlcyBpZiB0aGV5J3JlIG5vdCBzZXQuCiAqCiAqIEBuYW1lIHNhbml0aXplQXJndW1lbnRzKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2IsIGNiMikKICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lCiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZAogKiBAcGFyYW0ge0hhc2h9IHByb3BlcnRpZXMKICogQHBhcmFtIHtGdW5jdGlvbn0gY2IKICogQHBhcmFtIHtGdW5jdGlvbn0gY2IyCiAqIEBhcGkgcHJpdmF0ZQogKi8KCnZhciBzYW5pdGl6ZUFyZ3VtZW50cyA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2IsIGNiMikgewogICAgaWYgKCFjYikgewogICAgICAgIGNiID0gcHJvcGVydGllczsKICAgICAgICBwcm9wZXJ0aWVzID0ge307CiAgICB9CiAgICBpZiAoIXByb3BlcnRpZXMucm9sZXMpIHsKICAgICAgICBwcm9wZXJ0aWVzLnJvbGVzID0gW107CiAgICB9CiAgICBjYjIodXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYik7Cn07CgoKLyoqCiAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgdXNlciBkb2N1bWVudCwgZ2l2ZW4gaXRzIHVzZXJuYW1lLiBZb3UKICogbXVzdCBiZSBsb2dnZWQgaW4gYXMgYW4gYWRtaW5pc3RyYXRpdmUgdXNlciBmb3IgdGhpcyBmdW5jdGlvbgogKiB0byBzdWNjZWVkLgogKgogKiBAbmFtZSBkZWxldGUodXNlcm5hbWUsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBUaGUgdXNlcm5hbWUgb2YgdGhlIHVzZXIgdG8gZGVsZXRlCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkgLSBGdW5jdGlvbiBjYWxsZWQgb24gY29tcGxldGlvbiBvZgogKiAgICAgdGhlIG9wZXJhdGlvbgogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHVzZXJzLmRlbGV0ZSgndXNlcm5hbWUnLCBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICBpZiAoZXJyKSAvLyB0aGVyZSB3YXMgYW4gZXJyb3IgZGVsZXRpbmcgdGhlIHVzZXIKICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3MKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMuZGVsZXRlID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBjYWxsYmFjaykgewogICAgZXhwb3J0cy5nZXQodXNlcm5hbWUsIGZ1bmN0aW9uKGVyciwgdXNlciwgb3B0aW9ucykgewogICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0KCiAgICAgICAgZ2V0QWRtaW4odXNlcm5hbWUsIGZ1bmN0aW9uKGVyciwgYWRtaW4pIHsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgaWYgKGVyci5zdGF0dXMgIT09IDQwNCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZGVsZXRlVXNlcihvcHRpb25zLmF1dGhkYiwgb3B0aW9ucy5pZCwgdXNlciwgY2FsbGJhY2spOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgZGVsZXRlQWRtaW4odXNlcm5hbWUsIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGRlbGV0ZVVzZXIob3B0aW9ucy5hdXRoZGIsIG9wdGlvbnMuaWQsIHVzZXIsIGNhbGxiYWNrKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9KTsKfTsKCgovKioKICogR2V0IGEgc2luZ2xlIHVzZXIgYnkgdXNlcm5hbWUuIFRoZSB0aGlyZCBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgaXMgYW4gaW5mbwogKiBvYmplY3Qgd2hpY2ggcmV0dXJucyB0aGUgYXV0aGRiIHVzZWQsIGFuZCB0aGUgcmVhbCBpZCBvZiB0aGUgdXNlciB3aXRoCiAqICJvcmcuY291Y2hkYi51c2VyOiIgcHJlZml4LgogKgogKiBAbmFtZSBnZXQodXNlcm5hbWUsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSBUaGUgdXNlcm5hbWUgb2YgdGhlIHVzZXIgdG8gZ2V0CiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycix1c2VyLGluZm8pIC0gRnVuY3Rpb24gY2FsbGVkIG9uIGNvbXBsZXRpb24KICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiB1c2Vycy5nZXQoJ3Rlc3R1c2VyJywgZnVuY3Rpb24gKGVyciwgZG9jKSB7CiAqICAgICBpZiAoZXJyKSAvLyB0aGVyZSB3YXMgYW4gZXJyb3IgZmV0Y2hpbmcgdGhlIHVzZXIgZG9jdW1lbnQKICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3MKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgaWQgPSAnb3JnLmNvdWNoZGIudXNlcjonICsgdXNlcm5hbWU7CgogICAgYXV0aGRiKGZ1bmN0aW9uIChlcnIsIGF1dGhkYikgewogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgfQogICAgICAgIGRiLnJlcXVlc3QoewogICAgICAgICAgICB0eXBlOiAnR0VUJywKICAgICAgICAgICAgdXJsOiAnLycgKyBkYi5lbmNvZGUoYXV0aGRiKSArICcvJyArIGRiLmVuY29kZShpZCksCiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicKICAgICAgICB9LAogICAgICAgIGZ1bmN0aW9uIChlcnIsIHVzZXIpIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB1c2VyLCB7YXV0aGRiOiBhdXRoZGIsIGlkOiBpZH0pOwogICAgICAgIH0pOwogICAgfSk7Cn07CgoKLyoqCiAqIExpc3QgdXNlcnMgaW4gdGhlIGF1dGggZGF0YWJhc2UuIEJ5IGRlZmF1bHQsIGl0IHdpbGwgbGlzdCBhbGwgdXNlcnMuCiAqIEJ5IHVzaW5nIHRoZSBvcHRpb25hbCBgcWAgcGFyYW1ldGVyLCB5b3UgY2FuIHBhc3MgYWRkaXRpb25hbCBvcHRpb25zIHRvIHRoZQogKiBgX2FsbF9kb2NzYCB2aWV3IGZvciB0aGUgYXV0aCBkYXRhYmFzZS4KICoKICogQG5hbWUgbGlzdChbcV0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge09iamVjdH0gcSAtIFF1ZXJ5IHBhcmFtZXRlcnMgKG9wdGlvbmFsKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIsbGlzdCkgLSBGdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0aW5nCiAqICAgICBsaXN0IChvciBlcnJvcikKICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiB1c2Vycy5saXN0KGZ1bmN0aW9uIChlcnIsIGxpc3QpIHsKICogICAgIGlmIChlcnIpIC8vIHRoZXJlIHdhcyBhbiBlcnJvciBxdWVyeWluZyB0aGUgYXV0aCBkYXRhYmFzZQogKiAgICAgZWxzZSAgICAgLy8gc3VjY2VzcwogKiB9KTsKICogYGBgCiAqLwoKZXhwb3J0cy5saXN0ID0gZnVuY3Rpb24ocSwgY2FsbGJhY2spIHsKICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQogICAgaWYgKCFxLnN0YXJ0a2V5KSB7CiAgICAgICAgcS5zdGFydGtleSA9ICcib3JnLmNvdWNoZGIudXNlcjoiJzsKICAgIH0KICAgIGlmICghcS5lbmRrZXkpIHsKICAgICAgICBxLmVuZGtleSA9ICcib3JnLmNvdWNoZGIudXNlcl8iJzsKICAgIH0KICAgIGF1dGhkYihmdW5jdGlvbiAoZXJyLCBhdXRoZGIpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7CiAgICAgICAgfQogICAgICAgIHZhciByZXEgPSB7CiAgICAgICAgICAgIHR5cGU6ICdHRVQnLAogICAgICAgICAgICB1cmw6ICcvJyArIGRiLmVuY29kZShhdXRoZGIpICsgJy9fYWxsX2RvY3MnLAogICAgICAgICAgICBkYXRhOiBkYi5zdHJpbmdpZnlRdWVyeShxKSwKICAgICAgICAgICAgZXhwZWN0X2pzb246IHRydWUKICAgICAgICB9OwogICAgICAgIGRiLnJlcXVlc3QocmVxLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgdXNlcnMgPSBfKHJlc3VsdC5yb3dzKS5zZWxlY3QoZnVuY3Rpb24ocm93KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcm93LmlkLm1hdGNoKC9eb3JnXC5jb3VjaGRiXC51c2VyLyk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBjYWxsYmFjayhudWxsLCB1c2Vycyk7CiAgICAgICAgfSk7CiAgICB9KTsKfTsKCgovKioKICogQ3JlYXRlcyBhIG5ldyB1c2VyIGRvY3VtZW50IHdpdGggZ2l2ZW4gdXNlcm5hbWUgYW5kIHBhc3N3b3JkLgogKiBJZiBwcm9wZXJ0aWVzLnJvbGVzIGNvbnRhaW5zICdfYWRtaW4nLCB1c2VyIHdpbGwgYmUgbWFkZSBhZG1pbi4KICoKICogQG5hbWUgY3JlYXRlKHVzZXJuYW1lLCBwYXNzd29yZCwgW3Byb3BlcnRpZXNdLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIC0gVGhlIHVzZXJuYW1lIG9mIHRoZSBuZXcgdXNlcgogKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSBUaGUgdW5oYXNoZWQgcGFzc3dvcmQgZm9yIHRoZSBuZXcgdXNlcgogKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEFkZGl0aW9uYWwgcHJvcGVydGllcyBzdWNoIGFzIHJvbGVzIHRvIGV4dGVuZAogKiAgICAgdGhlIHVzZXIgZG9jdW1lbnQgd2l0aCAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkgLSBGdW5jdGlvbiBjYWxsZWQgb24gY29tcGxldGlvbiBvcgogKiAgICAgZXJyb3IKICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiB1c2Vycy5jcmVhdGUoJ3Rlc3R1c2VyJywgJ3Rlc3RpbmcnLCB7cm9sZXM6IFsnZXhhbXBsZSddfSwgZnVuY3Rpb24gKGVycikgewogKiAgICAgaWYgKGVycikgLy8gYW4gZXJyb3Igb2NjdXJyZWQKICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIG5ldyB1c2VyCiAqIH0pOwogKiBgYGAKICovCgpleHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7CiAgICBzYW5pdGl6ZUFyZ3VtZW50cyh1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrLAogICAgICAgIGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2spIHsKICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihwcm9wZXJ0aWVzLnJvbGVzLCAiX2FkbWluIikgIT09IC0xKSB7CiAgICAgICAgICAgICAgICBjcmVhdGVBZG1pbih1c2VybmFtZSwgcGFzc3dvcmQsIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnJvbGVzID0gW107CiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVXNlcih1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgY3JlYXRlVXNlcih1c2VybmFtZSwgcGFzc3dvcmQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKTsKICAgICAgICAgICAgfQogICAgfSk7Cn07CgoKLyoqCiAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdXNlciBkb2N1bWVudC4gU2ltaWxhciB1c2FnZSB0byB0aGUgY3JlYXRlIGZ1bmN0aW9uLgogKgogKiBAbmFtZSB1cGRhdGUodXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykKICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIC0gVGhlIHVzZXJuYW1lIG9mIHRoZSBuZXcgdXNlcgogKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSBUaGUgdW5oYXNoZWQgcGFzc3dvcmQgZm9yIHRoZSBuZXcgdXNlcgogKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEFkZGl0aW9uYWwgcHJvcGVydGllcyBzdWNoIGFzIHJvbGVzIHRvIGV4dGVuZAogKiAgICAgdGhlIHVzZXIgZG9jdW1lbnQgd2l0aCAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkgLSBGdW5jdGlvbiBjYWxsZWQgb24gY29tcGxldGlvbiBvcgogKiAgICAgZXJyb3IKICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiB1c2Vycy51cGRhdGUoJ3Rlc3R1c2VyJywgJ3Rlc3RpbmcnLCB7cm9sZXM6IFsnZXhhbXBsZSddfSwgZnVuY3Rpb24gKGVycikgewogKiAgICAgaWYgKGVycikgLy8gYW4gZXJyb3Igb2NjdXJyZWQKICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3NmdWxseSB1cGRhdGVkIHVzZXIKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMudXBkYXRlID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2spIHsKICAgIHNhbml0aXplQXJndW1lbnRzKHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvcGVydGllcywgY2FsbGJhY2ssCiAgICAgICAgZnVuY3Rpb24odXNlcm5hbWUsIHBhc3N3b3JkLCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykgewogICAgICAgICAgICBleHBvcnRzLmdldCh1c2VybmFtZSwgZnVuY3Rpb24gKGVyciwgdXNlciwgb3B0aW9ucykgewogICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKF8uaW5kZXhPZihwcm9wZXJ0aWVzLnJvbGVzLCAiX2FkbWluIikgPT09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgXy5leHRlbmQodXNlciwgcHJvcGVydGllcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAocGFzc3dvcmQpIHsKICAgICAgICAgICAgICAgICAgICB1c2VyLnBhc3N3b3JkX3NoYSA9IHNoYTEuaGV4KHBhc3N3b3JkICsgdXNlci5zYWx0KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBzYXZlVXNlcihvcHRpb25zLmF1dGhkYiwgdXNlciwgZnVuY3Rpb24gKGVyciwgdXNlcikgewogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHNlc3Npb24uaW5mbyhmdW5jdGlvbihlcnIsIHNlc3Npb25faW5mbyl7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uX2luZm8udXNlckN0eC5yb2xlcyAmJiBfLmluZGV4T2Yoc2Vzc2lvbl9pbmZvLnVzZXJDdHgucm9sZXMsICJfYWRtaW4iKSAhPT0gLTEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmluZGV4T2YocHJvcGVydGllcy5yb2xlcywgIl9hZG1pbiIpICE9PSAtMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUFkbWluKHVzZXJuYW1lLCBwYXNzd29yZCwgZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB1c2VyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFkbWluKHVzZXJuYW1lLCBmdW5jdGlvbihlcnIsIGFkbWluKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIuc3RhdHVzICE9PSA0MDQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1c2VyKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUFkbWluKHVzZXJuYW1lLCBjYWxsYmFjayk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgdXNlcik7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgIH0pOwp9OwoKCn0pfTsKCi8qKioqKioqKioqIHVuZGVyc2NvcmUgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJ1bmRlcnNjb3JlIl0gPSB7bG9hZDogKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUpIHsKCi8vICAgICBVbmRlcnNjb3JlLmpzIDEuMy4zCi8vICAgICAoYykgMjAwOS0yMDEyIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuCi8vICAgICBVbmRlcnNjb3JlIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4KLy8gICAgIFBvcnRpb25zIG9mIFVuZGVyc2NvcmUgYXJlIGluc3BpcmVkIG9yIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLAovLyAgICAgT2xpdmVyIFN0ZWVsZSdzIEZ1bmN0aW9uYWwsIGFuZCBKb2huIFJlc2lnJ3MgTWljcm8tVGVtcGxhdGluZy4KLy8gICAgIEZvciBhbGwgZGV0YWlscyBhbmQgZG9jdW1lbnRhdGlvbjoKLy8gICAgIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZQoKKGZ1bmN0aW9uKCkgewoKICAvLyBCYXNlbGluZSBzZXR1cAogIC8vIC0tLS0tLS0tLS0tLS0tCgogIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLgogIHZhciByb290ID0gdGhpczsKCiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS4KICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fOwoKICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uCiAgdmFyIGJyZWFrZXIgPSB7fTsKCiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjoKICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7CgogIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLgogIHZhciBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSwKICAgICAgdW5zaGlmdCAgICAgICAgICA9IEFycmF5UHJvdG8udW5zaGlmdCwKICAgICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLAogICAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7CgogIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZQogIC8vIGFyZSBkZWNsYXJlZCBoZXJlLgogIHZhcgogICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLAogICAgbmF0aXZlTWFwICAgICAgICAgID0gQXJyYXlQcm90by5tYXAsCiAgICBuYXRpdmVSZWR1Y2UgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZSwKICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsCiAgICBuYXRpdmVGaWx0ZXIgICAgICAgPSBBcnJheVByb3RvLmZpbHRlciwKICAgIG5hdGl2ZUV2ZXJ5ICAgICAgICA9IEFycmF5UHJvdG8uZXZlcnksCiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsCiAgICBuYXRpdmVJbmRleE9mICAgICAgPSBBcnJheVByb3RvLmluZGV4T2YsCiAgICBuYXRpdmVMYXN0SW5kZXhPZiAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLAogICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSwKICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLAogICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7CgogIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LgogIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7IHJldHVybiBuZXcgd3JhcHBlcihvYmopOyB9OwoKICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aAogIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW4KICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsCiAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgImFkdmFuY2VkIiBtb2RlLgogIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgewogICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfOwogICAgfQogICAgZXhwb3J0cy5fID0gXzsKICB9IGVsc2UgewogICAgcm9vdFsnXyddID0gXzsKICB9CgogIC8vIEN1cnJlbnQgdmVyc2lvbi4KICBfLlZFUlNJT04gPSAnMS4zLjMnOwoKICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9ucwogIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tCgogIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLgogIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLgogIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuCiAgdmFyIGVhY2ggPSBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7CiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjsKICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7CiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTsKICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHsKICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsKICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKSB7CiAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSByZXR1cm47CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfTsKCiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRvciB0byBlYWNoIGVsZW1lbnQuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLgogIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkgewogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7CiAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpOwogICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkgewogICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTsKICAgIH0pOwogICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXN1bHRzLmxlbmd0aCA9IG9iai5sZW5ndGg7CiAgICByZXR1cm4gcmVzdWx0czsKICB9OwoKICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsCiAgLy8gb3IgYGZvbGRsYC4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZWAgaWYgYXZhaWxhYmxlLgogIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkgewogICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjsKICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107CiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkgewogICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpOwogICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pIDogb2JqLnJlZHVjZShpdGVyYXRvcik7CiAgICB9CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIGlmICghaW5pdGlhbCkgewogICAgICAgIG1lbW8gPSB2YWx1ZTsKICAgICAgICBpbml0aWFsID0gdHJ1ZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpOwogICAgICB9CiAgICB9KTsKICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpOwogICAgcmV0dXJuIG1lbW87CiAgfTsKCiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuCiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7CiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyOwogICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTsKICAgIGlmIChuYXRpdmVSZWR1Y2VSaWdodCAmJiBvYmoucmVkdWNlUmlnaHQgPT09IG5hdGl2ZVJlZHVjZVJpZ2h0KSB7CiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7CiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7CiAgICB9CiAgICB2YXIgcmV2ZXJzZWQgPSBfLnRvQXJyYXkob2JqKS5yZXZlcnNlKCk7CiAgICBpZiAoY29udGV4dCAmJiAhaW5pdGlhbCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpOwogICAgcmV0dXJuIGluaXRpYWwgPyBfLnJlZHVjZShyZXZlcnNlZCwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIDogXy5yZWR1Y2UocmV2ZXJzZWQsIGl0ZXJhdG9yKTsKICB9OwoKICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuCiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7CiAgICB2YXIgcmVzdWx0OwogICAgYW55KG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpIHsKICAgICAgICByZXN1bHQgPSB2YWx1ZTsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CgogIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZpbHRlcmAgaWYgYXZhaWxhYmxlLgogIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuCiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIHZhciByZXN1bHRzID0gW107CiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzOwogICAgaWYgKG5hdGl2ZUZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHJldHVybiBvYmouZmlsdGVyKGl0ZXJhdG9yLCBjb250ZXh0KTsKICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTsKICAgIH0pOwogICAgcmV0dXJuIHJlc3VsdHM7CiAgfTsKCiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy4KICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIHZhciByZXN1bHRzID0gW107CiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzOwogICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkgewogICAgICBpZiAoIWl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0c1tyZXN1bHRzLmxlbmd0aF0gPSB2YWx1ZTsKICAgIH0pOwogICAgcmV0dXJuIHJlc3VsdHM7CiAgfTsKCiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuCiAgLy8gQWxpYXNlZCBhcyBgYWxsYC4KICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7CiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTsKICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDsKICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KSByZXR1cm4gb2JqLmV2ZXJ5KGl0ZXJhdG9yLCBjb250ZXh0KTsKICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHsKICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyOwogICAgfSk7CiAgICByZXR1cm4gISFyZXN1bHQ7CiAgfTsKCiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuCiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS4KICAvLyBBbGlhc2VkIGFzIGBhbnlgLgogIHZhciBhbnkgPSBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpOwogICAgdmFyIHJlc3VsdCA9IGZhbHNlOwogICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0OwogICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShpdGVyYXRvciwgY29udGV4dCk7CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyOwogICAgfSk7CiAgICByZXR1cm4gISFyZXN1bHQ7CiAgfTsKCiAgLy8gRGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5IG9yIG9iamVjdCB1c2luZyBgPT09YC4KICAvLyBBbGlhc2VkIGFzIGBjb250YWluc2AuCiAgXy5pbmNsdWRlID0gXy5jb250YWlucyA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7CiAgICB2YXIgZm91bmQgPSBmYWxzZTsKICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZvdW5kOwogICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xOwogICAgZm91bmQgPSBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkgewogICAgICByZXR1cm4gdmFsdWUgPT09IHRhcmdldDsKICAgIH0pOwogICAgcmV0dXJuIGZvdW5kOwogIH07CgogIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLgogIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHsKICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpOwogICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHsKICAgICAgcmV0dXJuIChfLmlzRnVuY3Rpb24obWV0aG9kKSA/IG1ldGhvZCB8fCB2YWx1ZSA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTsKICAgIH0pOwogIH07CgogIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuCiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7CiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB2YWx1ZVtrZXldOyB9KTsKICB9OwoKICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCBvciAoZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuCiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7CiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSkgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7CiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gLUluZmluaXR5OwogICAgdmFyIHJlc3VsdCA9IHtjb21wdXRlZCA6IC1JbmZpbml0eX07CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7CiAgICAgIGNvbXB1dGVkID49IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTsKICAgIH0pOwogICAgcmV0dXJuIHJlc3VsdC52YWx1ZTsKICB9OwoKICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuCiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7CiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSkgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7CiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gSW5maW5pdHk7CiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogSW5maW5pdHl9OwogICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkgewogICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlOwogICAgICBjb21wdXRlZCA8IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTsKICAgIH0pOwogICAgcmV0dXJuIHJlc3VsdC52YWx1ZTsKICB9OwoKICAvLyBTaHVmZmxlIGFuIGFycmF5LgogIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikgewogICAgdmFyIHNodWZmbGVkID0gW10sIHJhbmQ7CiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaW5kZXggKyAxKSk7CiAgICAgIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdOwogICAgICBzaHVmZmxlZFtyYW5kXSA9IHZhbHVlOwogICAgfSk7CiAgICByZXR1cm4gc2h1ZmZsZWQ7CiAgfTsKCiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLgogIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCB2YWwsIGNvbnRleHQpIHsKICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWwpID8gdmFsIDogZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmpbdmFsXTsgfTsKICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgdmFsdWUgOiB2YWx1ZSwKICAgICAgICBjcml0ZXJpYSA6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KQogICAgICB9OwogICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkgewogICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTsKICAgICAgaWYgKGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7CiAgICAgIGlmIChiID09PSB2b2lkIDApIHJldHVybiAtMTsKICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwOwogICAgfSksICd2YWx1ZScpOwogIH07CgogIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUKICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi4KICBfLmdyb3VwQnkgPSBmdW5jdGlvbihvYmosIHZhbCkgewogICAgdmFyIHJlc3VsdCA9IHt9OwogICAgdmFyIGl0ZXJhdG9yID0gXy5pc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9ialt2YWxdOyB9OwogICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkgewogICAgICB2YXIga2V5ID0gaXRlcmF0b3IodmFsdWUsIGluZGV4KTsKICAgICAgKHJlc3VsdFtrZXldIHx8IChyZXN1bHRba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7CiAgICB9KTsKICAgIHJldHVybiByZXN1bHQ7CiAgfTsKCiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGF0IHdoYXQgaW5kZXggYW4gb2JqZWN0IHNob3VsZAogIC8vIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guCiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yKSB7CiAgICBpdGVyYXRvciB8fCAoaXRlcmF0b3IgPSBfLmlkZW50aXR5KTsKICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoOwogICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHsKICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxOwogICAgICBpdGVyYXRvcihhcnJheVttaWRdKSA8IGl0ZXJhdG9yKG9iaikgPyBsb3cgPSBtaWQgKyAxIDogaGlnaCA9IG1pZDsKICAgIH0KICAgIHJldHVybiBsb3c7CiAgfTsKCiAgLy8gU2FmZWx5IGNvbnZlcnQgYW55dGhpbmcgaXRlcmFibGUgaW50byBhIHJlYWwsIGxpdmUgYXJyYXkuCiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7CiAgICBpZiAoIW9iaikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgaWYgKF8uaXNBcnJheShvYmopKSAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKG9iaik7CiAgICBpZiAoXy5pc0FyZ3VtZW50cyhvYmopKSAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTsKICAgIGlmIChvYmoudG9BcnJheSAmJiBfLmlzRnVuY3Rpb24ob2JqLnRvQXJyYXkpKSByZXR1cm4gb2JqLnRvQXJyYXkoKTsKICAgIHJldHVybiBfLnZhbHVlcyhvYmopOwogIH07CgogIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC4KICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7CiAgfTsKCiAgLy8gQXJyYXkgRnVuY3Rpb25zCiAgLy8gLS0tLS0tLS0tLS0tLS0tCgogIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTgogIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2sKICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuCiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkgewogICAgcmV0dXJuIChuICE9IG51bGwpICYmICFndWFyZCA/IHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pIDogYXJyYXlbMF07CiAgfTsKCiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjY2lhbHkgdXNlZnVsIG9uCiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW4KICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGgKICAvLyBgXy5tYXBgLgogIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkgewogICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7CiAgfTsKCiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTgogIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLgogIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkgewogICAgaWYgKChuICE9IG51bGwpICYmICFndWFyZCkgewogICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdOwogICAgfQogIH07CgogIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAuCiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKippbmRleCoqIHdpbGwgcmV0dXJuCiAgLy8gdGhlIHJlc3Qgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgZnJvbSB0aGF0IGluZGV4IG9ud2FyZC4gVGhlICoqZ3VhcmQqKgogIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC4KICBfLnJlc3QgPSBfLnRhaWwgPSBmdW5jdGlvbihhcnJheSwgaW5kZXgsIGd1YXJkKSB7CiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgKGluZGV4ID09IG51bGwpIHx8IGd1YXJkID8gMSA6IGluZGV4KTsKICB9OwoKICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuCiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHsKICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gISF2YWx1ZTsgfSk7CiAgfTsKCiAgLy8gUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS4KICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykgewogICAgcmV0dXJuIF8ucmVkdWNlKGFycmF5LCBmdW5jdGlvbihtZW1vLCB2YWx1ZSkgewogICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIG1lbW8uY29uY2F0KHNoYWxsb3cgPyB2YWx1ZSA6IF8uZmxhdHRlbih2YWx1ZSkpOwogICAgICBtZW1vW21lbW8ubGVuZ3RoXSA9IHZhbHVlOwogICAgICByZXR1cm4gbWVtbzsKICAgIH0sIFtdKTsKICB9OwoKICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS4KICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkgewogICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTsKICB9OwoKICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeQogIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS4KICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLgogIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvcikgewogICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvcikgOiBhcnJheTsKICAgIHZhciByZXN1bHRzID0gW107CiAgICAvLyBUaGUgYGlzU29ydGVkYCBmbGFnIGlzIGlycmVsZXZhbnQgaWYgdGhlIGFycmF5IG9ubHkgY29udGFpbnMgdHdvIGVsZW1lbnRzLgogICAgaWYgKGFycmF5Lmxlbmd0aCA8IDMpIGlzU29ydGVkID0gdHJ1ZTsKICAgIF8ucmVkdWNlKGluaXRpYWwsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSwgaW5kZXgpIHsKICAgICAgaWYgKGlzU29ydGVkID8gXy5sYXN0KG1lbW8pICE9PSB2YWx1ZSB8fCAhbWVtby5sZW5ndGggOiAhXy5pbmNsdWRlKG1lbW8sIHZhbHVlKSkgewogICAgICAgIG1lbW8ucHVzaCh2YWx1ZSk7CiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7CiAgICAgIH0KICAgICAgcmV0dXJuIG1lbW87CiAgICB9LCBbXSk7CiAgICByZXR1cm4gcmVzdWx0czsKICB9OwoKICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2YKICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy4KICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gXy51bmlxKF8uZmxhdHRlbihhcmd1bWVudHMsIHRydWUpKTsKICB9OwoKICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlCiAgLy8gcGFzc2VkLWluIGFycmF5cy4gKEFsaWFzZWQgYXMgImludGVyc2VjdCIgZm9yIGJhY2stY29tcGF0LikKICBfLmludGVyc2VjdGlvbiA9IF8uaW50ZXJzZWN0ID0gZnVuY3Rpb24oYXJyYXkpIHsKICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHsKICAgICAgcmV0dXJuIF8uZXZlcnkocmVzdCwgZnVuY3Rpb24ob3RoZXIpIHsKICAgICAgICByZXR1cm4gXy5pbmRleE9mKG90aGVyLCBpdGVtKSA+PSAwOwogICAgICB9KTsKICAgIH0pOwogIH07CgogIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy4KICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLgogIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7CiAgICB2YXIgcmVzdCA9IF8uZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHRydWUpOwogICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhXy5pbmNsdWRlKHJlc3QsIHZhbHVlKTsgfSk7CiAgfTsKCiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZQogIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLgogIF8uemlwID0gZnVuY3Rpb24oKSB7CiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTsKICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3MsICdsZW5ndGgnKSk7CiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJncywgIiIgKyBpKTsKICAgIHJldHVybiByZXN1bHRzOwogIH07CgogIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksCiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuCiAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLgogIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYAogIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guCiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7CiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xOwogICAgdmFyIGksIGw7CiAgICBpZiAoaXNTb3J0ZWQpIHsKICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pOwogICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7CiAgICB9CiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKTsKICAgIGZvciAoaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIGlmIChpIGluIGFycmF5ICYmIGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTsKICAgIHJldHVybiAtMTsKICB9OwoKICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbGFzdEluZGV4T2ZgIGlmIGF2YWlsYWJsZS4KICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0pIHsKICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7CiAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSByZXR1cm4gYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7CiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aDsKICAgIHdoaWxlIChpLS0pIGlmIChpIGluIGFycmF5ICYmIGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTsKICAgIHJldHVybiAtMTsKICB9OwoKICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mCiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWUKICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLgogIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkgewogICAgICBzdG9wID0gc3RhcnQgfHwgMDsKICAgICAgc3RhcnQgPSAwOwogICAgfQogICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxOwoKICAgIHZhciBsZW4gPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7CiAgICB2YXIgaWR4ID0gMDsKICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW4pOwoKICAgIHdoaWxlKGlkeCA8IGxlbikgewogICAgICByYW5nZVtpZHgrK10gPSBzdGFydDsKICAgICAgc3RhcnQgKz0gc3RlcDsKICAgIH0KCiAgICByZXR1cm4gcmFuZ2U7CiAgfTsKCiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9ucwogIC8vIC0tLS0tLS0tLS0tLS0tLS0tLQoKICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuCiAgdmFyIGN0b3IgPSBmdW5jdGlvbigpe307CgogIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLAogIC8vIG9wdGlvbmFsbHkpLiBCaW5kaW5nIHdpdGggYXJndW1lbnRzIGlzIGFsc28ga25vd24gYXMgYGN1cnJ5YC4KICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWYgYXZhaWxhYmxlLgogIC8vIFdlIGNoZWNrIGZvciBgZnVuYy5iaW5kYCBmaXJzdCwgdG8gZmFpbCBmYXN0IHdoZW4gYGZ1bmNgIGlzIHVuZGVmaW5lZC4KICBfLmJpbmQgPSBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHsKICAgIHZhciBib3VuZCwgYXJnczsKICAgIGlmIChmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQgJiYgbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTsKICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yOwogICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTsKICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkgewogICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTsKICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTsKICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjsKICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7CiAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSByZXR1cm4gcmVzdWx0OwogICAgICByZXR1cm4gc2VsZjsKICAgIH07CiAgfTsKCiAgLy8gQmluZCBhbGwgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0CiAgLy8gYWxsIGNhbGxiYWNrcyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuCiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7CiAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICBpZiAoZnVuY3MubGVuZ3RoID09IDApIGZ1bmNzID0gXy5mdW5jdGlvbnMob2JqKTsKICAgIGVhY2goZnVuY3MsIGZ1bmN0aW9uKGYpIHsgb2JqW2ZdID0gXy5iaW5kKG9ialtmXSwgb2JqKTsgfSk7CiAgICByZXR1cm4gb2JqOwogIH07CgogIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuCiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7CiAgICB2YXIgbWVtbyA9IHt9OwogICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICByZXR1cm4gXy5oYXMobWVtbywga2V5KSA/IG1lbW9ba2V5XSA6IChtZW1vW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOwogICAgfTsKICB9OwoKICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzCiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLgogIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7CiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTsKICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpOyB9LCB3YWl0KTsKICB9OwoKICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMKICAvLyBjbGVhcmVkLgogIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7CiAgICByZXR1cm4gXy5kZWxheS5hcHBseShfLCBbZnVuYywgMV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpOwogIH07CgogIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZQogIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLgogIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7CiAgICB2YXIgY29udGV4dCwgYXJncywgdGltZW91dCwgdGhyb3R0bGluZywgbW9yZSwgcmVzdWx0OwogICAgdmFyIHdoZW5Eb25lID0gXy5kZWJvdW5jZShmdW5jdGlvbigpeyBtb3JlID0gdGhyb3R0bGluZyA9IGZhbHNlOyB9LCB3YWl0KTsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgY29udGV4dCA9IHRoaXM7IGFyZ3MgPSBhcmd1bWVudHM7CiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkgewogICAgICAgIHRpbWVvdXQgPSBudWxsOwogICAgICAgIGlmIChtb3JlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpOwogICAgICAgIHdoZW5Eb25lKCk7CiAgICAgIH07CiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpOwogICAgICBpZiAodGhyb3R0bGluZykgewogICAgICAgIG1vcmUgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7CiAgICAgIH0KICAgICAgd2hlbkRvbmUoKTsKICAgICAgdGhyb3R0bGluZyA9IHRydWU7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9OwogIH07CgogIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3QKICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yCiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlCiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy4KICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7CiAgICB2YXIgdGltZW91dDsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOwogICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHsKICAgICAgICB0aW1lb3V0ID0gbnVsbDsKICAgICAgICBpZiAoIWltbWVkaWF0ZSkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTsKICAgICAgfTsKICAgICAgaWYgKGltbWVkaWF0ZSAmJiAhdGltZW91dCkgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTsKICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOwogICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7CiAgICB9OwogIH07CgogIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvdwogIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uCiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykgewogICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vOwogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICBpZiAocmFuKSByZXR1cm4gbWVtbzsKICAgICAgcmFuID0gdHJ1ZTsKICAgICAgcmV0dXJuIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9OwogIH07CgogIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLAogIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmQKICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLgogIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgdmFyIGFyZ3MgPSBbZnVuY10uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7CiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfTsKICB9OwoKICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaAogIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuCiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7CiAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzOwogICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTsKICAgICAgfQogICAgICByZXR1cm4gYXJnc1swXTsKICAgIH07CiAgfTsKCiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLgogIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykgewogICAgaWYgKHRpbWVzIDw9IDApIHJldHVybiBmdW5jKCk7CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgIGlmICgtLXRpbWVzIDwgMSkgeyByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9CiAgICB9OwogIH07CgogIC8vIE9iamVjdCBGdW5jdGlvbnMKICAvLyAtLS0tLS0tLS0tLS0tLS0tCgogIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLgogIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2AKICBfLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikgewogICAgaWYgKG9iaiAhPT0gT2JqZWN0KG9iaikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7CiAgICB2YXIga2V5cyA9IFtdOwogICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7CiAgICByZXR1cm4ga2V5czsKICB9OwoKICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuCiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpOwogIH07CgogIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC4KICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYAogIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7CiAgICB2YXIgbmFtZXMgPSBbXTsKICAgIGZvciAodmFyIGtleSBpbiBvYmopIHsKICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTsKICAgIH0KICAgIHJldHVybiBuYW1lcy5zb3J0KCk7CiAgfTsKCiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuCiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHsKICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHsKICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHsKICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIG9iajsKICB9OwoKICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLgogIF8ucGljayA9IGZ1bmN0aW9uKG9iaikgewogICAgdmFyIHJlc3VsdCA9IHt9OwogICAgZWFjaChfLmZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSwgZnVuY3Rpb24oa2V5KSB7CiAgICAgIGlmIChrZXkgaW4gb2JqKSByZXN1bHRba2V5XSA9IG9ialtrZXldOwogICAgfSk7CiAgICByZXR1cm4gcmVzdWx0OwogIH07CgogIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuCiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikgewogICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkgewogICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkgewogICAgICAgIGlmIChvYmpbcHJvcF0gPT0gbnVsbCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdOwogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBvYmo7CiAgfTsKCiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LgogIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHsKICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqOwogICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTsKICB9OwoKICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouCiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byAidGFwIGludG8iIGEgbWV0aG9kIGNoYWluLCBpbgogIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLgogIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikgewogICAgaW50ZXJjZXB0b3Iob2JqKTsKICAgIHJldHVybiBvYmo7CiAgfTsKCiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24uCiAgZnVuY3Rpb24gZXEoYSwgYiwgc3RhY2spIHsKICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC4KICAgIC8vIFNlZSB0aGUgSGFybW9ueSBgZWdhbGAgcHJvcG9zYWw6IGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbC4KICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjsKICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC4KICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjsKICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLgogICAgaWYgKGEuX2NoYWluKSBhID0gYS5fd3JhcHBlZDsKICAgIGlmIChiLl9jaGFpbikgYiA9IGIuX3dyYXBwZWQ7CiAgICAvLyBJbnZva2UgYSBjdXN0b20gYGlzRXF1YWxgIG1ldGhvZCBpZiBvbmUgaXMgcHJvdmlkZWQuCiAgICBpZiAoYS5pc0VxdWFsICYmIF8uaXNGdW5jdGlvbihhLmlzRXF1YWwpKSByZXR1cm4gYS5pc0VxdWFsKGIpOwogICAgaWYgKGIuaXNFcXVhbCAmJiBfLmlzRnVuY3Rpb24oYi5pc0VxdWFsKSkgcmV0dXJuIGIuaXNFcXVhbChhKTsKICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuCiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTsKICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlOwogICAgc3dpdGNoIChjbGFzc05hbWUpIHsKICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuCiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6CiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGAiNSJgIGlzCiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZygiNSIpYC4KICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7CiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6CiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvcgogICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLgogICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpOwogICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzoKICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6CiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpcgogICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMKICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuCiAgICAgICAgcmV0dXJuICthID09ICtiOwogICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLgogICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOgogICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJgogICAgICAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJgogICAgICAgICAgICAgICBhLm11bHRpbGluZSA9PSBiLm11bHRpbGluZSAmJgogICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlOwogICAgfQogICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7CiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljCiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC4KICAgIHZhciBsZW5ndGggPSBzdGFjay5sZW5ndGg7CiAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mCiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy4KICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT0gYSkgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuCiAgICBzdGFjay5wdXNoKGEpOwogICAgdmFyIHNpemUgPSAwLCByZXN1bHQgPSB0cnVlOwogICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuCiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScpIHsKICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuCiAgICAgIHNpemUgPSBhLmxlbmd0aDsKICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBiLmxlbmd0aDsKICAgICAgaWYgKHJlc3VsdCkgewogICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuCiAgICAgICAgd2hpbGUgKHNpemUtLSkgewogICAgICAgICAgLy8gRW5zdXJlIGNvbW11dGF0aXZlIGVxdWFsaXR5IGZvciBzcGFyc2UgYXJyYXlzLgogICAgICAgICAgaWYgKCEocmVzdWx0ID0gc2l6ZSBpbiBhID09IHNpemUgaW4gYiAmJiBlcShhW3NpemVdLCBiW3NpemVdLCBzdGFjaykpKSBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudC4KICAgICAgaWYgKCdjb25zdHJ1Y3RvcicgaW4gYSAhPSAnY29uc3RydWN0b3InIGluIGIgfHwgYS5jb25zdHJ1Y3RvciAhPSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7CiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLgogICAgICBmb3IgKHZhciBrZXkgaW4gYSkgewogICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7CiAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuCiAgICAgICAgICBzaXplKys7CiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuCiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBzdGFjaykpKSBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuCiAgICAgIGlmIChyZXN1bHQpIHsKICAgICAgICBmb3IgKGtleSBpbiBiKSB7CiAgICAgICAgICBpZiAoXy5oYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpIGJyZWFrOwogICAgICAgIH0KICAgICAgICByZXN1bHQgPSAhc2l6ZTsKICAgICAgfQogICAgfQogICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuCiAgICBzdGFjay5wb3AoKTsKICAgIHJldHVybiByZXN1bHQ7CiAgfQoKICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC4KICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7CiAgICByZXR1cm4gZXEoYSwgYiwgW10pOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5PwogIC8vIEFuICJlbXB0eSIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLgogIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikgewogICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTsKICAgIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwOwogICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlOwogICAgcmV0dXJuIHRydWU7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50PwogIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5PwogIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5CiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJzsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD8KICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIGFyZ3VtZW50cyBvYmplY3Q/CiAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJzsKICB9OwogIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7CiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7CiAgICAgIHJldHVybiAhIShvYmogJiYgXy5oYXMob2JqLCAnY2FsbGVlJykpOwogICAgfTsKICB9CgogIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBmdW5jdGlvbj8KICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgc3RyaW5nPwogIF8uaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgU3RyaW5nXSc7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIG51bWJlcj8KICBfLmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IE51bWJlcl0nOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj8KICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIGlzRmluaXRlKG9iaik7CiAgfTsKCiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPwogIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHsKICAgIC8vIGBOYU5gIGlzIHRoZSBvbmx5IHZhbHVlIGZvciB3aGljaCBgPT09YCBpcyBub3QgcmVmbGV4aXZlLgogICAgcmV0dXJuIG9iaiAhPT0gb2JqOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuPwogIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJzsKICB9OwoKICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgZGF0ZT8KICBfLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7CiAgfTsKCiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGEgcmVndWxhciBleHByZXNzaW9uPwogIF8uaXNSZWdFeHAgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgUmVnRXhwXSc7CiAgfTsKCiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsPwogIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7CiAgICByZXR1cm4gb2JqID09PSBudWxsOwogIH07CgogIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkPwogIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHsKICAgIHJldHVybiBvYmogPT09IHZvaWQgMDsKICB9OwoKICAvLyBIYXMgb3duIHByb3BlcnR5PwogIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHsKICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTsKICB9OwoKICAvLyBVdGlsaXR5IEZ1bmN0aW9ucwogIC8vIC0tLS0tLS0tLS0tLS0tLS0tCgogIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMKICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuCiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7CiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7CiAgICByZXR1cm4gdGhpczsKICB9OwoKICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0b3JzLgogIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlOwogIH07CgogIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLgogIF8udGltZXMgPSBmdW5jdGlvbiAobiwgaXRlcmF0b3IsIGNvbnRleHQpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGkpOwogIH07CgogIC8vIEVzY2FwZSBhIHN0cmluZyBmb3IgSFRNTCBpbnRlcnBvbGF0aW9uLgogIF8uZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKSB7CiAgICByZXR1cm4gKCcnK3N0cmluZykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoLyIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjeDI3OycpLnJlcGxhY2UoL1wvL2csJyYjeDJGOycpOwogIH07CgogIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcHJvcGVydHkgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdDsKICAvLyBvdGhlcndpc2UsIHJldHVybiBpdC4KICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsKICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuIG51bGw7CiAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldOwogICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTsKICB9OwoKICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QsIGVuc3VyaW5nIHRoYXQKICAvLyB0aGV5J3JlIGNvcnJlY3RseSBhZGRlZCB0byB0aGUgT09QIHdyYXBwZXIgYXMgd2VsbC4KICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7CiAgICBlYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpewogICAgICBhZGRUb1dyYXBwZXIobmFtZSwgX1tuYW1lXSA9IG9ialtuYW1lXSk7CiAgICB9KTsKICB9OwoKICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLgogIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuCiAgdmFyIGlkQ291bnRlciA9IDA7CiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkgewogICAgdmFyIGlkID0gaWRDb3VudGVyKys7CiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDsKICB9OwoKICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGUKICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuCiAgXy50ZW1wbGF0ZVNldHRpbmdzID0gewogICAgZXZhbHVhdGUgICAgOiAvPCUoW1xzXFNdKz8pJT4vZywKICAgIGludGVycG9sYXRlIDogLzwlPShbXHNcU10rPyklPi9nLAogICAgZXNjYXBlICAgICAgOiAvPCUtKFtcc1xTXSs/KSU+L2cKICB9OwoKICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuCiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpcwogIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLgogIHZhciBub01hdGNoID0gLy5eLzsKCiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGEKICAvLyBzdHJpbmcgbGl0ZXJhbC4KICB2YXIgZXNjYXBlcyA9IHsKICAgICdcXCc6ICdcXCcsCiAgICAiJyI6ICInIiwKICAgICdyJzogJ1xyJywKICAgICduJzogJ1xuJywKICAgICd0JzogJ1x0JywKICAgICd1MjAyOCc6ICdcdTIwMjgnLAogICAgJ3UyMDI5JzogJ1x1MjAyOScKICB9OwoKICBmb3IgKHZhciBwIGluIGVzY2FwZXMpIGVzY2FwZXNbZXNjYXBlc1twXV0gPSBwOwogIHZhciBlc2NhcGVyID0gL1xcfCd8XHJ8XG58XHR8XHUyMDI4fFx1MjAyOS9nOwogIHZhciB1bmVzY2FwZXIgPSAvXFwoXFx8J3xyfG58dHx1MjAyOHx1MjAyOSkvZzsKCiAgLy8gV2l0aGluIGFuIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24sIG9yIGVzY2FwaW5nLCByZW1vdmUgSFRNTCBlc2NhcGluZwogIC8vIHRoYXQgaGFkIGJlZW4gcHJldmlvdXNseSBhZGRlZC4KICB2YXIgdW5lc2NhcGUgPSBmdW5jdGlvbihjb2RlKSB7CiAgICByZXR1cm4gY29kZS5yZXBsYWNlKHVuZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSkgewogICAgICByZXR1cm4gZXNjYXBlc1tlc2NhcGVdOwogICAgfSk7CiAgfTsKCiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi4KICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsCiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuCiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7CiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoc2V0dGluZ3MgfHwge30sIF8udGVtcGxhdGVTZXR0aW5ncyk7CgogICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCB0YWtpbmcgY2FyZSB0byBlc2NhcGUgY2hhcmFjdGVycyB0aGF0CiAgICAvLyBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlbiB1bmVzY2FwZSB0aGVtIGluIGNvZGUKICAgIC8vIGJsb2Nrcy4KICAgIHZhciBzb3VyY2UgPSAiX19wKz0nIiArIHRleHQKICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHsKICAgICAgICByZXR1cm4gJ1xcJyArIGVzY2FwZXNbbWF0Y2hdOwogICAgICB9KQogICAgICAucmVwbGFjZShzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCwgZnVuY3Rpb24obWF0Y2gsIGNvZGUpIHsKICAgICAgICByZXR1cm4gIicrXG5fLmVzY2FwZSgiICsgdW5lc2NhcGUoY29kZSkgKyAiKStcbiciOwogICAgICB9KQogICAgICAucmVwbGFjZShzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkgewogICAgICAgIHJldHVybiAiJytcbigiICsgdW5lc2NhcGUoY29kZSkgKyAiKStcbiciOwogICAgICB9KQogICAgICAucmVwbGFjZShzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoLCBmdW5jdGlvbihtYXRjaCwgY29kZSkgewogICAgICAgIHJldHVybiAiJztcbiIgKyB1bmVzY2FwZShjb2RlKSArICJcbjtfX3ArPSciOwogICAgICB9KSArICInO1xuIjsKCiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLgogICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XG4nICsgc291cmNlICsgJ31cbic7CgogICAgc291cmNlID0gInZhciBfX3A9Jyc7IiArCiAgICAgICJ2YXIgcHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPUFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnJyl9O1xuIiArCiAgICAgIHNvdXJjZSArICJyZXR1cm4gX19wO1xuIjsKCiAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7CiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTsKICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHsKICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pOwogICAgfTsKCiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgYnVpbGQgdGltZQogICAgLy8gcHJlY29tcGlsYXRpb24uCiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIChzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJykgKyAnKXtcbicgKwogICAgICBzb3VyY2UgKyAnfSc7CgogICAgcmV0dXJuIHRlbXBsYXRlOwogIH07CgogIC8vIEFkZCBhICJjaGFpbiIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgZGVsZWdhdGUgdG8gdGhlIHdyYXBwZXIuCiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikgewogICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpOwogIH07CgogIC8vIFRoZSBPT1AgV3JhcHBlcgogIC8vIC0tLS0tLS0tLS0tLS0tLQoKICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdAogIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlCiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC4KICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKG9iaikgeyB0aGlzLl93cmFwcGVkID0gb2JqOyB9OwoKICAvLyBFeHBvc2UgYHdyYXBwZXIucHJvdG90eXBlYCBhcyBgXy5wcm90b3R5cGVgCiAgXy5wcm90b3R5cGUgPSB3cmFwcGVyLnByb3RvdHlwZTsKCiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLgogIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmosIGNoYWluKSB7CiAgICByZXR1cm4gY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajsKICB9OwoKICAvLyBBIG1ldGhvZCB0byBlYXNpbHkgYWRkIGZ1bmN0aW9ucyB0byB0aGUgT09QIHdyYXBwZXIuCiAgdmFyIGFkZFRvV3JhcHBlciA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHsKICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7CiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpOwogICAgICB1bnNoaWZ0LmNhbGwoYXJncywgdGhpcy5fd3JhcHBlZCk7CiAgICAgIHJldHVybiByZXN1bHQoZnVuYy5hcHBseShfLCBhcmdzKSwgdGhpcy5fY2hhaW4pOwogICAgfTsKICB9OwoKICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuCiAgXy5taXhpbihfKTsKCiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci4KICBlYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHsKICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdOwogICAgd3JhcHBlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHsKICAgICAgdmFyIHdyYXBwZWQgPSB0aGlzLl93cmFwcGVkOwogICAgICBtZXRob2QuYXBwbHkod3JhcHBlZCwgYXJndW1lbnRzKTsKICAgICAgdmFyIGxlbmd0aCA9IHdyYXBwZWQubGVuZ3RoOwogICAgICBpZiAoKG5hbWUgPT0gJ3NoaWZ0JyB8fCBuYW1lID09ICdzcGxpY2UnKSAmJiBsZW5ndGggPT09IDApIGRlbGV0ZSB3cmFwcGVkWzBdOwogICAgICByZXR1cm4gcmVzdWx0KHdyYXBwZWQsIHRoaXMuX2NoYWluKTsKICAgIH07CiAgfSk7CgogIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLgogIGVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7CiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTsKICAgIHdyYXBwZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiByZXN1bHQobWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cyksIHRoaXMuX2NoYWluKTsKICAgIH07CiAgfSk7CgogIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC4KICB3cmFwcGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uKCkgewogICAgdGhpcy5fY2hhaW4gPSB0cnVlOwogICAgcmV0dXJuIHRoaXM7CiAgfTsKCiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuCiAgd3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiB0aGlzLl93cmFwcGVkOwogIH07Cgp9KS5jYWxsKHRoaXMpOwoKfSl9OwoKLyoqKioqKioqKiogc2hhMSAqKioqKioqKioqLwoKa2Fuc28ubW9kdWxlQ2FjaGVbInNoYTEiXSA9IHtsb2FkOiAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSkgewoKLyoqDQogKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWQNCiAqIGluIEZJUFMgUFVCIDE4MC0xLiBUaGlzIG1vZHVsZSBpcyB1c2VkIHRvIGhhc2ggdXNlciBwYXNzd29yZHMgaW4gYSB3YXkgdGhhdCdzDQogKiBjb21wYXRpYmxlIHdpdGggQ291Y2hEQi4NCiAqDQogKiBUaGlzIG1vZHVsZSBpcyBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMiBhbmQgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlDQogKiBCU0QgTGljZW5zZS4gU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuDQogKg0KICogQG1vZHVsZQ0KICovDQoNCi8qDQogKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWQNCiAqIGluIEZJUFMgUFVCIDE4MC0xDQogKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuDQogKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0DQogKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UNCiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLg0KICovDQoNCi8qDQogKiBDb25maWd1cmFibGUgdmFyaWFibGVzLiBZb3UgbWF5IG5lZWQgdG8gdHdlYWsgdGhlc2UgdG8gYmUgY29tcGF0aWJsZSB3aXRoDQogKiB0aGUgc2VydmVyLXNpZGUsIGJ1dCB0aGUgZGVmYXVsdHMgd29yayBpbiBtb3N0IGNhc2VzLg0KICovDQp2YXIgaGV4Y2FzZSA9IDA7ICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi8NCnZhciBiNjRwYWQgID0gIj0iOyAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuICI9IiBmb3Igc3RyaWN0IFJGQyBjb21wbGlhbmNlICAgKi8NCnZhciBjaHJzeiAgID0gODsgIC8qIGJpdHMgcGVyIGlucHV0IGNoYXJhY3Rlci4gOCAtIEFTQ0lJOyAxNiAtIFVuaWNvZGUgICAgICAqLw0KDQovKg0KICogVGhlc2UgYXJlIHRoZSBmdW5jdGlvbnMgeW91J2xsIHVzdWFsbHkgd2FudCB0byBjYWxsDQogKiBUaGV5IHRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciBoZXggb3IgYmFzZS02NCBlbmNvZGVkIHN0cmluZ3MNCiAqLw0KZnVuY3Rpb24gaGV4X3NoYTEocyl7cmV0dXJuIGJpbmIyaGV4KGNvcmVfc2hhMShzdHIyYmluYihzKSxzLmxlbmd0aCAqIGNocnN6KSk7fQ0KZnVuY3Rpb24gYjY0X3NoYTEocyl7cmV0dXJuIGJpbmIyYjY0KGNvcmVfc2hhMShzdHIyYmluYihzKSxzLmxlbmd0aCAqIGNocnN6KSk7fQ0KZnVuY3Rpb24gc3RyX3NoYTEocyl7cmV0dXJuIGJpbmIyc3RyKGNvcmVfc2hhMShzdHIyYmluYihzKSxzLmxlbmd0aCAqIGNocnN6KSk7fQ0KZnVuY3Rpb24gaGV4X2htYWNfc2hhMShrZXksIGRhdGEpeyByZXR1cm4gYmluYjJoZXgoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7fQ0KZnVuY3Rpb24gYjY0X2htYWNfc2hhMShrZXksIGRhdGEpeyByZXR1cm4gYmluYjJiNjQoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7fQ0KZnVuY3Rpb24gc3RyX2htYWNfc2hhMShrZXksIGRhdGEpeyByZXR1cm4gYmluYjJzdHIoY29yZV9obWFjX3NoYTEoa2V5LCBkYXRhKSk7fQ0KDQovKg0KICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nDQogKi8NCmZ1bmN0aW9uIHNoYTFfdm1fdGVzdCgpDQp7DQogIHJldHVybiBoZXhfc2hhMSgiYWJjIikgPT0gImE5OTkzZTM2NDcwNjgxNmFiYTNlMjU3MTc4NTBjMjZjOWNkMGQ4OWQiOw0KfQ0KDQovKg0KICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoDQogKi8NCmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pDQp7DQogIC8qIGFwcGVuZCBwYWRkaW5nICovDQogIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpOw0KICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47DQoNCiAgdmFyIHcgPSBBcnJheSg4MCk7DQogIHZhciBhID0gIDE3MzI1ODQxOTM7DQogIHZhciBiID0gLTI3MTczMzg3OTsNCiAgdmFyIGMgPSAtMTczMjU4NDE5NDsNCiAgdmFyIGQgPSAgMjcxNzMzODc4Ow0KICB2YXIgZSA9IC0xMDA5NTg5Nzc2Ow0KDQogIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikNCiAgew0KICAgIHZhciBvbGRhID0gYTsNCiAgICB2YXIgb2xkYiA9IGI7DQogICAgdmFyIG9sZGMgPSBjOw0KICAgIHZhciBvbGRkID0gZDsNCiAgICB2YXIgb2xkZSA9IGU7DQoNCiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKykNCiAgICB7DQogICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTsNCiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7DQogICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksDQogICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7DQogICAgICBlID0gZDsNCiAgICAgIGQgPSBjOw0KICAgICAgYyA9IHJvbChiLCAzMCk7DQogICAgICBiID0gYTsNCiAgICAgIGEgPSB0Ow0KICAgIH0NCg0KICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTsNCiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7DQogICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpOw0KICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTsNCiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7DQogIH0NCiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpOw0KDQp9DQoNCi8qDQogKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudA0KICogaXRlcmF0aW9uDQogKi8NCmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZCkNCnsNCiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7DQogIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDsNCiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpOw0KICByZXR1cm4gYiBeIGMgXiBkOw0KfQ0KDQovKg0KICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uDQogKi8NCmZ1bmN0aW9uIHNoYTFfa3QodCkNCnsNCiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDoNCiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0Ow0KfQ0KDQovKg0KICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YQ0KICovDQpmdW5jdGlvbiBjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpDQp7DQogIHZhciBia2V5ID0gc3RyMmJpbmIoa2V5KTsNCiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGNvcmVfc2hhMShia2V5LCBrZXkubGVuZ3RoICogY2hyc3opOw0KDQogIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpOw0KICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykNCiAgew0KICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjsNCiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7DQogIH0NCg0KICB2YXIgaGFzaCA9IGNvcmVfc2hhMShpcGFkLmNvbmNhdChzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogY2hyc3opOw0KICByZXR1cm4gY29yZV9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApOw0KfQ0KDQovKg0KICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseQ0KICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy4NCiAqLw0KZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSkNCnsNCiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTsNCiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpOw0KICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTsNCn0NCg0KLyoNCiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC4NCiAqLw0KZnVuY3Rpb24gcm9sKG51bSwgY250KQ0Kew0KICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7DQp9DQoNCi8qDQogKiBDb252ZXJ0IGFuIDgtYml0IG9yIDE2LWJpdCBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3Jkcw0KICogSW4gOC1iaXQgZnVuY3Rpb24sIGNoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpLWJ5dGUgc2lsZW50bHkgaWdub3JlZC4NCiAqLw0KZnVuY3Rpb24gc3RyMmJpbmIoc3RyKQ0Kew0KICB2YXIgYmluID0gQXJyYXkoKTsNCiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxOw0KICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aCAqIGNocnN6OyBpICs9IGNocnN6KQ0KICAgIGJpbltpPj41XSB8PSAoc3RyLmNoYXJDb2RlQXQoaSAvIGNocnN6KSAmIG1hc2spIDw8ICgzMiAtIGNocnN6IC0gaSUzMik7DQogIHJldHVybiBiaW47DQp9DQoNCi8qDQogKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmcNCiAqLw0KZnVuY3Rpb24gYmluYjJzdHIoYmluKQ0Kew0KICB2YXIgc3RyID0gIiI7DQogIHZhciBtYXNrID0gKDEgPDwgY2hyc3opIC0gMTsNCiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbi5sZW5ndGggKiAzMjsgaSArPSBjaHJzeikNCiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYmluW2k+PjVdID4+PiAoMzIgLSBjaHJzeiAtIGklMzIpKSAmIG1hc2spOw0KICByZXR1cm4gc3RyOw0KfQ0KDQovKg0KICogQ29udmVydCBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzIHRvIGEgaGV4IHN0cmluZy4NCiAqLw0KZnVuY3Rpb24gYmluYjJoZXgoYmluYXJyYXkpDQp7DQogIHZhciBoZXhfdGFiID0gaGV4Y2FzZSA/ICIwMTIzNDU2Nzg5QUJDREVGIiA6ICIwMTIzNDU2Nzg5YWJjZGVmIjsNCiAgdmFyIHN0ciA9ICIiOw0KICBmb3IodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSsrKQ0KICB7DQogICAgc3RyICs9IGhleF90YWIuY2hhckF0KChiaW5hcnJheVtpPj4yXSA+PiAoKDMgLSBpJTQpKjgrNCkpICYgMHhGKSArDQogICAgICAgICAgIGhleF90YWIuY2hhckF0KChiaW5hcnJheVtpPj4yXSA+PiAoKDMgLSBpJTQpKjggICkpICYgMHhGKTsNCiAgfQ0KICByZXR1cm4gc3RyOw0KfQ0KDQovKg0KICogQ29udmVydCBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzIHRvIGEgYmFzZS02NCBzdHJpbmcNCiAqLw0KZnVuY3Rpb24gYmluYjJiNjQoYmluYXJyYXkpDQp7DQogIHZhciB0YWIgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7DQogIHZhciBzdHIgPSAiIjsNCiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkgKz0gMykNCiAgew0KICAgIHZhciB0cmlwbGV0ID0gKCgoYmluYXJyYXlbaSAgID4+IDJdID4+IDggKiAoMyAtICBpICAgJTQpKSAmIDB4RkYpIDw8IDE2KQ0KICAgICAgICAgICAgICAgIHwgKCgoYmluYXJyYXlbaSsxID4+IDJdID4+IDggKiAoMyAtIChpKzEpJTQpKSAmIDB4RkYpIDw8IDggKQ0KICAgICAgICAgICAgICAgIHwgICgoYmluYXJyYXlbaSsyID4+IDJdID4+IDggKiAoMyAtIChpKzIpJTQpKSAmIDB4RkYpOw0KICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspDQogICAgew0KICAgICAgaWYoaSAqIDggKyBqICogNiA+IGJpbmFycmF5Lmxlbmd0aCAqIDMyKSBzdHIgKz0gYjY0cGFkOw0KICAgICAgZWxzZSBzdHIgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+PiA2KigzLWopKSAmIDB4M0YpOw0KICAgIH0NCiAgfQ0KICByZXR1cm4gc3RyOw0KfQ0KDQoNCi8qKg0KICogSGFzaGVzIGEgc3RyaW5nIHVzaW5nIFNIQTEgYW5kIHJldHVybnMgYSBoZXggcmVwcmVzZW50YXRpb24gb2YgaXQuDQogKg0KICogQG5hbWUgaGV4KHMpDQogKiBAcGFyYW0ge1N0cmluZ30gcw0KICogQHJldHVybnMge1N0cmluZ30NCiAqIEBhcGkgcHVibGljDQogKi8NCg0KZXhwb3J0cy5oZXggPSBoZXhfc2hhMTsNCg0KLyoqDQogKiBIYXNoZXMgYSBzdHJpbmcgdXNpbmcgU0hBMSBhbmQgcmV0dXJucyBhIGJhc2U2NCByZXByZXNlbnRhdGlvbiBvZiBpdC4NCiAqDQogKiBAbmFtZSBiYXNlNjQocykNCiAqIEBwYXJhbSB7U3RyaW5nfSBzDQogKiBAcmV0dXJucyB7U3RyaW5nfQ0KICogQGFwaSBwdWJsaWMNCiAqLw0KDQpleHBvcnRzLmJhc2U2NCA9IGI2NF9zaGExOw0KDQovKioNCiAqIEhhc2hlcyBhIHN0cmluZyB1c2luZyBTSEExIGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0Lg0KICoNCiAqIEBuYW1lIHN0cihzKQ0KICogQHBhcmFtIHtTdHJpbmd9IHMNCiAqIEByZXR1cm5zIHtTdHJpbmd9DQogKiBAYXBpIHB1YmxpYw0KICovDQoNCmV4cG9ydHMuc3RyID0gc3RyX3NoYTE7DQoNCi8qKg0KICogQ2FsY3VsYXRlcyB0aGUgSE1BQy1TSEExIG9mIGEga2V5IGFuZCBzb21lIGRhdGEsIHJldHVybmluZyBhIGhleA0KICogcmVwcmVzZW50YXRpb24gb2YgaXQuDQogKg0KICogQG5hbWUgaGV4X2htYWMoa2V5LCBkYXRhKQ0KICogQHBhcmFtIHtTdHJpbmd9IGtleQ0KICogQHBhcmFtIHtTdHJpbmd9IGRhdGENCiAqIEByZXR1cm5zIHtTdHJpbmd9DQogKiBAYXBpIHB1YmxpYw0KICovDQoNCmV4cG9ydHMuaGV4X2htYWMgPSBoZXhfaG1hY19zaGExOw0KDQovKioNCiAqIENhbGN1bGF0ZXMgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhLCByZXR1cm5pbmcgYSBiYXNlNjQNCiAqIHJlcHJlc2VudGF0aW9uIG9mIGl0Lg0KICoNCiAqIEBuYW1lIGJhc2U2NF9obWFjKGtleSwgZGF0YSkNCiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkNCiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhDQogKiBAcmV0dXJucyB7U3RyaW5nfQ0KICogQGFwaSBwdWJsaWMNCiAqLw0KDQpleHBvcnRzLmJhc2U2NF9obWFjID0gYjY0X2htYWNfc2hhMTsNCg0KLyoqDQogKiBDYWxjdWxhdGVzIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSwgcmV0dXJuaW5nIGEgc3RyaW5nDQogKiByZXByZXNlbnRhdGlvbiBvZiBpdC4NCiAqDQogKiBAbmFtZSBzdHJfaG1hYyhrZXksIGRhdGEpDQogKiBAcGFyYW0ge1N0cmluZ30ga2V5DQogKiBAcGFyYW0ge1N0cmluZ30gZGF0YQ0KICogQHJldHVybnMge1N0cmluZ30NCiAqIEBhcGkgcHVibGljDQogKi8NCg0KZXhwb3J0cy5zdHJfaG1hYyA9IHN0cl9obWFjX3NoYTE7DQoKCn0pfTsKCi8qKioqKioqKioqIGRiICoqKioqKioqKiovCgprYW5zby5tb2R1bGVDYWNoZVsiZGIiXSA9IHtsb2FkOiAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSkgewoKLypnbG9iYWwgJDogZmFsc2UgKi8KCi8qKgogKiAjIyBEQiBNb2R1bGUKICoKICogVGhpcyBjb250YWlucyB0aGUgY29yZSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDb3VjaERCLiBUaGF0IGluY2x1ZGVzCiAqIGRvY3VtZW50IENSVUQgb3BlcmF0aW9ucywgcXVlcnlpbmcgdmlld3MgYW5kIGNyZWF0aW5nL2RlbGV0aW5nIGRhdGFiYXNlcy4KICoKICoKICogIyMjIEV2ZW50cwogKgogKiBUaGUgZGIgbW9kdWxlIGlzIGFuIEV2ZW50RW1pdHRlci4gU2VlIHRoZQogKiBbZXZlbnRzIHBhY2thZ2VdKGh0dHA6Ly9rYW4uc28vcGFja2FnZXMvZGV0YWlscy9ldmVudHMpIGZvciBtb3JlIGluZm9ybWF0aW9uLgogKgogKiAjIyMjIHVuYXV0aG9yaXplZAogKgogKiBFbWl0dGVkIGJ5IHRoZSBkYiBtb2R1bGUgd2hlbiBhIHJlcXVlc3QgcmVzdWx0cyBpbiBhIDQwMSBVbmF1dGhvcml6ZWQKICogcmVzcG9uc2UuIFRoaXMgaXMgbGlzdGVuZWQgdG8gdXNlZCBieSB0aGUgc2Vzc2lvbiBtb2R1bGUgdG8gaGVscCBkZXRlY3QKICogc2Vzc2lvbiB0aW1lb3V0cyBldGMuCiAqCiAqIGBgYGphdmFzY3JpcHQKICogdmFyIGRiID0gcmVxdWlyZSgiZGIiKTsKICoKICogZGIub24oJ3VuYXV0aG9yaXplZCcsIGZ1bmN0aW9uIChyZXEpIHsKICogICAgIC8vIHJlcSBpcyB0aGUgYWpheCByZXF1ZXN0IG9iamVjdCB3aGljaCByZXR1cm5lZCA0MDEKICogfSk7CiAqIGBgYAogKgogKiBAbW9kdWxlCiAqLwoKCnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKSwKICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJykuXzsKCgovKioKICogVGVzdHMgaWYgcnVubmluZyBpbiB0aGUgYnJvd3NlcgogKgogKiBAcmV0dXJucyB7Qm9vbGVhbn0KICovCgpmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7CiAgICByZXR1cm4gKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyk7Cn0KCgovKioKICogVGhpcyBtb2R1bGUgaXMgYW4gRXZlbnRFbWl0dGVyLCB1c2VkIGZvciBlbWl0dGluZyAndW5hdXRob3JpemVkJyBldmVudHMKICovCgp2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTsKCgovKioKICogVGFrZW4gZnJvbSBqUXVlcnkgMS40LjQgc28gd2UgY2FuIHN1cHBvcnQgbW9yZSByZWNlbnQgdmVyc2lvbnMgb2YgalF1ZXJ5LgogKi8KCnZhciBodHRwRGF0YSA9IGZ1bmN0aW9uICh4aHIsIHR5cGUsIHMpIHsKICAgIHZhciBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcigiY29udGVudC10eXBlIikgfHwgIiIsCiAgICAgICAgeG1sID0gdHlwZSA9PT0gInhtbCIgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZigieG1sIikgPj0gMCwKICAgICAgICBkYXRhID0geG1sID8geGhyLnJlc3BvbnNlWE1MIDogeGhyLnJlc3BvbnNlVGV4dDsKCiAgICBpZiAoeG1sICYmIGRhdGEuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSAicGFyc2VyZXJyb3IiKSB7CiAgICAgICAgJC5lcnJvcigicGFyc2VyZXJyb3IiKTsKICAgIH0KICAgIGlmIChzICYmIHMuZGF0YUZpbHRlcikgewogICAgICAgIGRhdGEgPSBzLmRhdGFGaWx0ZXIoZGF0YSwgdHlwZSk7CiAgICB9CiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICJzdHJpbmciKSB7CiAgICAgICAgaWYgKHR5cGUgPT09ICJqc29uIiB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKCJqc29uIikgPj0gMCkgewogICAgICAgICAgICBkYXRhID0gJC5wYXJzZUpTT04oZGF0YSk7CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICJzY3JpcHQiIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoImphdmFzY3JpcHQiKSA+PSAwKSB7CiAgICAgICAgICAgICQuZ2xvYmFsRXZhbChkYXRhKTsKICAgICAgICB9CiAgICB9CiAgICByZXR1cm4gZGF0YTsKfTsKCgovKioKICogUmV0dXJucyBhIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBhamF4IHJlc3BvbnNlcyBmcm9tIGpxdWVyeSBhbmQgY2FsbHMKICogdGhlIGNhbGxiYWNrIHdpdGggdGhlIGRhdGEgb3IgYXBwcm9wcmlhdGUgZXJyb3IuCiAqCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwcml2YXRlCiAqLwoKZnVuY3Rpb24gb25Db21wbGV0ZShvcHRpb25zLCBjYWxsYmFjaykgewogICAgcmV0dXJuIGZ1bmN0aW9uIChyZXEpIHsKICAgICAgICB2YXIgcmVzcDsKICAgICAgICB2YXIgY3R5cGUgPSByZXEuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpOwogICAgICAgIGlmIChjdHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nIHx8IGN0eXBlID09PSAndGV4dC9qc29uJykgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgcmVzcCA9IGh0dHBEYXRhKHJlcSwgImpzb24iKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICBpZiAob3B0aW9ucy5leHBlY3RfanNvbikgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICByZXNwID0gaHR0cERhdGEocmVxLCAianNvbiIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKAogICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0V4cGVjdGVkIEpTT04gcmVzcG9uc2UsIGdvdCAnICsgY3R5cGUpCiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3AgPSByZXEucmVzcG9uc2VUZXh0OwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmIChyZXEuc3RhdHVzID09PSA0MDEpIHsKICAgICAgICAgICAgZXhwb3J0cy5lbWl0KCd1bmF1dGhvcml6ZWQnLCByZXEpOwogICAgICAgIH0KICAgICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwIHx8IHJlcS5zdGF0dXMgPT09IDIwMSB8fCByZXEuc3RhdHVzID09PSAyMDIpIHsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcCk7CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKHJlc3AuZXJyb3IgfHwgcmVzcC5yZWFzb24pIHsKICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihyZXNwLnJlYXNvbiB8fCByZXNwLmVycm9yKTsKICAgICAgICAgICAgZXJyLmVycm9yID0gcmVzcC5lcnJvcjsKICAgICAgICAgICAgZXJyLnJlYXNvbiA9IHJlc3AucmVhc29uOwogICAgICAgICAgICBlcnIuY29kZSA9IHJlc3AuY29kZTsKICAgICAgICAgICAgZXJyLnN0YXR1cyA9IHJlcS5zdGF0dXM7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICAvLyBUT0RPOiBtYXAgc3RhdHVzIGNvZGUgdG8gbWVhbmluZ2Z1bCBlcnJvciBtZXNzYWdlCiAgICAgICAgICAgIHZhciBlcnIyID0gbmV3IEVycm9yKCdSZXR1cm5lZCBzdGF0dXMgY29kZTogJyArIHJlcS5zdGF0dXMpOwogICAgICAgICAgICBlcnIyLnN0YXR1cyA9IHJlcS5zdGF0dXM7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycjIpOwogICAgICAgIH0KICAgIH07Cn0KCgovKioKICogQXR0ZW1wdHMgdG8gZ3Vlc3MgdGhlIGRhdGFiYXNlIG5hbWUgYW5kIGRlc2lnbiBkb2MgaWQgZnJvbSB0aGUgY3VycmVudCBVUkwsCiAqIG9yIHRoZSBsb2MgcGFyYW10ZXIuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggJ2RiJywgJ2Rlc2lnbl9kb2MnIGFuZCAncm9vdCcKICogcHJvcGVydGllcywgb3IgbnVsbCBmb3IgYSBVUkwgbm90IG1hdGNoaW5nIHRoZSBleHBlY3RlZCBmb3JtYXQgKHBlcmhhcHMKICogYmVoaW5nIGEgdmhvc3QpLgogKgogKiBZb3Ugd291bGRuJ3Qgbm9ybWFsbHkgdXNlIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHksIGJ1dCB1c2UgYGRiLmN1cnJlbnQoKWAgdG8KICogcmV0dXJuIGEgREIgb2JqZWN0IGJvdW5kIHRvIHRoZSBjdXJyZW50IGRhdGFiYXNlIGluc3RlYWQuCiAqCiAqIEBuYW1lIGd1ZXNzQ3VycmVudChbbG9jXSkKICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIEFuIGFsdGVybmF0aXZlIFVSTCB0byB1c2UgaW5zdGVhZCBvZiB3aW5kb3cubG9jYXRpb24KICogICAgIChvcHRpb25hbCkKICogQHJldHVybnMge09iamVjdHxudWxsfSAtIEFuIG9iamVjdCB3aXRoICdkYicsICdkZXNpZ25fZG9jJyBhbmQgJ3Jvb3QnCiAqICAgICBwcm9wZXJ0aWVzLCBvciBudWxsIGZvciBhIFVSTCBub3QgbWF0Y2hpbmcgdGhlCiAqICAgICBleHBlY3RlZCBmb3JtYXQgKHBlcmhhcHMgYmVoaW5nIGEgdmhvc3QpCiAqIEBhcGkgcHVibGljCiAqLwoKZXhwb3J0cy5ndWVzc0N1cnJlbnQgPSBmdW5jdGlvbiAobG9jKSB7CiAgICB2YXIgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjsKCiAgICAvKioKICAgICAqIEEgZGF0YWJhc2UgbXVzdCBiZSBuYW1lZCB3aXRoIGFsbCBsb3dlcmNhc2UgbGV0dGVycyAoYS16KSwgZGlnaXRzICgwLTkpLAogICAgICogb3IgYW55IG9mIHRoZSBfJCgpKy0vIGNoYXJhY3RlcnMgYW5kIG11c3QgZW5kIHdpdGggYSBzbGFzaCBpbiB0aGUgVVJMLgogICAgICogVGhlIG5hbWUgaGFzIHRvIHN0YXJ0IHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyIChhLXopLgogICAgICoKICAgICAqIGh0dHA6Ly93aWtpLmFwYWNoZS5vcmcvY291Y2hkYi9IVFRQX2RhdGFiYXNlX0FQSQogICAgICovCgogICAgdmFyIHJlID0gL1wvKFthLXpdW2EtejAtOV9cJFwoXClcKy1cL10qKVwvX2Rlc2lnblwvKFteXC9dKylcLy87CiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKGxvYy5wYXRobmFtZSk7CgogICAgaWYgKG1hdGNoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZGI6IG1hdGNoWzFdLAogICAgICAgICAgICBkZXNpZ25fZG9jOiBtYXRjaFsyXSwKICAgICAgICAgICAgcm9vdDogJy8nCiAgICAgICAgfQogICAgfQogICAgcmV0dXJuIG51bGw7Cn07CgovKioKICogQ29udmVydHMgYW4gb2JqZWN0IHRvIGEgc3RyaW5nIG9mIHByb3Blcmx5IGVzY2FwZWQgVVJMIHBhcmFtZXRlcnMuCiAqCiAqIEBuYW1lIGVzY2FwZVVybFBhcmFtcyhbb2JqXSkKICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEFuIG9iamVjdCBjb250YWluaW5nIHVybCBwYXJhbWV0ZXJzLCB3aXRoCiAqICAgICAgIHBhcmFtZXRlciBuYW1lcyBzdG9yZWQgYXMgcHJvcGVydHkgbmFtZXMgKG9yIGtleXMpLgogKiBAcmV0dXJucyB7U3RyaW5nfQogKiBAYXBpIHB1YmxpYwogKi8KCmV4cG9ydHMuZXNjYXBlVXJsUGFyYW1zID0gZnVuY3Rpb24gKG9iaikgewogICAgdmFyIHJ2ID0gWyBdOwogICAgZm9yICh2YXIga2V5IGluIG9iaikgewogICAgICAgIHJ2LnB1c2goCiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsKICAgICAgICAgICAgICAgICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkKICAgICAgICApOwogICAgfQogICAgcmV0dXJuIChydi5sZW5ndGggPiAwID8gKCc/JyArIHJ2LmpvaW4oJyYnKSkgOiAnJyk7Cn07CgovKioKICogRW5jb2RlcyBhIGRvY3VtZW50IGlkIG9yIHZpZXcsIGxpc3Qgb3Igc2hvdyBuYW1lLiBUaGlzIGFsc28gd2lsbCBtYWtlIHN1cmUKICogdGhlIGZvcndhcmQtc2xhc2ggaXMgbm90IGVzY2FwZWQgZm9yIGRvY3VtZW50cyB3aXRoIGlkJ3MgYmVnaW5uaW5nIHdpdGgKICogIlxfZGVzaWduLyIuCiAqCiAqIEBuYW1lIGVuY29kZShzdHIpCiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSB0aGUgbmFtZSBvciBpZCB0byBlc2NhcGUKICogQHJldHVybnMge1N0cmluZ30KICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsKICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9eX2Rlc2lnbiUyRi8sICdfZGVzaWduLycpOwp9OwoKCi8qKgogKiBQcm9wZXJseSBlbmNvZGVzIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gQ291Y2hEQiB2aWV3cyBldGMuIEhhbmRsZSBjb21wbGV4CiAqIGtleXMgYW5kIG90aGVyIG5vbi1zdHJpbmcgcGFyYW1ldGVycyBieSBwYXNzaW5nIHRocm91Z2ggSlNPTi5zdHJpbmdpZnkuCiAqIFJldHVybnMgYSBzaGFsbG93LWNvcGllZCBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgcXVlcnkgYWZ0ZXIgY29tcGxleCB2YWx1ZXMKICogaGF2ZSBiZWVuIHN0cmluZ2lmaWVkLgogKgogKiBAbmFtZSBzdHJpbmdpZnlRdWVyeShxdWVyeSkKICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5CiAqIEByZXR1cm5zIHtPYmplY3R9CiAqIEBhcGkgcHVibGljCiAqLwoKZXhwb3J0cy5zdHJpbmdpZnlRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkgewogICAgdmFyIHEgPSB7fTsKICAgIGZvciAodmFyIGsgaW4gcXVlcnkpIHsKICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5W2tdICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICBxW2tdID0gSlNPTi5zdHJpbmdpZnkocXVlcnlba10pOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgcVtrXSA9IHF1ZXJ5W2tdOwogICAgICAgIH0KICAgIH0KICAgIHJldHVybiBxOwp9OwoKCi8qKgogKiBNYWtlIGEgcmVxdWVzdCwgd2l0aCBzb21lIGRlZmF1bHQgc2V0dGluZ3MsIHByb3BlciBjYWxsYmFjawogKiBoYW5kbGluZywgYW5kIG9wdGlvbmFsIGNhY2hpbmcuIFVzZWQgYmVoaW5kLXRoZS1zY2VuZXMgYnkKICogbW9zdCBvdGhlciBEQiBtb2R1bGUgZnVuY3Rpb25zLgogKgogKiBAbmFtZSByZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKQogKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKZXhwb3J0cy5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7CiAgICBvcHRpb25zLmNvbXBsZXRlID0gb25Db21wbGV0ZShvcHRpb25zLCBjYWxsYmFjayk7CiAgICBvcHRpb25zLmRhdGFUeXBlID0gJ2pzb24nOwogICAgJC5hamF4KG9wdGlvbnMpOwp9OwoKCi8qKgogKiBDcmVhdGVzIGEgQ291Y2hEQiBkYXRhYmFzZS4KICoKICogSWYgeW91J3JlIHJ1bm5pbmcgYmVoaW5kIGEgdmlydHVhbCBob3N0IHlvdSdsbCBuZWVkIHRvIHNldCB1cAogKiBhcHByb3ByaWF0ZSByZXdyaXRlcyBmb3IgYSBERUxFVEUgcmVxdWVzdCB0byAnLycgZWl0aGVyIHR1cm5pbmcgb2ZmIHNhZmUKICogcmV3cml0ZXMgb3Igc2V0dGluZyB1cCBhIG5ldyB2aG9zdCBlbnRyeS4KICoKICogQG5hbWUgY3JlYXRlRGF0YWJhc2UobmFtZSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLmNyZWF0ZURhdGFiYXNlID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgcmVxID0gewogICAgICAgIHR5cGU6ICdQVVQnLAogICAgICAgIHVybDogJy8nICsgZXhwb3J0cy5lbmNvZGUobmFtZS5yZXBsYWNlKC9eXC8rLywgJycpKQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCi8qKgogKiBEZWxldGVzIGEgQ291Y2hEQiBkYXRhYmFzZS4KICoKICogSWYgeW91J3JlIHJ1bm5pbmcgYmVoaW5kIGEgdmlydHVhbCBob3N0IHlvdSdsbCBuZWVkIHRvIHNldCB1cAogKiBhcHByb3ByaWF0ZSByZXdyaXRlcyBmb3IgYSBERUxFVEUgcmVxdWVzdCB0byAnLycgZWl0aGVyIHR1cm5pbmcgb2ZmIHNhZmUKICogcmV3cml0ZXMgb3Igc2V0dGluZyB1cCBhIG5ldyB2aG9zdCBlbnRyeS4KICoKICogQG5hbWUgZGVsZXRlRGF0YWJhc2UobmFtZSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgovLyBUT0RPOiBkZXRlY3Qgd2hlbiAnbmFtZScgYXJndW1lbnQgaXMgYSB1cmwgYW5kIGRvbid0IGNvbnN0cnVjdCBhIHVybCB0aGVuCmV4cG9ydHMuZGVsZXRlRGF0YWJhc2UgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsKICAgIHZhciByZXEgPSB7CiAgICAgICAgdHlwZTogJ0RFTEVURScsCiAgICAgICAgdXJsOiAnLycgKyBleHBvcnRzLmVuY29kZShuYW1lLnJlcGxhY2UoL15cLysvLCAnJykpCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBMaXN0cyBhbGwgZGF0YWJzZXMKICoKICogSWYgeW91J3JlIHJ1bm5pbmcgYmVoaW5kIGEgdmlydHVhbCBob3N0IHlvdSdsbCBuZWVkIHRvIHNldCB1cAogKiBhcHByb3ByaWF0ZSByZXdyaXRlcyBmb3IgYSBERUxFVEUgcmVxdWVzdCB0byAnLycgZWl0aGVyIHR1cm5pbmcgb2ZmIHNhZmUKICogcmV3cml0ZXMgb3Igc2V0dGluZyB1cCBhIG5ldyB2aG9zdCBlbnRyeS4KICoKICogQG5hbWUgYWxsRGJzKGNhbGxiYWNrKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKZXhwb3J0cy5hbGxEYnMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsKICAgIHZhciByZXEgPSB7CiAgICAgICAgdHlwZTogJ0dFVCcsCiAgICAgICAgdXJsOiAnL19hbGxfZGJzJwogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogUmV0dXJucyBhIG5ldyBVVUlEIGdlbmVyYXRlZCBieSBDb3VjaERCLiBJdHMgcG9zc2libGUgdG8gY2FjaGUKICogbXVsdGlwbGUgVVVJRHMgZm9yIGxhdGVyIHVzZSwgdG8gYXZvaWQgbWFraW5nIHRvbyBtYW55IHJlcXVlc3RzLgogKgogKiBAbmFtZSBuZXdVVUlEKGNhY2hlTnVtLCBjYWxsYmFjaykKICogQHBhcmFtIHtOdW1iZXJ9IGNhY2hlTnVtIChvcHRpb25hbCwgZGVmYXVsdDogMSkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCnZhciB1dWlkQ2FjaGUgPSBbXTsKCmV4cG9ydHMubmV3VVVJRCA9IGZ1bmN0aW9uIChjYWNoZU51bSwgY2FsbGJhY2spIHsKICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IGNhY2hlTnVtOwogICAgICAgIGNhY2hlTnVtID0gMTsKICAgIH0KICAgIGlmICh1dWlkQ2FjaGUubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV1aWRDYWNoZS5zaGlmdCgpKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiAnL191dWlkcycsCiAgICAgICAgZGF0YToge2NvdW50OiBjYWNoZU51bX0sCiAgICAgICAgZXhwZWN0X2pzb246IHRydWUKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB9CiAgICAgICAgdXVpZENhY2hlID0gcmVzcC51dWlkczsKICAgICAgICBjYWxsYmFjayhudWxsLCB1dWlkQ2FjaGUuc2hpZnQoKSk7CiAgICB9KTsKfTsKCgovKioKICogREIgb2JqZWN0IGNyZWF0ZWQgYnkgdXNlKGRibmFtZSkgZnVuY3Rpb24KICovCgpmdW5jdGlvbiBEQih1cmwpIHsKICAgIHRoaXMudXJsID0gdXJsOwogICAgLy8gYWRkIHRoZSBtb2R1bGUgZnVuY3Rpb25zIHRvIHRoZSBEQiBvYmplY3QKICAgIGZvciAodmFyIGsgaW4gZXhwb3J0cykgewogICAgICAgIHRoaXNba10gPSBleHBvcnRzW2tdOwogICAgfQp9OwoKCi8qKgogKiBDcmVhdGVzIGEgbmV3IERCIG9iamVjdCB3aXRoIG1ldGhvZHMgb3BlcmF0aW5nIG9uIHRoZSBkYXRhYmFzZSBhdCAndXJsJwogKgogKiBUaGUgREIgb2JqZWN0IGFsc28gZXhwb3NlcyB0aGUgc2FtZSBtb2R1bGUtbGV2ZWwgbWV0aG9kcyAoZWcsIGNyZWF0ZURhdGFiYXNlKQogKiBzbyBpdCBjYW4gYmUgdXNlZCBpbi1wbGFjZSBvZiB0aGUgZGIgZXhwb3J0cyBvYmplY3QsIGZvciBleGFtcGxlOgogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHZhciBkYiA9IHJlcXVpcmUoJ2RiJykudXNlKCdteWRiJyk7CiAqCiAqIGRiLmNyZWF0ZURhdGFiYXNlKCdleGFtcGxlJywgZnVuY3Rpb24gKGVyciwgcmVzcCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nCiAqIH0pOwogKiBgYGAKICoKICogQG5hbWUgdXNlKHVybCkKICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSB1cmwgdG8gYmluZCB0aGUgbmV3IERCIG9iamVjdCB0bwogKiBAcmV0dXJucyB7REJ9CiAqIEBhcGkgcHVibGljCiAqLwoKLy8gVE9ETzogaGFuZGxlIGZ1bGwgdXJscywgbm90IGp1c3QgZGIgbmFtZXMKZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAodXJsKSB7CiAgICAvKiBGb3JjZSBsZWFkaW5nIHNsYXNoOyBtYWtlIGFic29sdXRlIHBhdGggKi8KICAgIHJldHVybiBuZXcgREIoKHVybC5zdWJzdHIoMCwgMSkgIT09ICcvJyA/ICcvJyA6ICcnKSArIHVybCk7Cn07CgovKioKICogQXR0ZW1wdHMgdG8gZ3Vlc3MgdGhlIGN1cnJlbnQgREIgbmFtZSBhbmQgcmV0dXJuIGEgREIgb2JqZWN0IHVzaW5nIHRoYXQuCiAqIFNob3VsZCB3b3JrIHJlbGlhYmx5IHVubGVzcyBydW5uaW5nIGJlaGluZCBhIHZpcnR1YWwgaG9zdC4KICoKICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjdXJyZW50IGRhdGFiYXNlIHVybCBjYW5ub3QgYmUgZGV0ZWN0ZWQuCiAqCiAqIFRoZSBEQiBvYmplY3QgYWxzbyBleHBvc2VzIHRoZSBzYW1lIG1vZHVsZS1sZXZlbCBtZXRob2RzIChlZywgY3JlYXRlRGF0YWJhc2UpCiAqIHNvIGl0IGNhbiBiZSB1c2VkIGluLXBsYWNlIG9mIHRoZSBkYiBleHBvcnRzIG9iamVjdCwgZm9yIGV4YW1wbGU6CiAqCiAqIGBgYGphdmFzY3JpcHQKICogdmFyIGRiID0gcmVxdWlyZSgnZGInKS5jdXJyZW50KCk7CiAqCiAqIGRiLmNyZWF0ZURhdGFiYXNlKCdleGFtcGxlJywgZnVuY3Rpb24gKGVyciwgcmVzcCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nCiAqIH0pOwogKiBgYGAKICoKICogQG5hbWUgY3VycmVudCgpCiAqIEByZXR1cm5zIHtEQn0KICogQGFwaSBwdWJsaWMKICovCgpleHBvcnRzLmN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7CiAgICAvLyBndWVzcyBjdXJyZW50IGRiIHVybCBldGMKICAgIHZhciBjdXJyID0gZXhwb3J0cy5ndWVzc0N1cnJlbnQoKTsKICAgIGlmICghY3VycikgewogICAgICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgICAgICAgJ0Nhbm5vdCBndWVzcyBjdXJyZW50IGRhdGFiYXNlIFVSTCwgaWYgcnVubmluZyBiZWhpbmQgYSB2aXJ0dWFsICcgKwogICAgICAgICAgICAnaG9zdCB5b3UgbmVlZCB0byBleHBsaWNpdGx5IHNldCB0aGUgZGF0YWJhc2UgVVJMIHVzaW5nICcgKwogICAgICAgICAgICAnZGIudXNlKGRhdGFiYXNlX3VybCkgaW5zdGVhZCBvZiBkYi5jdXJyZW50KCknCiAgICAgICAgKTsKICAgIH0KICAgIHJldHVybiBleHBvcnRzLnVzZShjdXJyLmRiKTsKfTsKCgovKioKICogRmV0Y2hlcyBhIHJld3JpdGUgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcCBpcyBydW5uaW5nIG9uLiBSZXN1bHRzCiAqIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sKICogcmVzZXJ2ZWQgZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5nZXRSZXdyaXRlKG5hbWUsIHBhdGgsIFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRlc2lnbiBkb2MKICogQHBhcmFtIHtTdHJpbmd9IHBhdGgKICogQHBhcmFtIHtPYmplY3R9IHEgKG9wdGlvbmFsKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmdldFJld3JpdGUgPSBmdW5jdGlvbiAobmFtZSwgcGF0aCwgLypvcHRpb25hbCovcSwgY2FsbGJhY2spIHsKICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQogICAgLy8gcHJlcGVuZCBmb3J3YXJkLXNsYXNoIGlmIG1pc3NpbmcKICAgIHBhdGggPSAocGF0aFswXSA9PT0gJy8nKSA/IHBhdGg6ICcvJyArIHBhdGg7CgogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IGV4cG9ydHMuc3RyaW5naWZ5UXVlcnkocSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiB0aGlzLnVybCArICcvX2Rlc2lnbi8nICsgZXhwb3J0cy5lbmNvZGUobmFtZSkgKyAnL19yZXdyaXRlJyArIHBhdGgsCiAgICAgICAgZGF0YTogZGF0YQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogUXVlcmllcyBhbGwgZGVzaWduIGRvY3VtZW50cyBpbiB0aGUgZGF0YWJhc2UuCiAqCiAqIEBuYW1lIERCLmFsbERlc2lnbkRvY3MoW3FdLCBjYWxsYmFjaykKICogQHBhcmFtIHtPYmplY3R9IHEgLSBxdWVyeSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gL19hbGxfZG9jcyAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuYWxsRGVzaWduRG9jcyA9IGZ1bmN0aW9uICgvKm9wdGlvbmFsKi9xLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CiAgICBxLnN0YXJ0a2V5ID0gJyJfZGVzaWduIic7CiAgICBxLmVuZGtleSA9ICciX2Rlc2lnbjAiJzsKICAgIHRoaXMuYWxsRG9jcyhxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIFF1ZXJpZXMgYWxsIGRvY3VtZW50cyBpbiB0aGUgZGF0YWJhc2UgKGluY2x1ZGUgZGVzaWduIGRvY3MpLgogKgogKiBAbmFtZSBEQi5hbGxEb2NzKFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7T2JqZWN0fSBxIC0gcXVlcnkgcGFyYW1ldGVycyB0byBwYXNzIHRvIC9fYWxsX2RvY3MgKG9wdGlvbmFsKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmFsbERvY3MgPSBmdW5jdGlvbiAoLypvcHRpb25hbCovcSwgY2FsbGJhY2spIHsKICAgIGlmICghY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IHE7CiAgICAgICAgcSA9IHt9OwogICAgfQogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IGV4cG9ydHMuc3RyaW5naWZ5UXVlcnkocSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiB0aGlzLnVybCArICcvX2FsbF9kb2NzJywKICAgICAgICBkYXRhOiBkYXRhLAogICAgICAgIGV4cGVjdF9qc29uOiB0cnVlCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBGZXRjaGVzIGEgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcCBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZQogKiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQKICogZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5nZXREb2MoaWQsIFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBpZAogKiBAcGFyYW0ge09iamVjdH0gcSAob3B0aW9uYWwpCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrKGVycixyZXNwb25zZSkKICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuZ2V0RG9jID0gZnVuY3Rpb24gKGlkLCAvKm9wdGlvbmFsKi9xLCBjYWxsYmFjaykgewogICAgaWYgKCFpZCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0RG9jIHJlcXVpcmVzIGFuIGlkIHBhcmFtZXRlciB0byB3b3JrIHByb3Blcmx5Jyk7CiAgICB9CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KICAgIHRyeSB7CiAgICAgICAgdmFyIGRhdGEgPSBleHBvcnRzLnN0cmluZ2lmeVF1ZXJ5KHEpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICB9CiAgICB2YXIgcmVxID0gewogICAgICAgIHVybDogdGhpcy51cmwgKyAnLycgKyBleHBvcnRzLmVuY29kZShpZCksCiAgICAgICAgZXhwZWN0X2pzb246IHRydWUsCiAgICAgICAgZGF0YTogZGF0YQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogU2F2ZXMgYSBkb2N1bWVudCB0byB0aGUgZGF0YWJhc2UgdGhlIGFwcCBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZQogKiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQKICogZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5zYXZlRG9jKGRvYywgY2FsbGJhY2spCiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCkRCLnByb3RvdHlwZS5zYXZlRG9jID0gZnVuY3Rpb24gKGRvYywgY2FsbGJhY2spIHsKICAgIHZhciBtZXRob2QsIHVybCA9IHRoaXMudXJsOwogICAgaWYgKGRvYy5faWQgPT09IHVuZGVmaW5lZCkgewogICAgICAgIG1ldGhvZCA9ICJQT1NUIjsKICAgIH0KICAgIGVsc2UgewogICAgICAgIG1ldGhvZCA9ICJQVVQiOwogICAgICAgIHVybCArPSAnLycgKyBkb2MuX2lkOwogICAgfQogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRvYyk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdHlwZTogbWV0aG9kLAogICAgICAgIHVybDogdXJsLAogICAgICAgIGRhdGE6IGRhdGEsCiAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLAogICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsCiAgICAgICAgZXhwZWN0X2pzb246IHRydWUKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgovKioKICogRGVsZXRlcyBhIGRvY3VtZW50IGZyb20gdGhlIGRhdGFiYXNlIHRoZSBhcHAgaXMgcnVubmluZyBvbi4gUmVzdWx0cyBhcmUKICogcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrIHJlc2VydmVkCiAqIGZvciBhbnkgZXhjZXB0aW9ucyB0aGF0IG9jY3VycmVkIChub2RlLmpzIHN0eWxlKS4KICoKICogQG5hbWUgREIucmVtb3ZlRG9jKGRvYywgY2FsbGJhY2spCiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCkRCLnByb3RvdHlwZS5yZW1vdmVEb2MgPSBmdW5jdGlvbiAoZG9jLCBjYWxsYmFjaykgewogICAgaWYgKCFkb2MuX2lkKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVEb2MgcmVxdWlyZXMgYW4gX2lkIGZpZWxkIGluIHlvdXIgZG9jdW1lbnQnKTsKICAgIH0KICAgIGlmICghZG9jLl9yZXYpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZURvYyByZXF1aXJlcyBhIF9yZXYgZmllbGQgaW4geW91ciBkb2N1bWVudCcpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB0eXBlOiAnREVMRVRFJywKICAgICAgICB1cmw6IHRoaXMudXJsICsgJy8nICsgZXhwb3J0cy5lbmNvZGUoZG9jLl9pZCkgKwogICAgICAgICAgICAgJz9yZXY9JyArIGV4cG9ydHMuZW5jb2RlKGRvYy5fcmV2KQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogRmV0Y2hlcyBhIHZpZXcgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcCBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZQogKiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQKICogZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQgKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5nZXRWaWV3KG5hbWUsIHZpZXcsIFtxXSwgY2FsbGJhY2spCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgZGVzaWduIGRvYyB0byB1c2UKICogQHBhcmFtIHtTdHJpbmd9IHZpZXcgLSBuYW1lIG9mIHRoZSB2aWV3CiAqIEBwYXJhbSB7T2JqZWN0fSBxIChvcHRpb25hbCkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKQogKiBAYXBpIHB1YmxpYwogKi8KCkRCLnByb3RvdHlwZS5nZXRWaWV3ID0gZnVuY3Rpb24gKG5hbWUsIHZpZXcsIC8qb3B0Ki9xLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CiAgICB2YXIgdmlld25hbWUgPSBleHBvcnRzLmVuY29kZSh2aWV3KTsKICAgIHRyeSB7CiAgICAgICAgdmFyIGRhdGEgPSBleHBvcnRzLnN0cmluZ2lmeVF1ZXJ5KHEpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICB9CiAgICB2YXIgcmVxID0gewogICAgICAgIHVybDogKHRoaXMudXJsICsKICAgICAgICAgICAgJy9fZGVzaWduLycgKyBleHBvcnRzLmVuY29kZShuYW1lKSArCiAgICAgICAgICAgICcvX3ZpZXcvJyArIHZpZXduYW1lCiAgICAgICAgKSwKICAgICAgICBleHBlY3RfanNvbjogdHJ1ZSwKICAgICAgICBkYXRhOiBkYXRhCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBGZXRjaGVzIGEgc3BhdGlhbCB2aWV3IGZyb20gdGhlIGRhdGFiYXNlIHRoZSBhcHAgaXMgcnVubmluZyBvbi4gUmVzdWx0cyBhcmUKICogcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrIHJlc2VydmVkCiAqIGZvciBhbnkgZXhjZXB0aW9ucyB0aGF0IG9jY3VycmVkIChub2RlLmpzIHN0eWxlKS4KICoKICogX19QYXJhbWV0ZXJzOl9fCiAqICogYmJveCAtIHRoZSBib3VuZGluZyBib3ggZmlsdGVyIGUuZy46IGJib3g6ICcwLDAsMTgwLDkwJwogKiAqIHBsYW5lX2JvdW5kcyAtIGUuZy46IHBsYW5lX2JvdW5kczogJy0xODAsLTkwLDE4MCw5MCcKICogKiBzdGFsZSAtIHN0YWxlOiAnb2snIHByZXZlbnRzIHRoZSBzcGF0aWFsIGluZGV4IHRvIGJlIHJlYnVpbHQKICogKiBjb3VudCAtIGNvdW50OiB0cnVlIHdpbGwgb25seSByZXR1cm4gdGhlIG51bWJlciBvZiBnZW9tZXRyaWVzCiAqCiAqIEBuYW1lIERCLmdldFNwYXRpYWxWaWV3KG5hbWUsIHZpZXcsIHEsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGRlc2lnbiBkb2MgdG8gdXNlCiAqIEBwYXJhbSB7U3RyaW5nfSB2aWV3IC0gbmFtZSBvZiB0aGUgdmlldwogKiBAcGFyYW0ge09iamVjdH0gcSAtIHF1ZXJ5IHBhcmFtZXRlcnMgKHNlZSBvcHRpb25zIGFib3ZlKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmdldFNwYXRpYWxWaWV3ID0gZnVuY3Rpb24gKG5hbWUsIHZpZXcsIHEsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KICAgIHZhciB2aWV3bmFtZSA9IGV4cG9ydHMuZW5jb2RlKHZpZXcpOwogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IGV4cG9ydHMuc3RyaW5naWZ5UXVlcnkocSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiAodGhpcy51cmwgKwogICAgICAgICAgICAnL19kZXNpZ24vJyArIGV4cG9ydHMuZW5jb2RlKG5hbWUpICsKICAgICAgICAgICAgJy9fc3BhdGlhbC8nICsgdmlld25hbWUKICAgICAgICApLAogICAgICAgIGV4cGVjdF9qc29uOiB0cnVlLAogICAgICAgIGRhdGE6IGRhdGEKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIFRyYW5zZm9ybXMgYW5kIGZldGNoZXMgYSB2aWV3IHRocm91Z2ggYSBsaXN0IGZyb20gdGhlIGRhdGFiYXNlIHRoZSBhcHAKICogaXMgcnVubmluZyBvbi4gUmVzdWx0cyBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjaywgd2l0aCB0aGUgZmlyc3QKICogYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrIHJlc2VydmVkIGZvciBhbnkgZXhjZXB0aW9ucyB0aGF0IG9jY3VycmVkCiAqIChub2RlLmpzIHN0eWxlKS4KICoKICogQG5hbWUgREIuZ2V0TGlzdChuYW1lLCBsaXN0LCB2aWV3LCBbcV0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGRlc2lnbiBkb2MgdG8gdXNlCiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0IC0gbmFtZSBvZiB0aGUgbGlzdCBmdW5jdGlvbgogKiBAcGFyYW0ge1N0cmluZ30gdmlldyAtIG5hbWUgb2YgdGhlIHZpZXcgdG8gYXBwbHkgdGhlIGxpc3QgZnVuY3Rpb24gdG8KICogQHBhcmFtIHtPYmplY3R9IHEgKG9wdGlvbmFsKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKLy8gVE9ETzogcnVuIGxpc3QgZnVuY3Rpb24gY2xpZW50LXNpZGU/CkRCLnByb3RvdHlwZS5nZXRMaXN0ID0gZnVuY3Rpb24gKG5hbWUsIGxpc3QsIHZpZXcsIC8qb3B0aW9uYWwqL3EsIGNhbGxiYWNrKSB7CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KICAgIHZhciBsaXN0bmFtZSA9IGV4cG9ydHMuZW5jb2RlKGxpc3QpOwogICAgdmFyIHZpZXduYW1lID0gZXhwb3J0cy5lbmNvZGUodmlldyk7CiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gZXhwb3J0cy5zdHJpbmdpZnlRdWVyeShxKTsKICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQogICAgdmFyIHJlcSA9IHsKICAgICAgICB1cmw6IHRoaXMudXJsICsgJy9fZGVzaWduLycgKyBleHBvcnRzLmVuY29kZShuYW1lKSArCiAgICAgICAgICAgICcvX2xpc3QvJyArIGxpc3RuYW1lICsgJy8nICsgdmlld25hbWUsCiAgICAgICAgZGF0YTogZGF0YQogICAgfTsKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCi8qKgogKiBUcmFuc2Zvcm1zIGFuZCBmZXRjaGVzIGEgZG9jdW1lbnQgdGhyb3VnaCBhIHNob3cgZnJvbSB0aGUgZGF0YWJhc2UgdGhlIGFwcAogKiBpcyBydW5uaW5nIG9uLiBSZXN1bHRzIGFyZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLCB3aXRoIHRoZSBmaXJzdAogKiBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2sgcmVzZXJ2ZWQgZm9yIGFueSBleGNlcHRpb25zIHRoYXQgb2NjdXJyZWQKICogKG5vZGUuanMgc3R5bGUpLgogKgogKiBAbmFtZSBEQi5nZXRTaG93KG5hbWUsIHNob3csIGRvY2lkLCBbcV0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGRlc2lnbiBkb2MgdG8gdXNlCiAqIEBwYXJhbSB7U3RyaW5nfSBzaG93IC0gbmFtZSBvZiB0aGUgc2hvdyBmdW5jdGlvbgogKiBAcGFyYW0ge1N0cmluZ30gZG9jaWQgLSBpZCBvZiB0aGUgZG9jdW1lbnQgdG8gYXBwbHkgdGhlIHNob3cgZnVuY3Rpb24gdG8KICogQHBhcmFtIHtPYmplY3R9IHEgKG9wdGlvbmFsKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKLy8gVE9ETzogcnVuIHNob3cgZnVuY3Rpb24gY2xpZW50LXNpZGU/CkRCLnByb3RvdHlwZS5nZXRTaG93ID0gZnVuY3Rpb24gKG5hbWUsIHNob3csIGRvY2lkLCAvKm9wdGlvbmFsKi9xLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CiAgICB0cnkgewogICAgICAgIHZhciBkYXRhID0gZXhwb3J0cy5zdHJpbmdpZnlRdWVyeShxKTsKICAgIH0KICAgIGNhdGNoIChlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgfQogICAgdmFyIHNob3duYW1lID0gZXhwb3J0cy5lbmNvZGUoc2hvdyk7CiAgICB2YXIgc2hvd191cmwgPSB0aGlzLnVybCArICcvX2Rlc2lnbi8nICsKICAgICAgICBleHBvcnRzLmVuY29kZShuYW1lKSArICcvX3Nob3cvJyArIGV4cG9ydHMuZW5jb2RlKHNob3duYW1lKTsKICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiBzaG93X3VybCArIChkb2NpZCA/ICcvJyArIGV4cG9ydHMuZW5jb2RlKGRvY2lkKTogJycpLAogICAgICAgIGRhdGE6IGRhdGEKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIEZldGNoIGEgZGVzaWduIGRvY3VtZW50IGZyb20gQ291Y2hEQi4KICoKICogQG5hbWUgREIuZ2V0RGVzaWduRG9jKG5hbWUsIGNhbGxiYWNrKQogKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiAoaS5lLiBwYXRoIHRvKSB0aGUgZGVzaWduIGRvY3VtZW50IHdpdGhvdXQgdGhlCiAqICAgICBwcmVjZWVkaW5nICJcX2Rlc2lnbi8iLgogKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSByZXF1ZXN0IGNvbXBsZXRlcy4KICogQGFwaSBwdWJsaWMKICovCgpEQi5wcm90b3R5cGUuZ2V0RGVzaWduRG9jID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7CiAgICB0aGlzLmdldERvYygnX2Rlc2lnbi8nICsgbmFtZSwgZnVuY3Rpb24gKGVyciwgZGRvYykgewogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkZG9jKTsKICAgIH0pOwp9OwoKLyoqCiAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRhdGFiYXNlLgogKgogKiBAbmFtZSBEQi5pbmZvKGNhbGxiYWNrKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsKICAgIHZhciByZXEgPSB7CiAgICAgICAgdXJsOiB0aGlzLnVybCwKICAgICAgICBleHBlY3RfanNvbjogdHJ1ZSwKICAgIH07CiAgICBleHBvcnRzLnJlcXVlc3QocmVxLCBjYWxsYmFjayk7Cn07CgoKLyoqCiAqIExpc3RlbiB0byB0aGUgY2hhbmdlcyBmZWVkIGZvciBhIGRhdGFiYXNlLgogKgogKiBfX09wdGlvbnM6X18KICogKiBfZmlsdGVyXyAtIHRoZSBmaWx0ZXIgZnVuY3Rpb24gdG8gdXNlCiAqICogX3NpbmNlXyAtIHRoZSB1cGRhdGVfc2VxIHRvIHN0YXJ0IGxpc3RlbmluZyBmcm9tCiAqICogX2hlYXJ0YmVhdF8gLSB0aGUgaGVhcnRiZWF0IHRpbWUgKGRlZmF1bHRzIHRvIDEwIHNlY29uZHMpCiAqICogX2luY2x1ZGVfZG9jc18gLSB3aGV0aGVyIHRvIGluY2x1ZGUgZG9jcyBpbiB0aGUgcmVzdWx0cwogKgogKiBSZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGUgY2FsbGJhY2sgd2lsbCBjYW5jZWwgdGhlIGNoYW5nZXMgbGlzdGVuZXIKICoKICogQG5hbWUgREIuY2hhbmdlcyhbcV0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge09iamVjdH0gcSAob3B0aW9uYWwpIHF1ZXJ5IHBhcmFtZXRlcnMgKHNlZSBvcHRpb25zIGFib3ZlKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayhlcnIscmVzcG9uc2UpCiAqIEBhcGkgcHVibGljCiAqLwoKLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gdXNlIGFuIEV2ZW50RW1pdHRlcgpEQi5wcm90b3R5cGUuY2hhbmdlcyA9IGZ1bmN0aW9uICgvKm9wdGlvbmFsKi9xLCBjYWxsYmFjaykgewogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gcTsKICAgICAgICBxID0ge307CiAgICB9CgogICAgdmFyIHRoYXQgPSB0aGlzOwoKICAgIHEgPSBxIHx8IHt9OwogICAgcS5mZWVkID0gJ2xvbmdwb2xsJzsKICAgIHEuaGVhcnRiZWF0ID0gcS5oZWFydGJlYXQgfHwgMTAwMDA7CgogICAgZnVuY3Rpb24gZ2V0Q2hhbmdlcyhzaW5jZSkgewogICAgICAgIHEuc2luY2UgPSBzaW5jZTsKICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgZGF0YSA9IGV4cG9ydHMuc3RyaW5naWZ5UXVlcnkocSk7CiAgICAgICAgfQogICAgICAgIGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgICAgICB9CiAgICAgICAgdmFyIHJlcSA9IHsKICAgICAgICAgICAgdHlwZTogJ0dFVCcsCiAgICAgICAgICAgIGV4cGVjdF9qc29uOiB0cnVlLAogICAgICAgICAgICB1cmw6IHRoYXQudXJsICsgJy9fY2hhbmdlcycsCiAgICAgICAgICAgIGRhdGE6IGRhdGEKICAgICAgICB9OwogICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uIChlcnIsIGRhdGEpIHsKICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7CiAgICAgICAgICAgICAgICBnZXRDaGFuZ2VzKGRhdGEubGFzdF9zZXEpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNiKTsKICAgIH0KCiAgICAvLyB1c2Ugc2V0VGltZW91dCB0byBwYXNzIGNvbnRyb2wgYmFjayB0byB0aGUgYnJvd3NlciBicmllZmx5IHRvCiAgICAvLyBhbGxvdyB0aGUgbG9hZGluZyBzcGlubmVyIHRvIHN0b3Agb24gcGFnZSBsb2FkCiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICAgICAgICBpZiAocS5oYXNPd25Qcm9wZXJ0eSgnc2luY2UnKSkgewogICAgICAgICAgICBnZXRDaGFuZ2VzKHEuc2luY2UpOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgdGhhdC5pbmZvKGZ1bmN0aW9uIChlcnIsIGluZm8pIHsKICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGdldENoYW5nZXMoaW5mby51cGRhdGVfc2VxKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfQogICAgfSwgMCk7Cn07CgoKLyoqCiAqIFNhdmVzIGEgbGlzdCBvZiBkb2N1bWVudHMsIHdpdGhvdXQgdXNpbmcgc2VwYXJhdGUgcmVxdWVzdHMuCiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBDb3VjaERCJ3MgSFRUUCBidWxrIGRvY3VtZW50IEFQSSAoX2J1bGtfZG9jcykuCiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGFuICdpZCcKICogYW5kIGEgJ3JldicgZmllbGQuIFRoZSByZXR1cm4gdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB5b3UKICogcHJvdmlkZSB2aWEgaXRzIHNlY29uZCBhcmd1bWVudDsgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBjYWxsYmFjawogKiBpcyByZXNlcnZlZCBmb3IgYW55IGV4Y2VwdGlvbnMgdGhhdCBvY2N1cnJlZCAobm9kZS5qcyBzdHlsZSkuCiAqCiAqICoqT3B0aW9uczoqKgogKiAqICphbGxfb3JcX25vdGhpbmcqIC0gUmVxdWlyZSB0aGF0IGFsbCBkb2N1bWVudHMgYmUgc2F2ZWQKICogICBzdWNjZXNzZnVsbHkgKG9yIHNhdmVkIHdpdGggYSBjb25mbGljdCk7IG90aGVyd2lzZSByb2xsCiAqICAgYmFjayB0aGUgb3BlcmF0aW9uLgogKgogKiBAbmFtZSBEQi5idWxrU2F2ZShkb2NzLCBbb3B0aW9uc10sIGNhbGxiYWNrKQogKiBAcGFyYW0ge0FycmF5fSBkb2NzIEFuIGFycmF5IG9mIGRvY3VtZW50czsgZWFjaCBkb2N1bWVudCBpcyBhbiBvYmplY3QKICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKG9wdGlvbmFsKSBPcHRpb25zIGZvciB0aGUgYnVsay1zYXZlIG9wZXJhdGlvbi4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKSAtIEEgZnVuY3Rpb24gdG8gYWNjZXB0IHJlc3VsdHMKICogICAgICAgICAgYW5kL29yIGVycm9ycy4gRG9jdW1lbnQgdXBkYXRlIGNvbmZsaWN0cyBhcmUgcmVwb3J0ZWQgaW4gdGhlCiAqICAgICAgICAgIHJlc3VsdHMgYXJyYXkuCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmJ1bGtTYXZlID0gZnVuY3Rpb24gKGRvY3MsIC8qb3B0aW9uYWwqLyBvcHRpb25zLCBjYWxsYmFjaykgewogICAgaWYgKCFfLmlzQXJyYXkoZG9jcykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICdidWxrU2F2ZSByZXF1aXJlcyBhbiBhcnJheSBvZiBkb2N1bWVudHMgdG8gd29yayBwcm9wZXJseScKICAgICAgICApOwogICAgfQogICAgaWYgKCFjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gb3B0aW9uczsKICAgICAgICBvcHRpb25zID0ge307CiAgICB9CiAgICBvcHRpb25zLmRvY3MgPSBkb2NzOwogICAgdHJ5IHsKICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICB9CiAgICB2YXIgcmVxID0gewogICAgICAgIHR5cGU6ICdQT1NUJywKICAgICAgICB1cmw6IHRoaXMudXJsICsgJy9fYnVsa19kb2NzJywKICAgICAgICBkYXRhOiBkYXRhLAogICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSwKICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLAogICAgICAgIGV4cGVjdF9qc29uOiB0cnVlCiAgICB9OwogICAgZXhwb3J0cy5yZXF1ZXN0KHJlcSwgY2FsbGJhY2spOwp9OwoKCi8qKgogKiBSZXF1ZXN0cyBhIGxpc3Qgb2YgZG9jdW1lbnRzLCB1c2luZyBvbmx5IGEgc2luZ2xlIEhUVFAgcmVxdWVzdC4KICogVGhpcyBmdW5jdGlvbiB1c2VzIENvdWNoREIncyBIVFRQIGJ1bGsgZG9jdW1lbnQgQVBJIChfYWxsX2RvY3MpLgogKiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2Ygd2hpY2ggaXMgYSBkb2N1bWVudC4KICogVGhlIHJldHVybiB2YWx1ZSBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHlvdSBwcm92aWRlIHZpYSBpdHMgc2Vjb25kCiAqIGFyZ3VtZW50OyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrIGlzIHJlc2VydmVkIGZvciBhbnkKICogZXhjZXB0aW9ucyB0aGF0IG9jY3VycmVkIChub2RlLmpzIHN0eWxlKS4KICoKICogQG5hbWUgREIuYnVsa0dldChrZXlzLCBbcV0sIGNhbGxiYWNrKQogKiBAcGFyYW0ge0FycmF5fSBrZXlzIEFuIGFycmF5IG9mIGRvY3VtZW50cyBpZGVudGlmaWVycyAoaS5lLiBzdHJpbmdzKS4KICogQHBhcmFtIHtPYmplY3R9IHEgKG9wdGlvbmFsKSBRdWVyeSBwYXJhbWV0ZXJzIGZvciB0aGUgYnVsay1yZWFkIG9wZXJhdGlvbi4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2soZXJyLHJlc3BvbnNlKSAtIEEgZnVuY3Rpb24gdG8gYWNjZXB0IHJlc3VsdHMKICogICAgICAgICAgYW5kL29yIGVycm9ycy4gRG9jdW1lbnQgdXBkYXRlIGNvbmZsaWN0cyBhcmUgcmVwb3J0ZWQgaW4gdGhlCiAqICAgICAgICAgIHJlc3VsdHMgYXJyYXkuCiAqIEBhcGkgcHVibGljCiAqLwoKREIucHJvdG90eXBlLmJ1bGtHZXQgPSBmdW5jdGlvbiAoa2V5cywgLypvcHRpb25hbCovIHEsIGNhbGxiYWNrKSB7CiAgICBpZiAoa2V5cyAmJiAhXy5pc0FycmF5KGtleXMpKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICAgICAnYnVsa0dldCByZXF1aXJlcyB0aGF0IF9pZCB2YWx1ZXMgYmUgc3VwcGxpZWQgYXMgYSBsaXN0JwogICAgICAgICk7CiAgICB9CiAgICBpZiAoIWNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBxOwogICAgICAgIHEgPSB7fTsKICAgIH0KCiAgICAvKiBFbmNvZGUgZXZlcnkgcXVlcnktc3RyaW5nIG9wdGlvbjoKICAgICAgICBDb3VjaERCIHJlcXVpcmVzIHRoYXQgdGhlc2UgYmUgSlNPTiwgZXZlbiB0aG91Z2ggdGhleQogICAgICAgIHdpbGwgYmUgVVJMLWVuY29kZWQgYXMgcGFydCBvZiB0aGUgcmVxdWVzdCBwcm9jZXNzLiAqLwoKICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgayBpbiBxKSB7CiAgICAgICAgICAgIHFba10gPSBKU09OLnN0cmluZ2lmeShxW2tdKTsKICAgICAgICB9CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgIH0KCiAgICAvKiBNYWtlIHJlcXVlc3Q6CiAgICAgICAgSWYgd2UgaGF2ZSBhIGxpc3Qgb2Yga2V5cywgdXNlIGEgcG9zdCByZXF1ZXN0IGNvbnRhaW5pbmcKICAgICAgICBhIEpTT04tZW5jb2RlZCBsaXN0IG9mIGtleXMuIE90aGVyd2lzZSwgdXNlIGEgZ2V0IHJlcXVlc3QuICovCgogICAgdmFyIHJlcSA9IHsKICAgICAgICBleHBlY3RfanNvbjogdHJ1ZSwKICAgICAgICB1cmw6IHRoaXMudXJsICsgJy9fYWxsX2RvY3MnICsgZXhwb3J0cy5lc2NhcGVVcmxQYXJhbXMocSkKICAgIH07CiAgICBpZiAoa2V5cykgewogICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoeyBrZXlzOiBrZXlzfSk7CiAgICAgICAgfQogICAgICAgIGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgICAgICB9CiAgICAgICAgcmVxID0gXy5leHRlbmQocmVxLCB7CiAgICAgICAgICAgIHR5cGU6ICdQT1NUJywKICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLAogICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLAogICAgICAgICAgICBkYXRhOiBkYXRhCiAgICAgICAgfSk7CiAgICB9IGVsc2UgewogICAgICAgIHJlcSA9IF8uZXh0ZW5kKHJlcSwgewogICAgICAgICAgICB0eXBlOiAnR0VUJwogICAgICAgIH0pOwogICAgfQoKICAgIGV4cG9ydHMucmVxdWVzdChyZXEsIGNhbGxiYWNrKTsKfTsKCgovKioKICogREIgbWV0aG9kcyBjYW4gb25seSBiZSBjYWxsZWQgY2xpZW50LXNpZGUKICovCgpfLmVhY2goXy5rZXlzKERCLnByb3RvdHlwZSksIGZ1bmN0aW9uIChrKSB7CiAgICB2YXIgX2ZuID0gREIucHJvdG90eXBlW2tdOwogICAgREIucHJvdG90eXBlW2tdID0gZnVuY3Rpb24gKCkgewogICAgICAgIGlmICghaXNCcm93c2VyKCkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGsgKyAnIGNhbm5vdCBiZSBjYWxsZWQgc2VydmVyLXNpZGUnKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9mbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKfSk7CgoKfSl9OwoKLyoqKioqKioqKiogc2Vzc2lvbiAqKioqKioqKioqLwoKa2Fuc28ubW9kdWxlQ2FjaGVbInNlc3Npb24iXSA9IHtsb2FkOiAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSkgewoKLyoqCiAqICMjIFNlc3Npb24gbW9kdWxlCiAqCiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHNlc3Npb24gbWFuYWdlbWVudC4gTG9nZ2luZyBpbiwKICogbG9nZ2luZyBvdXQgYW5kIGNoZWNraW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgdXNlcidzIHNlc3Npb24uCiAqCiAqIEZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBmb2xsb3cgdGhlIG5vZGUuanMgY2FsbGJhY2sgc3R5bGUuIFRoZSBmaXJzdAogKiBhcmd1bWVudCBpcyBhbiBlcnJvciBvYmplY3QgKGlmIG9uZSBvY2N1cnJlZCksIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIGFyZQogKiB0aGUgcmVzdWx0cyBvZiB0aGUgb3BlcmF0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYWx3YXlzIHRoZSBsYXN0IGFyZ3VtZW50IHRvIGEKICogZnVuY3Rpb24uCiAqCiAqCiAqICMjIyBFdmVudHMKICoKICogVGhlIHNlc3Npb24gbW9kdWxlIGlzIGFuIEV2ZW50RW1pdHRlci4gU2VlIHRoZQogKiBbZXZlbnRzIHBhY2thZ2VdKGh0dHA6Ly9rYW4uc28vcGFja2FnZXMvZGV0YWlscy9ldmVudHMpIGZvciBtb3JlIGluZm9ybWF0aW9uLgogKgogKiAjIyMjIGNoYW5nZQogKgogKiBFbWl0dGVkIHdoZW5ldmVyIGEgY2hhbmdlIHRvIHRoZSB1c2VyJ3Mgc2Vzc2lvbiBpcyBkZXRlY3RlZCwgdGhpcwogKiBjYW4gb2NjdXIgYXMgdGhlIHJlc3VsdCBvZiBhIGxvZ2luL2xvZ291dCBjYWxsIG9yIGJ5IGdldHRpbmcgdGhlIHVzZXIncwogKiBzZXNzaW9uIGluZm8gKGFuZCBpdCdzIGNoYW5nZWQpLgogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHZhciBzZXNzaW9uID0gcmVxdWlyZSgic2Vzc2lvbiIpOwogKgogKiBzZXNzaW9uLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAodXNlckN0eCkgewogKiAgICAgLy8gdXBkYXRlIHNlc3Npb24gaW5mb3JtYXRpb24sIGVnICJMb2dnZWQgaW4gYXMgLi4uIgogKiB9KTsKICogYGBgCiAqCiAqIEBtb2R1bGUKICovCgoKdmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpLAogICAgZGIgPSByZXF1aXJlKCdkYicpOwoKCi8qKgogKiBRdWljayB1dGlsaXR5IGZ1bmN0aW9uIGZvciB0ZXN0aW5nIGlmIHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXIsIHNpbmNlCiAqIHRoZXNlIGZ1bmN0aW9ucyB3b24ndCBydW4gb24gQ291Y2hEQiBzZXJ2ZXItc2lkZQogKi8KCmZ1bmN0aW9uIGlzQnJvd3NlcigpIHsKICAgIHJldHVybiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKTsKfQoKLyoqCiAqIFdoZW4gYSBkYiBjYWxsIHJlc3VsdHMgaW4gYW4gdW5hdXRob3JpemVkIHJlc3BvbnNlLCB0aGUgdXNlcidzIHNlc3Npb24gaXMKICogY2hlY2tlZCB0byBzZWUgaWYgdGhlaXIgc2Vzc2lvbiBoYXMgdGltZWQgb3V0IG9yIHRoZXkndmUgbG9nZ2VkIG91dCBpbgogKiBhbm90aGVyIHNjcmVlbi4KICoKICogVGhpcyBjaGVjayBpcyB0aHJvdHRsZWQgdG8gb25jZSBwZXIgc2Vjb25kLCB0byBhdm9pZCBmbG9vZGluZyB0aGUgc2VydmVyIGlmCiAqIG11bHRpcGxlIHJlcXVlc3RzIGFyZSBtYWRlIHdpdGggaW5jb3JyZWN0IHBlcm1pc3Npb25zLgogKi8KCnZhciBsYXN0X3Nlc3Npb25fY2hlY2sgPSAwOwoKZGIub24oJ3VuYXV0aG9yaXplZCcsIGZ1bmN0aW9uIChyZXEpIHsKICAgIC8vIGRiIGNhbGwgcmV0dXJuZWQgJ1VuYXV0aG9yaXplZCcsIGNoZWNrIHRoZSB1c2VyJ3Mgc2Vzc2lvbiBpZiBpdCdzIG5vdAogICAgLy8gYmVlbiBjaGVja2VkIG9uIGFuICdVbmF1dGhvcml6ZWQnIHJlcHNvbnNlIGluIHRoZSBsYXN0IHNlY29uZAogICAgaWYgKGxhc3Rfc2Vzc2lvbl9jaGVjayA8IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gMTAwMCkgewogICAgICAgIGV4cG9ydHMuaW5mbygpOwogICAgfQp9KTsKCgovKioKICogVGhpcyBtb2R1bGUgaXMgYW4gRXZlbnRFbWl0dGVyLCB1c2VkIGZvciBoYW5kbGluZyAnY2hhbmdlJyBldmVudHMKICovCgp2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTsKCgovKioKICogQXR0ZW1wdCB0byBsb2dpbiB1c2luZyB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIHByb3ZpZGVkLgogKgogKiBAbmFtZSBsb2dpbih1c2VybmFtZSwgcGFzc3dvcmQsIGNhbGxiYWNrKQogKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgLSB0aGUgdXNlcm5hbWUgdG8gbG9naW4gd2l0aAogKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgLSB0aGUgdXNlcidzIHBhc3N3b3JkICh1bmhhc2hlZCkKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBsb2dpbgogKiAgICAgYXR0ZW1wdAogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHNlc3Npb24ubG9naW4oJ3Rlc3R1c2VyJywgJ3Bhc3N3b3JkJywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHsKICogICAgIGlmIChlcnIpIC8vIGFuIGVycm9yIG9jY3VycmVkIGxvZ2dpbmcgaW4KICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3MKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMubG9naW4gPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBjYWxsYmFjaykgewogICAgaWYgKCFpc0Jyb3dzZXIoKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignbG9naW4gY2Fubm90IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZScpOwogICAgfQogICAgZGIucmVxdWVzdCh7CiAgICAgICAgdHlwZTogIlBPU1QiLAogICAgICAgIHVybDogIi9fc2Vzc2lvbiIsCiAgICAgICAgZGF0YToge25hbWU6IHVzZXJuYW1lLCBwYXNzd29yZDogcGFzc3dvcmR9CiAgICB9LAogICAgZnVuY3Rpb24gKGVyciwgcmVzcCkgewogICAgICAgIGlmIChyZXNwICYmIHJlc3Aub2spIHsKICAgICAgICAgICAgLy8gVE9ETzogZm9yIHNvbWUgcmVhc29uIHJlc3AubmFtZSBpcyBzZXQgdG8gbnVsbCBpbiB0aGUgcmVzcG9uc2UKICAgICAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlIHJvbGVzIGFyZSBjb3JyZWN0IGZvciB0aGUgdXNlciEgTG9vayBpbnRvIHRoaXMKICAgICAgICAgICAgLy8gYW5kIHNlZSBpZiBpdHMgYSBidWcgaW4gY291Y2hkYiwgZm9yIG5vdywganVzdCB1c2luZyB0aGUgdXNlcm5hbWUKICAgICAgICAgICAgLy8gZ2l2ZW4gdG8gdGhlIGxvZ2luIGZ1bmN0aW9uIGluc3RlYWQsIHNpbmNlIHdlIGtub3cgdGhlIGxvZ2luCiAgICAgICAgICAgIC8vIHJlcXVlc3Qgd2FzIGFjY2VwdGVkLgogICAgICAgICAgICBleHBvcnRzLnVzZXJDdHggPSB7bmFtZTogdXNlcm5hbWUsIHJvbGVzOiByZXNwLnJvbGVzfTsKICAgICAgICAgICAgZXhwb3J0cy5zZXNzaW9uID0ge3VzZXJDdHg6IGV4cG9ydHMudXNlckN0eH07CiAgICAgICAgICAgIGV4cG9ydHMuZW1pdCgnY2hhbmdlJywgZXhwb3J0cy51c2VyQ3R4KTsKICAgICAgICB9CiAgICAgICAgaWYgKGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcCk7CiAgICAgICAgfQogICAgfSk7Cn07CgoKLyoqCiAqIExvZ3Mgb3V0IHRoZSBjdXJyZW50IHVzZXIuCiAqCiAqIEBuYW1lIGxvZ291dChjYWxsYmFjaykKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBsb2dvdXQKICogICAgIGF0dGVtcHQKICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiBzZXNzaW9uLmxvZ291dChmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkgewogKiAgICAgaWYgKGVycikgLy8gYW4gZXJyb3Igb2NjdXJyZWQgbG9nZ2luZyBvdXQKICogICAgIGVsc2UgICAgIC8vIHN1Y2Nlc3MKICogfSk7CiAqIGBgYAogKi8KCmV4cG9ydHMubG9nb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7CiAgICBpZiAoIWlzQnJvd3NlcigpKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2dvdXQgY2Fubm90IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZScpOwogICAgfQogICAgZGIucmVxdWVzdCh7CiAgICAgICAgdHlwZTogIkRFTEVURSIsCiAgICAgICAgdXJsOiAiL19zZXNzaW9uIiwgLy8gZG9uJ3QgbmVlZCBiYXNlVVJMLCAvX3Nlc3Npb24gYWx3YXlzIGF2YWlsYWJsZQogICAgICAgIHVzZXJuYW1lOiAiXyIsCiAgICAgICAgcGFzc3dvcmQgOiAiXyIKICAgIH0sCiAgICBmdW5jdGlvbiAoZXJyLCByZXNwKSB7CiAgICAgICAgaWYgKHJlc3AgJiYgcmVzcC5vaykgewogICAgICAgICAgICBleHBvcnRzLnVzZXJDdHggPSB7bmFtZTogbnVsbCwgcm9sZXM6IFtdfTsKICAgICAgICAgICAgZXhwb3J0cy5zZXNzaW9uID0ge3VzZXJDdHg6IGV4cG9ydHMudXNlckN0eH07CiAgICAgICAgICAgIGV4cG9ydHMuZW1pdCgnY2hhbmdlJywgZXhwb3J0cy51c2VyQ3R4KTsKICAgICAgICB9CiAgICAgICAgaWYgKGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcCk7CiAgICAgICAgfQogICAgfSk7Cn07CgoKLyoqCiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdXNlcidzIHNlc3Npb24gaW5mb3JtYXRpb24uIFRoZSBpbmZvIG9iamVjdCBjb250YWlucyBhCiAqIGB1c2VyQ3R4YCBwcm9wZXJ0eSBhbmQgYW4gYGluZm9gIHByb3BlcnR5LiBUaGUgZmlyc3QgY29udGFpbnMgdGhlIG5hbWUgYW5kCiAqIHJvbGVzIG9mIHRoZSBjdXJyZW50IHVzZXIsIHRoZSBzZWNvbmQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIKICogZGF0YWJhc2UgYW5kIGF1dGhlbnRpY2F0aW9uIGhhbmRsZXJzLgogKgogKiBAbmFtZSBpbmZvKGNhbGxiYWNrKQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBzZXNzaW9uIGluZm9ybWF0aW9uCiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogc2Vzc2lvbi5pbmZvKGZ1bmN0aW9uIChlcnIsIGluZm8pIHsKICogICAgIGlmIChlcnIpIC8vIGFuIGVycm9yIG9jY3VycmVkIGdldHRpbmcgc2Vzc2lvbiBpbmZvCiAqICAgICBlbHNlICAgICAvLyBzdWNjZXNzCiAqIH0pOwogKiBgYGAKICovCgpleHBvcnRzLmluZm8gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsKICAgIGlmICghaXNCcm93c2VyKCkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZm8gY2Fubm90IGJlIGNhbGxlZCBzZXJ2ZXItc2lkZScpOwogICAgfQogICAgZGIucmVxdWVzdCh7CiAgICAgICAgdHlwZTogIkdFVCIsCiAgICAgICAgdXJsOiAiL19zZXNzaW9uIgogICAgfSwKICAgIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHsKICAgICAgICB2YXIgb2xkVXNlckN0eCA9IGV4cG9ydHMudXNlckN0eDsKICAgICAgICBleHBvcnRzLnNlc3Npb24gPSByZXNwOwogICAgICAgIGV4cG9ydHMudXNlckN0eCA9IChyZXNwICYmIHJlc3AudXNlckN0eCkgfHwge25hbWU6IG51bGwsIHJvbGVzOiBbXX07CiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgY2hlY2sgZm9yIGRpZmZlcmVuY2VzIGluIG1vcmUgdGhhbiBqdXN0IG5hbWU/CiAgICAgICAgaWYgKCFvbGRVc2VyQ3R4IHx8IG9sZFVzZXJDdHgubmFtZSAhPT0gZXhwb3J0cy51c2VyQ3R4Lm5hbWUpIHsKICAgICAgICAgICAgZXhwb3J0cy5lbWl0KCdjaGFuZ2UnLCBleHBvcnRzLnVzZXJDdHgpOwogICAgICAgIH0KICAgICAgICBpZiAoY2FsbGJhY2spIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwKTsKICAgICAgICB9CiAgICB9KTsKfTsKCgp9KX07CgovKioqKioqKioqKiBldmVudHMgKioqKioqKioqKi8KCmthbnNvLm1vZHVsZUNhY2hlWyJldmVudHMiXSA9IHtsb2FkOiAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSkgewoKLyoqCiAqICMjIEV2ZW50cyBtb2R1bGUKICoKICogVGhpcyBpcyBhIGJyb3dzZXIgcG9ydCBvZiB0aGUgbm9kZS5qcyBldmVudHMgbW9kdWxlLiBNYW55IG9iamVjdHMgYW5kCiAqIG1vZHVsZXMgZW1pdCBldmVudHMgYW5kIHRoZXNlIGFyZSBpbnN0YW5jZXMgb2YgZXZlbnRzLkV2ZW50RW1pdHRlci4KICoKICogWW91IGNhbiBhY2Nlc3MgdGhpcyBtb2R1bGUgYnkgZG9pbmc6IGByZXF1aXJlKCJldmVudHMiKWAKICoKICogRnVuY3Rpb25zIGNhbiB0aGVuIGJlIGF0dGFjaGVkIHRvIG9iamVjdHMsIHRvIGJlIGV4ZWN1dGVkIHdoZW4gYW4gZXZlbnQgaXMKICogZW1pdHRlZC4gVGhlc2UgZnVuY3Rpb25zIGFyZSBjYWxsZWQgbGlzdGVuZXJzLgogKgogKiBAbW9kdWxlCiAqLwoKCi8qKgogKiBUbyBhY2Nlc3MgdGhlIEV2ZW50RW1pdHRlciBjbGFzcywgcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLgogKgogKiBXaGVuIGFuIEV2ZW50RW1pdHRlciBpbnN0YW5jZSBleHBlcmllbmNlcyBhbiBlcnJvciwgdGhlIHR5cGljYWwgYWN0aW9uIGlzIHRvCiAqIGVtaXQgYW4gJ2Vycm9yJyBldmVudC4gRXJyb3IgZXZlbnRzIGFyZSB0cmVhdGVkIGFzIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGVyZQogKiBpcyBubyBsaXN0ZW5lciBmb3IgaXQsIHRoZW4gdGhlIGRlZmF1bHQgYWN0aW9uIGlzIGZvciB0aGUgZXJyb3IgdG8gdGhyb3cuCiAqCiAqIEFsbCBFdmVudEVtaXR0ZXJzIGVtaXQgdGhlIGV2ZW50ICduZXdMaXN0ZW5lcicgd2hlbiBuZXcgbGlzdGVuZXJzIGFyZSBhZGRlZC4KICoKICogQG5hbWUgZXZlbnRzLkV2ZW50RW1pdHRlcgogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7CiAqCiAqIC8vIGNyZWF0ZSBhbiBldmVudCBlbWl0dGVyCiAqIHZhciBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpOwogKiBgYGAKICovCgp2YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTsKCnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7CiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nOwp9OwoKCi8qKgogKiBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmUKICogYWRkZWQgZm9yIGEgcGFydGljdWxhciBldmVudC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcKICogbWVtb3J5IGxlYWtzLiBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcwogKiBmdW5jdGlvbiBhbGxvd3MgdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuCiAqCiAqIEBuYW1lIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKG4pCiAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGxpc3RlbmVycwogKiBAYXBpIHB1YmxpYwogKi8KCi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4KLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoCi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLgovLwovLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3MKLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuCnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7CkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikgewogIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTsKICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjsKfTsKCgovKioKICogRXhlY3V0ZSBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgaW4gb3JkZXIgd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLgogKgogKiBAbmFtZSBlbWl0dGVyLmVtaXQoZXZlbnQsIFthcmcxXSwgW2FyZzJdLCBbLi4uXSkKICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUvaWQgdG8gZmlyZQogKiBAYXBpIHB1YmxpYwogKi8KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHsKICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuCiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHsKICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHwKICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkKICAgIHsKICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudAogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuIik7CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0KCiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTsKICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTsKICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTsKCiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHsKICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAvLyBmYXN0IGNhc2VzCiAgICAgIGNhc2UgMToKICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMjoKICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAzOgogICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIC8vIHNsb3dlcgogICAgICBkZWZhdWx0OgogICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfQogICAgcmV0dXJuIHRydWU7CgogIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkgewogICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwoKICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7CiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfQogICAgcmV0dXJuIHRydWU7CgogIH0gZWxzZSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQp9OwoKCi8qKgogKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LgogKgogKiBAbmFtZSBlbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lcikgfCBlbWl0dGVyLmFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikKICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUvaWQgdG8gbGlzdGVuIGZvcgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIHRoZSBldmVudAogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIHNlc3Npb24ub24oJ2NoYW5nZScsIGZ1bmN0aW9uICh1c2VyQ3R4KSB7CiAqICAgICBjb25zb2xlLmxvZygnc2Vzc2lvbiBjaGFuZ2VkIScpOwogKiB9KTsKICogYGBgCiAqLwoKLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjCi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCgpIGlzIGFsc28gZGVmaW5lZCB0aGVyZS4KRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7CiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikgewogICAgdGhyb3cgbmV3IEVycm9yKCdhZGRMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpOwogIH0KCiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9OwoKICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09ICJuZXdMaXN0ZW5lcnMiISBCZWZvcmUKICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCAibmV3TGlzdGVuZXJzIi4KICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpOwoKICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgewogICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjsKICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkgewoKICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrCiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHsKICAgICAgdmFyIG07CiAgICAgIGlmICh0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHsKICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVyczsKICAgICAgfSBlbHNlIHsKICAgICAgICBtID0gZGVmYXVsdE1heExpc3RlbmVyczsKICAgICAgfQoKICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHsKICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTsKICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICsKICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgKwogICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsCiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTsKICAgICAgICBjb25zb2xlLnRyYWNlKCk7CiAgICAgIH0KICAgIH0KCiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7CiAgfSBlbHNlIHsKICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LgogICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdOwogIH0KCiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjsKCi8qKgogKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudC4gVGhpcyBsaXN0ZW5lciBpcyBpbnZva2VkIG9ubHkgdGhlCiAqIG5leHQgdGltZSB0aGUgZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuCiAqCiAqIEBuYW1lIGVtaXR0ZXIub25jZShldmVudCwgbGlzdGVuZXIpCiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC0gVGhlIGV2ZW50IG5hbWUvaWQgdG8gbGlzdGVuIGZvcgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIHRoZSBldmVudAogKiBAYXBpIHB1YmxpYwogKgogKiBgYGBqYXZhc2NyaXB0CiAqIGRiLm9uY2UoJ3VuYXV0aG9yaXplZCcsIGZ1bmN0aW9uIChyZXEpIHsKICogICAgIC8vIHRoaXMgZXZlbnQgbGlzdGVuZXIgd2lsbCBmaXJlIG9uY2UsIHRoZW4gYmUgdW5ib3VuZAogKiB9KTsKICogYGBgCiAqLwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHsKICB2YXIgc2VsZiA9IHRoaXM7CiAgc2VsZi5vbih0eXBlLCBmdW5jdGlvbiBnKCkgewogICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTsKICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfSk7CgogIHJldHVybiB0aGlzOwp9OwoKLyoqCiAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LiBDYXV0aW9uOgogKiBjaGFuZ2VzIGFycmF5IGluZGljZXMgaW4gdGhlIGxpc3RlbmVyIGFycmF5IGJlaGluZCB0aGUgbGlzdGVuZXIuCiAqCiAqIEBuYW1lIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKQogKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS9pZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20KICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlCiAqIEBhcGkgcHVibGljCiAqCiAqIGBgYGphdmFzY3JpcHQKICogdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGluaXQpIHsKICogICAgIGNvbnNvbGUubG9nKCdkdWFsaXR5IGFwcCBsb2FkZWQnKTsKICogfTsKICogZGV2ZW50cy5vbignaW5pdCcsIGNhbGxiYWNrKTsKICogLy8gLi4uCiAqIGRldmVudHMucmVtb3ZlTGlzdGVuZXIoJ2luaXQnLCBjYWxsYmFjayk7CiAqIGBgYAogKi8KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikgewogIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHsKICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTsKICB9CgogIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXQogIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzOwoKICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTsKCiAgaWYgKGlzQXJyYXkobGlzdCkpIHsKICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGxpc3RlbmVyKTsKICAgIGlmIChpIDwgMCkgcmV0dXJuIHRoaXM7CiAgICBsaXN0LnNwbGljZShpLCAxKTsKICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKQogICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwogIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdID09PSBsaXN0ZW5lcikgewogICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTsKICB9CgogIHJldHVybiB0aGlzOwp9OwoKLyoqCiAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC4KICoKICogQG5hbWUgZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoW2V2ZW50XSkKICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gRXZlbnQgbmFtZS9pZCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgKG9wdGlvbmFsKQogKiBAYXBpIHB1YmxpYwogKi8KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkgewogIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXQogIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7CiAgcmV0dXJuIHRoaXM7Cn07CgovKioKICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuIFRoaXMgYXJyYXkgY2FuIGJlCiAqIG1hbmlwdWxhdGVkLCBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuCiAqCiAqIEBuYW1lIGVtaXR0ZXIubGlzdGVuZXJzKGV2ZW50KQogKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzIC0gVGhlIGV2ZW50IG5hbWUvaWQgdG8gcmV0dXJuIGxpc3RlbmVycyBmb3IKICogQGFwaSBwdWJsaWMKICoKICogYGBgamF2YXNjcmlwdAogKiBzZXNzaW9uLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoc3RyZWFtKSB7CiAqICAgICBjb25zb2xlLmxvZygnc2Vzc2lvbiBjaGFuZ2VkJyk7CiAqIH0pOwogKiBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3Qoc2Vzc2lvbi5saXN0ZW5lcnMoJ2NoYW5nZScpKSk7IC8vIFsgW0Z1bmN0aW9uXSBdCiAqIGBgYAogKi8KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkgewogIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTsKICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107CiAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHsKICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dOwogIH0KICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdOwp9OwoKCi8qKgogKiBAbmFtZSBlbWl0dGVyIEV2ZW50OiAnbmV3TGlzdGVuZXInCiAqCiAqIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCBhbnkgdGltZSBzb21lb25lIGFkZHMgYSBuZXcgbGlzdGVuZXIuCiAqCiAqIGBgYGphdmFzY3JpcHQKICogZW1pdHRlci5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7CiAqICAgICAvLyBuZXcgbGlzdGVuZXIgYWRkZWQKICogfSk7CiAqIGBgYAogKi8KCgp9KX07Cgo="
        }
    },
    "lib": {
        "app": "",
        "manage-tokens": "\nvar session = require(\"session\"),\n    users = require(\"users\"),\n    _ = require(\"underscore\")._;\n\nfunction log(msg) {\n    try{\n        console.log(msg)\n    } catch (e) {\n\n    }\n}\n\n\nfunction getOAuth(email, doc, regenerate) {\n    if (regenerate || !(doc.oauth \n        && doc.oauth.consumer_keys \n        && doc.oauth.consumer_keys[email]\n        && doc.oauth.tokens\n        && doc.oauth.tokens.node_sign_token)) {\n\n        doc.oauth = doc.oauth || {};\n        doc.oauth.consumer_keys = doc.oauth.consumer_keys || {};\n        doc.oauth.tokens = doc.oauth.tokens || {};\n\n        doc.oauth.consumer_keys[email] = exports.generateSecret(32);\n        doc.oauth.tokens.node_sign_token = exports.generateSecret(32);\n\n        if (!doc.roles || _.indexOf(doc.roles, \"node_sign\") == -1) {\n            doc.roles = doc.roles || [];\n            // doc.roles.push(\"node_sign\");\n        }\n\n        users.update(email, null, doc, function(err) {\n            if (err) {\n                log(err);\n            } else {\n                getUserInfo(email);\n            }\n        });\n\n    } else {\n        $(\".oauth\").show(500);\n        $(\"#consumer_key\").val(email)\n        $(\"#consumer_secret\").val(doc.oauth.consumer_keys[email]);\n        $(\"#token_secret\").val(doc.oauth.tokens.node_sign_token);\n    }\n}\n\nfunction getSigningInfo(email, doc) {\n    if (doc.lrsignature && doc.lrsignature.full_name) {\n        $(\"#full_name\").val(doc.lrsignature.full_name);\n    }\n}\n\nfunction setMessage(msg, wait, cb) {\n    if (!wait) {\n        wait = 10000;\n    }\n\n    $(\".msg\").fadeOut('fast').empty().text(msg).fadeIn('fast').delay(wait).fadeOut('slow').hide('fast');\n\n    if (cb) {\n        cb();\n    }\n}\n\nfunction resetForms() {\n    $(\".oauth\").hide(500);\n    $(\"#password\").val(\"\");\n    $(\"#verify_password\").val(\"\");\n    $(\"#password_set\").prop(\"checked\", false);\n    $(\"#consumer_key\").val(\"\");\n    $(\"#consumer_secret\").val(\"\");\n    $(\"#token_secret\").val(\"\");\n    $(\"#full_name\").val(\"\");\n}\n\nfunction setSigningInfo() {\n    full_name = $(\"#full_name\").val();\n    if ($.trim(full_name) !== \"\") {\n        session.info(function(err, session_info){\n            if (session_info.userCtx.name) {\n                users.get(session_info.userCtx.name, function(err, doc){\n                    doc.lrsignature = doc.lrsignature || {}\n                    doc.lrsignature.full_name = full_name;\n\n                    users.update(session_info.userCtx.name, null, doc, function(err) {\n                        if (err) {\n                            log(err);\n                            setMessage(\"Unable to save signing information.\");\n                        } else {\n                            setMessage(\"Information saved.\")\n                        }\n                    });\n                }); \n            };\n        });\n    }\n}\n\nfunction setPasswordInfo(email, doc) {\n    if (doc.password_sha) {\n        $(\"#password_set\").prop(\"checked\", true);\n    } else {\n        $(\"#password_set\").prop(\"checked\", false);\n    }\n}\n\nfunction getUserInfo(email) {\n    users.get(email, function(err, doc) {\n        if (!err) {\n            getOAuth(email, doc);\n            getSigningInfo(email, doc);\n            setPasswordInfo(email, doc);\n        }\n        else {\n            setMessage(err);\n        }\n    });\n}\n\nfunction revokeAndGenerate() {\n    session.info(function(err, session_info){\n        if (session_info.userCtx.name) {\n            users.get(session_info.userCtx.name, function (err, doc){\n                if (!err) {\n                   getOAuth(session_info.userCtx.name, doc, true); \n                }\n            });\n        } else {\n            sessionTimeout();\n        }\n    });\n}\n\nfunction sessionTimeout () {\n    setMessage(\"Session has timed out.\", 50000, function(){\n        window.location.reload();\n    });\n}\n\nfunction checkPasswordMatch() {\n    var passwd1 = $(\"#password\").val();\n    var passwd2 = $(\"#verify_password\").val();\n    if (passwd1 === \"\" || passwd2 === \"\" || passwd1 !== passwd2)\n        return false;\n    return true;\n}\n\nfunction savePassword() {\n    var passwd1 = $(\"#password\").val();\n    var passwd2 = $(\"#verify_password\").val();\n    if ( checkPasswordMatch() ) {\n        session.info(function(err, session_info) {\n            if (session_info.userCtx.name) {\n                users.get(session_info.userCtx.name, function(err, doc){\n                    doc.password = passwd1;\n\n                    users.update(session_info.userCtx.name, null, doc, function(err) {\n                        if (err) {\n                            log(err);\n                            setMessage(\"Unable to save publish password.\");\n                        } else {\n                            setMessage(\"Password saved.\");\n                            $(\"#password\").val(\"\");\n                            $(\"#verify_password\").val(\"\");\n                            $(\"#password_set\").prop(\"checked\", true);\n                        }\n                    });\n                }); \n            };\n        });\n    } else {\n        setMessage(\"Passwords do no match.\");\n    }\n}\n\n\nexports.registerCallbacks = function() {\n    $.couch.browserid.login(function(evt, err, info) { \n        try {\n            var email = null;\n            if (info && info.name) {\n                email = info.name;\n            } else if (info && info.email) {\n                email = info.email\n            }\n\n            if (email) {\n                log(email);\n                getUserInfo(email);\n            }\n        } catch (error) {\n\n        } finally {\n\n        } \n    });\n\n    $.couch.browserid.logout(function(evt, err, info){\n        resetForms();\n    });\n\n    $(\"#info_update\").bind('click', setSigningInfo);\n    $(\"#regenerate\").bind('click', revokeAndGenerate);\n    $(\"#save_password\").bind('click', savePassword);\n}\n\n\n// Simple secret key generator\nexports.generateSecret = function(length) {\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var secret = '';\n    for (var i = 0; i < length; i++) {\n        secret += tab.charAt(Math.floor(Math.random() * 64));\n    }\n    return secret;\n}\n\n"
    },
    "users": "/**\n * ## Users module\n *\n * Functions for querying, creating, updating and deleting user documents.\n *\n * Functions in this module follow the node.js callback style. The first\n * argument is an error object (if one occurred), the following arguments are\n * the results of the operation. The callback is always the last argument to a\n * function.\n *\n * @module\n */\n\n\nvar db = require('db'),\n    session = require('session'),\n    sha1 = require('sha1'),\n    _ = require('underscore')._;\n\n\n/**\n * Returns the authentication database for the current user's session.\n *\n * @name authdb(callback)\n * @param {Function} callback\n * @api private\n */\n\nvar authdb = function(callback) {\n    db.request({\n        type: \"GET\",\n        url: \"/_session\"\n    },\n    function (err, resp) {\n        if (err) {\n            return callback(err, null);\n        }\n        callback(null, resp.info.authentication_db);\n    });\n};\n\n\n/**\n * Returns successful if username is in admin database.\n *\n * @name getAdmin(username, callback)\n * @param {String} username\n * @param {Function} callback\n * @api private\n */\n\nvar getAdmin = function(username, callback) {\n    db.request({\n        type: 'GET',\n        url: '/_config/admins/' + encodeURIComponent(username),\n        contentType: 'application/json'\n    }, callback);\n};\n\n\n/**\n * Delete user from user database.\n *\n * @name deleteUser(authdb, id, user, callback)\n * @param {String} user database\n * @param {String} user id\n * @param {Object} user document\n * @param {Function} callback\n * @api private\n */\n\nvar deleteUser = function(authdb, id, user, callback) {\n    db.request({\n        type: 'DELETE',\n        url: '/' + db.encode(authdb) + '/' + db.encode(id) +\n             '?rev=' + db.encode(user._rev),\n        contentType: 'application/json'\n    }, callback);\n};\n\n/**\n * Delete user from admin database.\n *\n * @name deleteAdmin(username, callback)\n * @param {String} username\n * @param {Function} callback\n * @api private\n */\n\nvar deleteAdmin = function(username, callback) {\n    db.request({\n        type: 'DELETE',\n        url: '/_config/admins/' + encodeURIComponent(username),\n        contentType: 'application/json'\n    }, callback);\n};\n\n\n/**\n * Save user to user database.\n *\n * @name saveUser(authdb, doc, callback)\n * @param {String} user database\n * @param {Object} user document\n * @param {Function} callback\n * @api private\n */\n\nvar saveUser = function(authdb, doc, callback) {\n    var url = '/' + authdb + '/' + doc._id;\n    var req = {\n        type: 'PUT',\n        url: url,\n        data: JSON.stringify(doc),\n        processData: false,\n        contentType: 'application/json'\n    };\n    db.request(req, callback);\n};\n\n\n/**\n * Create a new user in the user database.\n *\n * @name createUser(username, password, properties, callback)\n * @param {String} username\n * @param {String} password\n * @param {Hash} properties\n * @param {Function} callback\n * @api private\n */\n\nvar createUser = function(username, password, properties, callback) {\n    var doc = {};\n    doc._id = 'org.couchdb.user:' + username;\n    doc.name = username;\n    doc.type = 'user';\n\n    _.extend(doc, properties);\n\n    db.newUUID(100, function (err, uuid) {\n        if (err) {\n            return callback(err);\n        }\n        doc.salt = uuid;\n        doc.password_sha = sha1.hex(password + doc.salt);\n\n        authdb(function (err, authdb) {\n            if (err) { return callback(err); }\n            saveUser(authdb, doc, callback);\n        });\n    });\n};\n\n\n/**\n * Create a new user in the admin database.\n *\n * @name createAdmin(username, password, callback)\n * @param {String} username\n * @param {String} password\n * @param {Function} callback\n * @api private\n */\n\nvar createAdmin = function(username, password, callback) {\n    var url = '/_config/admins/' + encodeURIComponent(username);\n    var req = {\n        type: 'PUT',\n        url: url,\n        data: JSON.stringify(password),\n        processData: false,\n        contentType: 'application/json'\n    };\n    db.request(req, callback);\n};\n\n\n/**\n * Sanitize the arguments by allowing to omit the properties and\n * predefining the roles if they're not set.\n *\n * @name sanitizeArguments(username, password, properties, cb, cb2)\n * @param {String} username\n * @param {String} password\n * @param {Hash} properties\n * @param {Function} cb\n * @param {Function} cb2\n * @api private\n */\n\nvar sanitizeArguments = function(username, password, properties, cb, cb2) {\n    if (!cb) {\n        cb = properties;\n        properties = {};\n    }\n    if (!properties.roles) {\n        properties.roles = [];\n    }\n    cb2(username, password, properties, cb);\n};\n\n\n/**\n * Deletes an existing user document, given its username. You\n * must be logged in as an administrative user for this function\n * to succeed.\n *\n * @name delete(username, callback)\n * @param {String} username - The username of the user to delete\n * @param {Function} callback(err,response) - Function called on completion of\n *     the operation\n * @api public\n *\n * ```javascript\n * users.delete('username', function (err) {\n *     if (err) // there was an error deleting the user\n *     else     // success\n * });\n * ```\n */\n\nexports.delete = function (username, callback) {\n    exports.get(username, function(err, user, options) {\n        if (err) { return callback(err); }\n\n        getAdmin(username, function(err, admin) {\n            if (err) {\n                if (err.status !== 404) {\n                    return callback(err);\n                }\n                deleteUser(options.authdb, options.id, user, callback);\n            }\n            else {\n                deleteAdmin(username, function(err) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    deleteUser(options.authdb, options.id, user, callback);\n                });\n            }\n        });\n    });\n};\n\n\n/**\n * Get a single user by username. The third argument to the callback is an info\n * object which returns the authdb used, and the real id of the user with\n * \"org.couchdb.user:\" prefix.\n *\n * @name get(username, callback)\n * @param {String} username - The username of the user to get\n * @param {Function} callback(err,user,info) - Function called on completion\n * @api public\n *\n * ```javascript\n * users.get('testuser', function (err, doc) {\n *     if (err) // there was an error fetching the user document\n *     else     // success\n * });\n * ```\n */\n\nexports.get = function(username, callback) {\n    var id = 'org.couchdb.user:' + username;\n\n    authdb(function (err, authdb) {\n        if (err) {\n            return callback(err);\n        }\n        db.request({\n            type: 'GET',\n            url: '/' + db.encode(authdb) + '/' + db.encode(id),\n            contentType: 'application/json'\n        },\n        function (err, user) {\n            callback(err, user, {authdb: authdb, id: id});\n        });\n    });\n};\n\n\n/**\n * List users in the auth database. By default, it will list all users.\n * By using the optional `q` parameter, you can pass additional options to the\n * `_all_docs` view for the auth database.\n *\n * @name list([q], callback)\n * @param {Object} q - Query parameters (optional)\n * @param {Function} callback(err,list) - Function called with the resulting\n *     list (or error)\n * @api public\n *\n * ```javascript\n * users.list(function (err, list) {\n *     if (err) // there was an error querying the auth database\n *     else     // success\n * });\n * ```\n */\n\nexports.list = function(q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    if (!q.startkey) {\n        q.startkey = '\"org.couchdb.user:\"';\n    }\n    if (!q.endkey) {\n        q.endkey = '\"org.couchdb.user_\"';\n    }\n    authdb(function (err, authdb) {\n        if (err) {\n            callback(err, null);\n        }\n        var req = {\n            type: 'GET',\n            url: '/' + db.encode(authdb) + '/_all_docs',\n            data: db.stringifyQuery(q),\n            expect_json: true\n        };\n        db.request(req, function(err, result) {\n            if (err) {\n                return callback(err, null);\n            }\n            var users = _(result.rows).select(function(row) {\n                return row.id.match(/^org\\.couchdb\\.user/);\n            });\n            callback(null, users);\n        });\n    });\n};\n\n\n/**\n * Creates a new user document with given username and password.\n * If properties.roles contains '_admin', user will be made admin.\n *\n * @name create(username, password, [properties], callback)\n * @param {String} username - The username of the new user\n * @param {String} password - The unhashed password for the new user\n * @param {Object} properties - Additional properties such as roles to extend\n *     the user document with (optional)\n * @param {Function} callback(err,response) - Function called on completion or\n *     error\n * @api public\n *\n * ```javascript\n * users.create('testuser', 'testing', {roles: ['example']}, function (err) {\n *     if (err) // an error occurred\n *     else     // successfully created new user\n * });\n * ```\n */\n\nexports.create = function (username, password, properties, callback) {\n    sanitizeArguments(username, password, properties, callback,\n        function(username, password, properties, callback) {\n            if (_.indexOf(properties.roles, \"_admin\") !== -1) {\n                createAdmin(username, password, function (err) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    properties.roles = [];\n                    createUser(username, password, properties, callback);\n                });\n            }\n            else {\n                createUser(username, password, properties, callback);\n            }\n    });\n};\n\n\n/**\n * Updates an existing user document. Similar usage to the create function.\n *\n * @name update(username, password, properties, callback)\n * @param {String} username - The username of the new user\n * @param {String} password - The unhashed password for the new user\n * @param {Object} properties - Additional properties such as roles to extend\n *     the user document with (optional)\n * @param {Function} callback(err,response) - Function called on completion or\n *     error\n * @api public\n *\n * ```javascript\n * users.update('testuser', 'testing', {roles: ['example']}, function (err) {\n *     if (err) // an error occurred\n *     else     // successfully updated user\n * });\n * ```\n */\n\nexports.update = function (username, password, properties, callback) {\n    sanitizeArguments(username, password, properties, callback,\n        function(username, password, properties, callback) {\n            exports.get(username, function (err, user, options) {\n                if (err) {\n                    return callback(err);\n                }\n                if (_.indexOf(properties.roles, \"_admin\") === -1) {\n                    _.extend(user, properties);\n                }\n                if (password) {\n                    user.password_sha = sha1.hex(password + user.salt);\n                }\n\n                saveUser(options.authdb, user, function (err, user) {\n                    \n                    session.info(function(err, session_info){\n                        if (session_info.userCtx.roles && _.indexOf(session_info.userCtx.roles, \"_admin\") !== -1) {\n                            if (_.indexOf(properties.roles, \"_admin\") !== -1) {\n                                createAdmin(username, password, function () {\n                                    callback(null, user);\n                                });\n                            }\n                            else {\n                                getAdmin(username, function(err, admin) {\n                                    if (err) {\n                                        if (err.status !== 404) {\n                                            return callback(err);\n                                        }\n                                        return callback(null, user);\n                                    }\n                                    else {\n                                        deleteAdmin(username, callback);\n                                    }\n                                });\n                            }\n                        } else {\n                            callback(err, user);\n                        }\n                    });\n                    \n                });\n            });\n    });\n};\n",
    "underscore": "//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);",
    "sha1": "/**\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS PUB 180-1. This module is used to hash user passwords in a way that's\r\n * compatible with CouchDB.\r\n *\r\n * This module is Copyright Paul Johnston 2000 - 2002 and distributed under the\r\n * BSD License. See http://pajhome.org.uk/crypt/md5 for details.\r\n *\r\n * @module\r\n */\r\n\r\n/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS PUB 180-1\r\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n */\r\n\r\n/*\r\n * Configurable variables. You may need to tweak these to be compatible with\r\n * the server-side, but the defaults work in most cases.\r\n */\r\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\r\nvar b64pad  = \"=\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\r\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\r\n\r\n/*\r\n * These are the functions you'll usually want to call\r\n * They take string arguments and return either hex or base-64 encoded strings\r\n */\r\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\r\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\r\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\r\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\r\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\r\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction sha1_vm_test()\r\n{\r\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\r\n}\r\n\r\n/*\r\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\r\n */\r\nfunction core_sha1(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << (24 - len % 32);\r\n  x[((len + 64 >> 9) << 4) + 15] = len;\r\n\r\n  var w = Array(80);\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n  var e = -1009589776;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n    var olde = e;\r\n\r\n    for(var j = 0; j < 80; j++)\r\n    {\r\n      if(j < 16) w[j] = x[i + j];\r\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\r\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\r\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\r\n      e = d;\r\n      d = c;\r\n      c = rol(b, 30);\r\n      b = a;\r\n      a = t;\r\n    }\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n    e = safe_add(e, olde);\r\n  }\r\n  return Array(a, b, c, d, e);\r\n\r\n}\r\n\r\n/*\r\n * Perform the appropriate triplet combination function for the current\r\n * iteration\r\n */\r\nfunction sha1_ft(t, b, c, d)\r\n{\r\n  if(t < 20) return (b & c) | ((~b) & d);\r\n  if(t < 40) return b ^ c ^ d;\r\n  if(t < 60) return (b & c) | (b & d) | (c & d);\r\n  return b ^ c ^ d;\r\n}\r\n\r\n/*\r\n * Determine the appropriate additive constant for the current iteration\r\n */\r\nfunction sha1_kt(t)\r\n{\r\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\r\n         (t < 60) ? -1894007588 : -899497514;\r\n}\r\n\r\n/*\r\n * Calculate the HMAC-SHA1 of a key and some data\r\n */\r\nfunction core_hmac_sha1(key, data)\r\n{\r\n  var bkey = str2binb(key);\r\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\r\n\r\n  var ipad = Array(16), opad = Array(16);\r\n  for(var i = 0; i < 16; i++)\r\n  {\r\n    ipad[i] = bkey[i] ^ 0x36363636;\r\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\r\n  }\r\n\r\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\r\n  return core_sha1(opad.concat(hash), 512 + 160);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\n/*\r\n * Convert an 8-bit or 16-bit string to an array of big-endian words\r\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\r\n */\r\nfunction str2binb(str)\r\n{\r\n  var bin = Array();\r\n  var mask = (1 << chrsz) - 1;\r\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\r\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\r\n  return bin;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a string\r\n */\r\nfunction binb2str(bin)\r\n{\r\n  var str = \"\";\r\n  var mask = (1 << chrsz) - 1;\r\n  for(var i = 0; i < bin.length * 32; i += chrsz)\r\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\r\n  return str;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a hex string.\r\n */\r\nfunction binb2hex(binarray)\r\n{\r\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n  var str = \"\";\r\n  for(var i = 0; i < binarray.length * 4; i++)\r\n  {\r\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\r\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\r\n  }\r\n  return str;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a base-64 string\r\n */\r\nfunction binb2b64(binarray)\r\n{\r\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n  var str = \"\";\r\n  for(var i = 0; i < binarray.length * 4; i += 3)\r\n  {\r\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\r\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\r\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\r\n    for(var j = 0; j < 4; j++)\r\n    {\r\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\r\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n\r\n/**\r\n * Hashes a string using SHA1 and returns a hex representation of it.\r\n *\r\n * @name hex(s)\r\n * @param {String} s\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.hex = hex_sha1;\r\n\r\n/**\r\n * Hashes a string using SHA1 and returns a base64 representation of it.\r\n *\r\n * @name base64(s)\r\n * @param {String} s\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.base64 = b64_sha1;\r\n\r\n/**\r\n * Hashes a string using SHA1 and returns a string representation of it.\r\n *\r\n * @name str(s)\r\n * @param {String} s\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.str = str_sha1;\r\n\r\n/**\r\n * Calculates the HMAC-SHA1 of a key and some data, returning a hex\r\n * representation of it.\r\n *\r\n * @name hex_hmac(key, data)\r\n * @param {String} key\r\n * @param {String} data\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.hex_hmac = hex_hmac_sha1;\r\n\r\n/**\r\n * Calculates the HMAC-SHA1 of a key and some data, returning a base64\r\n * representation of it.\r\n *\r\n * @name base64_hmac(key, data)\r\n * @param {String} key\r\n * @param {String} data\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.base64_hmac = b64_hmac_sha1;\r\n\r\n/**\r\n * Calculates the HMAC-SHA1 of a key and some data, returning a string\r\n * representation of it.\r\n *\r\n * @name str_hmac(key, data)\r\n * @param {String} key\r\n * @param {String} data\r\n * @returns {String}\r\n * @api public\r\n */\r\n\r\nexports.str_hmac = str_hmac_sha1;\r\n",
    "db": "/*global $: false */\n\n/**\n * ## DB Module\n *\n * This contains the core functions for dealing with CouchDB. That includes\n * document CRUD operations, querying views and creating/deleting databases.\n *\n *\n * ### Events\n *\n * The db module is an EventEmitter. See the\n * [events package](http://kan.so/packages/details/events) for more information.\n *\n * #### unauthorized\n *\n * Emitted by the db module when a request results in a 401 Unauthorized\n * response. This is listened to used by the session module to help detect\n * session timeouts etc.\n *\n * ```javascript\n * var db = require(\"db\");\n *\n * db.on('unauthorized', function (req) {\n *     // req is the ajax request object which returned 401\n * });\n * ```\n *\n * @module\n */\n\n\nvar events = require('events'),\n    _ = require('underscore')._;\n\n\n/**\n * Tests if running in the browser\n *\n * @returns {Boolean}\n */\n\nfunction isBrowser() {\n    return (typeof(window) !== 'undefined');\n}\n\n\n/**\n * This module is an EventEmitter, used for emitting 'unauthorized' events\n */\n\nvar exports = module.exports = new events.EventEmitter();\n\n\n/**\n * Taken from jQuery 1.4.4 so we can support more recent versions of jQuery.\n */\n\nvar httpData = function (xhr, type, s) {\n    var ct = xhr.getResponseHeader(\"content-type\") || \"\",\n        xml = type === \"xml\" || !type && ct.indexOf(\"xml\") >= 0,\n        data = xml ? xhr.responseXML : xhr.responseText;\n\n    if (xml && data.documentElement.nodeName === \"parsererror\") {\n        $.error(\"parsererror\");\n    }\n    if (s && s.dataFilter) {\n        data = s.dataFilter(data, type);\n    }\n    if (typeof data === \"string\") {\n        if (type === \"json\" || !type && ct.indexOf(\"json\") >= 0) {\n            data = $.parseJSON(data);\n        }\n        else if (type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0) {\n            $.globalEval(data);\n        }\n    }\n    return data;\n};\n\n\n/**\n * Returns a function for handling ajax responses from jquery and calls\n * the callback with the data or appropriate error.\n *\n * @param {Function} callback(err,response)\n * @api private\n */\n\nfunction onComplete(options, callback) {\n    return function (req) {\n        var resp;\n        var ctype = req.getResponseHeader('Content-Type');\n        if (ctype === 'application/json' || ctype === 'text/json') {\n            try {\n                resp = httpData(req, \"json\");\n            }\n            catch (e) {\n                return callback(e);\n            }\n        }\n        else {\n            if (options.expect_json) {\n                try {\n                    resp = httpData(req, \"json\");\n                }\n                catch (ex) {\n                    return callback(\n                        new Error('Expected JSON response, got ' + ctype)\n                    );\n                }\n            }\n            else {\n                resp = req.responseText;\n            }\n        }\n        if (req.status === 401) {\n            exports.emit('unauthorized', req);\n        }\n        if (req.status === 200 || req.status === 201 || req.status === 202) {\n            callback(null, resp);\n        }\n        else if (resp.error || resp.reason) {\n            var err = new Error(resp.reason || resp.error);\n            err.error = resp.error;\n            err.reason = resp.reason;\n            err.code = resp.code;\n            err.status = req.status;\n            callback(err);\n        }\n        else {\n            // TODO: map status code to meaningful error message\n            var err2 = new Error('Returned status code: ' + req.status);\n            err2.status = req.status;\n            callback(err2);\n        }\n    };\n}\n\n\n/**\n * Attempts to guess the database name and design doc id from the current URL,\n * or the loc paramter. Returns an object with 'db', 'design_doc' and 'root'\n * properties, or null for a URL not matching the expected format (perhaps\n * behing a vhost).\n *\n * You wouldn't normally use this function directly, but use `db.current()` to\n * return a DB object bound to the current database instead.\n *\n * @name guessCurrent([loc])\n * @param {String} loc - An alternative URL to use instead of window.location\n *     (optional)\n * @returns {Object|null} - An object with 'db', 'design_doc' and 'root'\n *     properties, or null for a URL not matching the\n *     expected format (perhaps behing a vhost)\n * @api public\n */\n\nexports.guessCurrent = function (loc) {\n    var loc = loc || window.location;\n\n    /**\n     * A database must be named with all lowercase letters (a-z), digits (0-9),\n     * or any of the _$()+-/ characters and must end with a slash in the URL.\n     * The name has to start with a lowercase letter (a-z).\n     *\n     * http://wiki.apache.org/couchdb/HTTP_database_API\n     */\n\n    var re = /\\/([a-z][a-z0-9_\\$\\(\\)\\+-\\/]*)\\/_design\\/([^\\/]+)\\//;\n    var match = re.exec(loc.pathname);\n\n    if (match) {\n        return {\n            db: match[1],\n            design_doc: match[2],\n            root: '/'\n        }\n    }\n    return null;\n};\n\n/**\n * Converts an object to a string of properly escaped URL parameters.\n *\n * @name escapeUrlParams([obj])\n * @param {Object} obj - An object containing url parameters, with\n *       parameter names stored as property names (or keys).\n * @returns {String}\n * @api public\n */\n\nexports.escapeUrlParams = function (obj) {\n    var rv = [ ];\n    for (var key in obj) {\n        rv.push(\n            encodeURIComponent(key) +\n                '=' + encodeURIComponent(obj[key])\n        );\n    }\n    return (rv.length > 0 ? ('?' + rv.join('&')) : '');\n};\n\n/**\n * Encodes a document id or view, list or show name. This also will make sure\n * the forward-slash is not escaped for documents with id's beginning with\n * \"\\_design/\".\n *\n * @name encode(str)\n * @param {String} str - the name or id to escape\n * @returns {String}\n * @api public\n */\n\nexports.encode = function (str) {\n    return encodeURIComponent(str).replace(/^_design%2F/, '_design/');\n};\n\n\n/**\n * Properly encodes query parameters to CouchDB views etc. Handle complex\n * keys and other non-string parameters by passing through JSON.stringify.\n * Returns a shallow-copied clone of the original query after complex values\n * have been stringified.\n *\n * @name stringifyQuery(query)\n * @param {Object} query\n * @returns {Object}\n * @api public\n */\n\nexports.stringifyQuery = function (query) {\n    var q = {};\n    for (var k in query) {\n        if (typeof query[k] !== 'string') {\n            q[k] = JSON.stringify(query[k]);\n        }\n        else {\n            q[k] = query[k];\n        }\n    }\n    return q;\n};\n\n\n/**\n * Make a request, with some default settings, proper callback\n * handling, and optional caching. Used behind-the-scenes by\n * most other DB module functions.\n *\n * @name request(options, callback)\n * @param {Object} options\n * @param {Function} callback(err,response)\n * @api public\n */\n\nexports.request = function (options, callback) {\n    options.complete = onComplete(options, callback);\n    options.dataType = 'json';\n    $.ajax(options);\n};\n\n\n/**\n * Creates a CouchDB database.\n *\n * If you're running behind a virtual host you'll need to set up\n * appropriate rewrites for a DELETE request to '/' either turning off safe\n * rewrites or setting up a new vhost entry.\n *\n * @name createDatabase(name, callback)\n * @param {String} name\n * @param {Function} callback(err,response)\n * @api public\n */\n\nexports.createDatabase = function (name, callback) {\n    var req = {\n        type: 'PUT',\n        url: '/' + exports.encode(name.replace(/^\\/+/, ''))\n    };\n    exports.request(req, callback);\n};\n\n/**\n * Deletes a CouchDB database.\n *\n * If you're running behind a virtual host you'll need to set up\n * appropriate rewrites for a DELETE request to '/' either turning off safe\n * rewrites or setting up a new vhost entry.\n *\n * @name deleteDatabase(name, callback)\n * @param {String} name\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: detect when 'name' argument is a url and don't construct a url then\nexports.deleteDatabase = function (name, callback) {\n    var req = {\n        type: 'DELETE',\n        url: '/' + exports.encode(name.replace(/^\\/+/, ''))\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Lists all databses\n *\n * If you're running behind a virtual host you'll need to set up\n * appropriate rewrites for a DELETE request to '/' either turning off safe\n * rewrites or setting up a new vhost entry.\n *\n * @name allDbs(callback)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nexports.allDbs = function (callback) {\n    var req = {\n        type: 'GET',\n        url: '/_all_dbs'\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Returns a new UUID generated by CouchDB. Its possible to cache\n * multiple UUIDs for later use, to avoid making too many requests.\n *\n * @name newUUID(cacheNum, callback)\n * @param {Number} cacheNum (optional, default: 1)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nvar uuidCache = [];\n\nexports.newUUID = function (cacheNum, callback) {\n    if (!callback) {\n        callback = cacheNum;\n        cacheNum = 1;\n    }\n    if (uuidCache.length) {\n        return callback(null, uuidCache.shift());\n    }\n    var req = {\n        url: '/_uuids',\n        data: {count: cacheNum},\n        expect_json: true\n    };\n    exports.request(req, function (err, resp) {\n        if (err) {\n            return callback(err);\n        }\n        uuidCache = resp.uuids;\n        callback(null, uuidCache.shift());\n    });\n};\n\n\n/**\n * DB object created by use(dbname) function\n */\n\nfunction DB(url) {\n    this.url = url;\n    // add the module functions to the DB object\n    for (var k in exports) {\n        this[k] = exports[k];\n    }\n};\n\n\n/**\n * Creates a new DB object with methods operating on the database at 'url'\n *\n * The DB object also exposes the same module-level methods (eg, createDatabase)\n * so it can be used in-place of the db exports object, for example:\n *\n * ```javascript\n * var db = require('db').use('mydb');\n *\n * db.createDatabase('example', function (err, resp) {\n *     // do something\n * });\n * ```\n *\n * @name use(url)\n * @param {String} url - The url to bind the new DB object to\n * @returns {DB}\n * @api public\n */\n\n// TODO: handle full urls, not just db names\nexports.use = function (url) {\n    /* Force leading slash; make absolute path */\n    return new DB((url.substr(0, 1) !== '/' ? '/' : '') + url);\n};\n\n/**\n * Attempts to guess the current DB name and return a DB object using that.\n * Should work reliably unless running behind a virtual host.\n *\n * Throws an error if the current database url cannot be detected.\n *\n * The DB object also exposes the same module-level methods (eg, createDatabase)\n * so it can be used in-place of the db exports object, for example:\n *\n * ```javascript\n * var db = require('db').current();\n *\n * db.createDatabase('example', function (err, resp) {\n *     // do something\n * });\n * ```\n *\n * @name current()\n * @returns {DB}\n * @api public\n */\n\nexports.current = function () {\n    // guess current db url etc\n    var curr = exports.guessCurrent();\n    if (!curr) {\n        throw new Error(\n            'Cannot guess current database URL, if running behind a virtual ' +\n            'host you need to explicitly set the database URL using ' +\n            'db.use(database_url) instead of db.current()'\n        );\n    }\n    return exports.use(curr.db);\n};\n\n\n/**\n * Fetches a rewrite from the database the app is running on. Results\n * are passed to the callback, with the first argument of the callback\n * reserved for any exceptions that occurred (node.js style).\n *\n * @name DB.getRewrite(name, path, [q], callback)\n * @param {String} name - the name of the design doc\n * @param {String} path\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getRewrite = function (name, path, /*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    // prepend forward-slash if missing\n    path = (path[0] === '/') ? path: '/' + path;\n\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/_design/' + exports.encode(name) + '/_rewrite' + path,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Queries all design documents in the database.\n *\n * @name DB.allDesignDocs([q], callback)\n * @param {Object} q - query parameters to pass to /_all_docs (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.allDesignDocs = function (/*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    q.startkey = '\"_design\"';\n    q.endkey = '\"_design0\"';\n    this.allDocs(q, callback);\n};\n\n\n/**\n * Queries all documents in the database (include design docs).\n *\n * @name DB.allDocs([q], callback)\n * @param {Object} q - query parameters to pass to /_all_docs (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.allDocs = function (/*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/_all_docs',\n        data: data,\n        expect_json: true\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetches a document from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.getDoc(id, [q], callback)\n * @param {String} id\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getDoc = function (id, /*optional*/q, callback) {\n    if (!id) {\n        throw new Error('getDoc requires an id parameter to work properly');\n    }\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/' + exports.encode(id),\n        expect_json: true,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Saves a document to the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.saveDoc(doc, callback)\n * @param {Object} doc\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.saveDoc = function (doc, callback) {\n    var method, url = this.url;\n    if (doc._id === undefined) {\n        method = \"POST\";\n    }\n    else {\n        method = \"PUT\";\n        url += '/' + doc._id;\n    }\n    try {\n        var data = JSON.stringify(doc);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        type: method,\n        url: url,\n        data: data,\n        processData: false,\n        contentType: 'application/json',\n        expect_json: true\n    };\n    exports.request(req, callback);\n};\n\n/**\n * Deletes a document from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.removeDoc(doc, callback)\n * @param {Object} doc\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.removeDoc = function (doc, callback) {\n    if (!doc._id) {\n        throw new Error('removeDoc requires an _id field in your document');\n    }\n    if (!doc._rev) {\n        throw new Error('removeDoc requires a _rev field in your document');\n    }\n    var req = {\n        type: 'DELETE',\n        url: this.url + '/' + exports.encode(doc._id) +\n             '?rev=' + exports.encode(doc._rev)\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetches a view from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * @name DB.getView(name, view, [q], callback)\n * @param {String} name - name of the design doc to use\n * @param {String} view - name of the view\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getView = function (name, view, /*opt*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    var viewname = exports.encode(view);\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: (this.url +\n            '/_design/' + exports.encode(name) +\n            '/_view/' + viewname\n        ),\n        expect_json: true,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetches a spatial view from the database the app is running on. Results are\n * passed to the callback, with the first argument of the callback reserved\n * for any exceptions that occurred (node.js style).\n *\n * __Parameters:__\n * * bbox - the bounding box filter e.g.: bbox: '0,0,180,90'\n * * plane_bounds - e.g.: plane_bounds: '-180,-90,180,90'\n * * stale - stale: 'ok' prevents the spatial index to be rebuilt\n * * count - count: true will only return the number of geometries\n *\n * @name DB.getSpatialView(name, view, q, callback)\n * @param {String} name - name of the design doc to use\n * @param {String} view - name of the view\n * @param {Object} q - query parameters (see options above)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.getSpatialView = function (name, view, q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    var viewname = exports.encode(view);\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: (this.url +\n            '/_design/' + exports.encode(name) +\n            '/_spatial/' + viewname\n        ),\n        expect_json: true,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Transforms and fetches a view through a list from the database the app\n * is running on. Results are passed to the callback, with the first\n * argument of the callback reserved for any exceptions that occurred\n * (node.js style).\n *\n * @name DB.getList(name, list, view, [q], callback)\n * @param {String} name - name of the design doc to use\n * @param {String} list - name of the list function\n * @param {String} view - name of the view to apply the list function to\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: run list function client-side?\nDB.prototype.getList = function (name, list, view, /*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    var listname = exports.encode(list);\n    var viewname = exports.encode(view);\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        url: this.url + '/_design/' + exports.encode(name) +\n            '/_list/' + listname + '/' + viewname,\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n/**\n * Transforms and fetches a document through a show from the database the app\n * is running on. Results are passed to the callback, with the first\n * argument of the callback reserved for any exceptions that occurred\n * (node.js style).\n *\n * @name DB.getShow(name, show, docid, [q], callback)\n * @param {String} name - name of the design doc to use\n * @param {String} show - name of the show function\n * @param {String} docid - id of the document to apply the show function to\n * @param {Object} q (optional)\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: run show function client-side?\nDB.prototype.getShow = function (name, show, docid, /*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n    try {\n        var data = exports.stringifyQuery(q);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var showname = exports.encode(show);\n    var show_url = this.url + '/_design/' +\n        exports.encode(name) + '/_show/' + exports.encode(showname);\n    var req = {\n        url: show_url + (docid ? '/' + exports.encode(docid): ''),\n        data: data\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Fetch a design document from CouchDB.\n *\n * @name DB.getDesignDoc(name, callback)\n * @param name The name of (i.e. path to) the design document without the\n *     preceeding \"\\_design/\".\n * @param callback The callback to invoke when the request completes.\n * @api public\n */\n\nDB.prototype.getDesignDoc = function (name, callback) {\n    this.getDoc('_design/' + name, function (err, ddoc) {\n        if (err) {\n            return callback(err);\n        }\n        return callback(null, ddoc);\n    });\n};\n\n/**\n * Gets information about the database.\n *\n * @name DB.info(callback)\n * @param {Function} callback(err,response)\n * @api public\n */\n\nDB.prototype.info = function (callback) {\n    var req = {\n        url: this.url,\n        expect_json: true,\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Listen to the changes feed for a database.\n *\n * __Options:__\n * * _filter_ - the filter function to use\n * * _since_ - the update_seq to start listening from\n * * _heartbeat_ - the heartbeat time (defaults to 10 seconds)\n * * _include_docs_ - whether to include docs in the results\n *\n * Returning false from the callback will cancel the changes listener\n *\n * @name DB.changes([q], callback)\n * @param {Object} q (optional) query parameters (see options above)\n * @param {Function} callback(err,response)\n * @api public\n */\n\n// TODO: change this to use an EventEmitter\nDB.prototype.changes = function (/*optional*/q, callback) {\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n\n    var that = this;\n\n    q = q || {};\n    q.feed = 'longpoll';\n    q.heartbeat = q.heartbeat || 10000;\n\n    function getChanges(since) {\n        q.since = since;\n        try {\n            var data = exports.stringifyQuery(q);\n        }\n        catch (e) {\n            return callback(e);\n        }\n        var req = {\n            type: 'GET',\n            expect_json: true,\n            url: that.url + '/_changes',\n            data: data\n        };\n        var cb = function (err, data) {\n            var result = callback.apply(this, arguments);\n            if (result !== false) {\n                getChanges(data.last_seq);\n            }\n        }\n        exports.request(req, cb);\n    }\n\n    // use setTimeout to pass control back to the browser briefly to\n    // allow the loading spinner to stop on page load\n    setTimeout(function () {\n        if (q.hasOwnProperty('since')) {\n            getChanges(q.since);\n        }\n        else {\n            that.info(function (err, info) {\n                if (err) {\n                    return callback(err);\n                }\n                getChanges(info.update_seq);\n            });\n        }\n    }, 0);\n};\n\n\n/**\n * Saves a list of documents, without using separate requests.\n * This function uses CouchDB's HTTP bulk document API (_bulk_docs).\n * The return value is an array of objects, each containing an 'id'\n * and a 'rev' field. The return value is passed to the callback you\n * provide via its second argument; the first argument of the callback\n * is reserved for any exceptions that occurred (node.js style).\n *\n * **Options:**\n * * *all_or\\_nothing* - Require that all documents be saved\n *   successfully (or saved with a conflict); otherwise roll\n *   back the operation.\n *\n * @name DB.bulkSave(docs, [options], callback)\n * @param {Array} docs An array of documents; each document is an object\n * @param {Object} options (optional) Options for the bulk-save operation.\n * @param {Function} callback(err,response) - A function to accept results\n *          and/or errors. Document update conflicts are reported in the\n *          results array.\n * @api public\n */\n\nDB.prototype.bulkSave = function (docs, /*optional*/ options, callback) {\n    if (!_.isArray(docs)) {\n        throw new Error(\n            'bulkSave requires an array of documents to work properly'\n        );\n    }\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n    options.docs = docs;\n    try {\n        var data = JSON.stringify(options);\n    }\n    catch (e) {\n        return callback(e);\n    }\n    var req = {\n        type: 'POST',\n        url: this.url + '/_bulk_docs',\n        data: data,\n        processData: false,\n        contentType: 'application/json',\n        expect_json: true\n    };\n    exports.request(req, callback);\n};\n\n\n/**\n * Requests a list of documents, using only a single HTTP request.\n * This function uses CouchDB's HTTP bulk document API (_all_docs).\n * The return value is an array of objects, each of which is a document.\n * The return value is passed to the callback you provide via its second\n * argument; the first argument of the callback is reserved for any\n * exceptions that occurred (node.js style).\n *\n * @name DB.bulkGet(keys, [q], callback)\n * @param {Array} keys An array of documents identifiers (i.e. strings).\n * @param {Object} q (optional) Query parameters for the bulk-read operation.\n * @param {Function} callback(err,response) - A function to accept results\n *          and/or errors. Document update conflicts are reported in the\n *          results array.\n * @api public\n */\n\nDB.prototype.bulkGet = function (keys, /*optional*/ q, callback) {\n    if (keys && !_.isArray(keys)) {\n        throw new Error(\n            'bulkGet requires that _id values be supplied as a list'\n        );\n    }\n    if (!callback) {\n        callback = q;\n        q = {};\n    }\n\n    /* Encode every query-string option:\n        CouchDB requires that these be JSON, even though they\n        will be URL-encoded as part of the request process. */\n\n    try {\n        for (var k in q) {\n            q[k] = JSON.stringify(q[k]);\n        }\n    }\n    catch (e) {\n        return callback(e);\n    }\n\n    /* Make request:\n        If we have a list of keys, use a post request containing\n        a JSON-encoded list of keys. Otherwise, use a get request. */\n\n    var req = {\n        expect_json: true,\n        url: this.url + '/_all_docs' + exports.escapeUrlParams(q)\n    };\n    if (keys) {\n        try {\n            var data = JSON.stringify({ keys: keys});\n        }\n        catch (e) {\n            return callback(e);\n        }\n        req = _.extend(req, {\n            type: 'POST',\n            processData: false,\n            contentType: 'application/json',\n            data: data\n        });\n    } else {\n        req = _.extend(req, {\n            type: 'GET'\n        });\n    }\n\n    exports.request(req, callback);\n};\n\n\n/**\n * DB methods can only be called client-side\n */\n\n_.each(_.keys(DB.prototype), function (k) {\n    var _fn = DB.prototype[k];\n    DB.prototype[k] = function () {\n        if (!isBrowser()) {\n            throw new Error(k + ' cannot be called server-side');\n        }\n        return _fn.apply(this, arguments);\n    };\n});\n",
    "session": "/**\n * ## Session module\n *\n * This module contains functions related to session management. Logging in,\n * logging out and checking the current state of a user's session.\n *\n * Functions in this module follow the node.js callback style. The first\n * argument is an error object (if one occurred), the following arguments are\n * the results of the operation. The callback is always the last argument to a\n * function.\n *\n *\n * ### Events\n *\n * The session module is an EventEmitter. See the\n * [events package](http://kan.so/packages/details/events) for more information.\n *\n * #### change\n *\n * Emitted whenever a change to the user's session is detected, this\n * can occur as the result of a login/logout call or by getting the user's\n * session info (and it's changed).\n *\n * ```javascript\n * var session = require(\"session\");\n *\n * session.on('change', function (userCtx) {\n *     // update session information, eg \"Logged in as ...\"\n * });\n * ```\n *\n * @module\n */\n\n\nvar events = require('events'),\n    db = require('db');\n\n\n/**\n * Quick utility function for testing if running in the browser, since\n * these functions won't run on CouchDB server-side\n */\n\nfunction isBrowser() {\n    return (typeof(window) !== 'undefined');\n}\n\n/**\n * When a db call results in an unauthorized response, the user's session is\n * checked to see if their session has timed out or they've logged out in\n * another screen.\n *\n * This check is throttled to once per second, to avoid flooding the server if\n * multiple requests are made with incorrect permissions.\n */\n\nvar last_session_check = 0;\n\ndb.on('unauthorized', function (req) {\n    // db call returned 'Unauthorized', check the user's session if it's not\n    // been checked on an 'Unauthorized' repsonse in the last second\n    if (last_session_check < new Date().getTime() - 1000) {\n        exports.info();\n    }\n});\n\n\n/**\n * This module is an EventEmitter, used for handling 'change' events\n */\n\nvar exports = module.exports = new events.EventEmitter();\n\n\n/**\n * Attempt to login using the username and password provided.\n *\n * @name login(username, password, callback)\n * @param {String} username - the username to login with\n * @param {String} password - the user's password (unhashed)\n * @param {Function} callback - function called with the result of the login\n *     attempt\n * @api public\n *\n * ```javascript\n * session.login('testuser', 'password', function (err, response) {\n *     if (err) // an error occurred logging in\n *     else     // success\n * });\n * ```\n */\n\nexports.login = function (username, password, callback) {\n    if (!isBrowser()) {\n        throw new Error('login cannot be called server-side');\n    }\n    db.request({\n        type: \"POST\",\n        url: \"/_session\",\n        data: {name: username, password: password}\n    },\n    function (err, resp) {\n        if (resp && resp.ok) {\n            // TODO: for some reason resp.name is set to null in the response\n            // even though the roles are correct for the user! Look into this\n            // and see if its a bug in couchdb, for now, just using the username\n            // given to the login function instead, since we know the login\n            // request was accepted.\n            exports.userCtx = {name: username, roles: resp.roles};\n            exports.session = {userCtx: exports.userCtx};\n            exports.emit('change', exports.userCtx);\n        }\n        if (callback) {\n            callback(err, resp);\n        }\n    });\n};\n\n\n/**\n * Logs out the current user.\n *\n * @name logout(callback)\n * @param {Function} callback - function called with the result of the logout\n *     attempt\n * @api public\n *\n * ```javascript\n * session.logout(function (err, response) {\n *     if (err) // an error occurred logging out\n *     else     // success\n * });\n * ```\n */\n\nexports.logout = function (callback) {\n    if (!isBrowser()) {\n        throw new Error('logout cannot be called server-side');\n    }\n    db.request({\n        type: \"DELETE\",\n        url: \"/_session\", // don't need baseURL, /_session always available\n        username: \"_\",\n        password : \"_\"\n    },\n    function (err, resp) {\n        if (resp && resp.ok) {\n            exports.userCtx = {name: null, roles: []};\n            exports.session = {userCtx: exports.userCtx};\n            exports.emit('change', exports.userCtx);\n        }\n        if (callback) {\n            callback(err, resp);\n        }\n    });\n};\n\n\n/**\n * Returns the current user's session information. The info object contains a\n * `userCtx` property and an `info` property. The first contains the name and\n * roles of the current user, the second contains information about the user\n * database and authentication handlers.\n *\n * @name info(callback)\n * @param {Function} callback - function called with the session information\n * @api public\n *\n * ```javascript\n * session.info(function (err, info) {\n *     if (err) // an error occurred getting session info\n *     else     // success\n * });\n * ```\n */\n\nexports.info = function (callback) {\n    if (!isBrowser()) {\n        throw new Error('info cannot be called server-side');\n    }\n    db.request({\n        type: \"GET\",\n        url: \"/_session\"\n    },\n    function (err, resp) {\n        var oldUserCtx = exports.userCtx;\n        exports.session = resp;\n        exports.userCtx = (resp && resp.userCtx) || {name: null, roles: []};\n        // TODO: should this check for differences in more than just name?\n        if (!oldUserCtx || oldUserCtx.name !== exports.userCtx.name) {\n            exports.emit('change', exports.userCtx);\n        }\n        if (callback) {\n            callback(err, resp);\n        }\n    });\n};\n",
    "events": "/**\n * ## Events module\n *\n * This is a browser port of the node.js events module. Many objects and\n * modules emit events and these are instances of events.EventEmitter.\n *\n * You can access this module by doing: `require(\"events\")`\n *\n * Functions can then be attached to objects, to be executed when an event is\n * emitted. These functions are called listeners.\n *\n * @module\n */\n\n\n/**\n * To access the EventEmitter class, require('events').EventEmitter.\n *\n * When an EventEmitter instance experiences an error, the typical action is to\n * emit an 'error' event. Error events are treated as a special case. If there\n * is no listener for it, then the default action is for the error to throw.\n *\n * All EventEmitters emit the event 'newListener' when new listeners are added.\n *\n * @name events.EventEmitter\n * @api public\n *\n * ```javascript\n * var EventEmitter = require('events').EventEmitter;\n *\n * // create an event emitter\n * var emitter = new EventEmitter();\n * ```\n */\n\nvar EventEmitter = exports.EventEmitter = function () {};\n\nvar isArray = Array.isArray || function (obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n\n/**\n * By default EventEmitters will print a warning if more than 10 listeners are\n * added for a particular event. This is a useful default which helps finding\n * memory leaks. Obviously not all Emitters should be limited to 10. This\n * function allows that to be increased. Set to zero for unlimited.\n *\n * @name emitter.setMaxListeners(n)\n * @param {Number} n - The maximum number of listeners\n * @api public\n */\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\n/**\n * Execute each of the listeners in order with the supplied arguments.\n *\n * @name emitter.emit(event, [arg1], [arg2], [...])\n * @param {String} event - The event name/id to fire\n * @api public\n */\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * Adds a listener to the end of the listeners array for the specified event.\n *\n * @name emitter.on(event, listener) | emitter.addListener(event, listener)\n * @param {String} event - The event name/id to listen for\n * @param {Function} listener - The function to bind to the event\n * @api public\n *\n * ```javascript\n * session.on('change', function (userCtx) {\n *     console.log('session changed!');\n * });\n * ```\n */\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds a one time listener for the event. This listener is invoked only the\n * next time the event is fired, after which it is removed.\n *\n * @name emitter.once(event, listener)\n * @param {String} event- The event name/id to listen for\n * @param {Function} listener - The function to bind to the event\n * @api public\n *\n * ```javascript\n * db.once('unauthorized', function (req) {\n *     // this event listener will fire once, then be unbound\n * });\n * ```\n */\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\n/**\n * Remove a listener from the listener array for the specified event. Caution:\n * changes array indices in the listener array behind the listener.\n *\n * @name emitter.removeListener(event, listener)\n * @param {String} event - The event name/id to remove the listener from\n * @param {Function} listener - The listener function to remove\n * @api public\n *\n * ```javascript\n * var callback = function (init) {\n *     console.log('duality app loaded');\n * };\n * devents.on('init', callback);\n * // ...\n * devents.removeListener('init', callback);\n * ```\n */\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\n/**\n * Removes all listeners, or those of the specified event.\n *\n * @name emitter.removeAllListeners([event])\n * @param {String} event - Event name/id to remove all listeners for (optional)\n * @api public\n */\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\n/**\n * Returns an array of listeners for the specified event. This array can be\n * manipulated, e.g. to remove listeners.\n *\n * @name emitter.listeners(event)\n * @param {String} events - The event name/id to return listeners for\n * @api public\n *\n * ```javascript\n * session.on('change', function (stream) {\n *     console.log('session changed');\n * });\n * console.log(util.inspect(session.listeners('change'))); // [ [Function] ]\n * ```\n */\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n\n/**\n * @name emitter Event: 'newListener'\n *\n * This event is emitted any time someone adds a new listener.\n *\n * ```javascript\n * emitter.on('newListener', function (event, listener) {\n *     // new listener added\n * });\n * ```\n */\n",
    "rewrites": [],
    "kanso": {
        "config": {
            "name": "oauth-key-management",
            "version": "0.0.1",
            "description": "OAuth Key Management",
            "attachments": [
                "index.html",
                "css",
                "images"
            ],
            "modules": [
                "lib"
            ],
            "load": "lib/app",
            "dependencies": {
                "attachments": null,
                "modules": null,
                "users": null,
                "underscore": null,
                "properties": null
            },
            "minify": false
        },
        "build_time": "2012-10-03T21:27:24Z",
        "kanso_version": "0.2.2"
    }
}
